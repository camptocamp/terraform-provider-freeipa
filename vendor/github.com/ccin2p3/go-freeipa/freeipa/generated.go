// Code generated by `github.com/ccin2p3/go-freeipa/gen` - DO NOT EDIT.

package freeipa;

import (
  "time"
	"encoding/json"
  "fmt"
  "reflect"
  "strconv"
)

var apiVersion = "2.237"

type request struct {
  Method string `json:"method"`
  Params []interface{} `json:"params"`
}


/*
Create new ACI.
*/
func (c *Client) AciAdd(
  reqArgs *AciAddArgs,
  optArgs *AciAddOptionalArgs, // can be nil
) (*AciAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciAddKwParams{
    AciAddArgs: reqArgs,
    AciAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciAddArgs struct {
  
    /*
ACI name

    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
Permissions
Permissions to grant(read, write, add, delete, all)
    */
    Permissions []string `json:"permissions,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix string `json:"aciprefix,omitempty"`
  }

type AciAddOptionalArgs struct {
  
    /*
Permission
Permission ACI grants access to
    */
    Permission *string `json:"permission,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*
Attributes to which the permission applies
Attributes
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Type
type of IPA object (user, group, host, hostgroup, service, netgroup)
    */
    Type *string `json:"type,omitempty"`
  
    /*
Member of
Member of a group
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
Filter
Legal LDAP filter (e.g. ou=Engineering)
    */
    Filter *string `json:"filter,omitempty"`
  
    /*
Subtree
Subtree to apply ACI to
    */
    Subtree *string `json:"subtree,omitempty"`
  
    /*
Target group
Group to apply ACI to
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Target your own entry (self)
Apply ACI to your own entry (self)
    */
    Selfaci *bool `json:"selfaci,omitempty"`
  
    /*

Test the ACI syntax but don't write anything
    */
    Test *bool `json:"test,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type aciAddKwParams struct {
  *AciAddArgs
  *AciAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciAddResponse struct {
	Error  *Error      `json:"error"`
	Result *AciAddResult `json:"result"`
}
type AciAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Aci `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AciAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciAddResult%v", string(b))
}

/*
Delete ACI.
*/
func (c *Client) AciDel(
  reqArgs *AciDelArgs,
  optArgs *AciDelOptionalArgs, // can be nil
) (*AciDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciDelKwParams{
    AciDelArgs: reqArgs,
    AciDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciDelArgs struct {
  
    /*
ACI name

    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix string `json:"aciprefix,omitempty"`
  }

type AciDelOptionalArgs struct {
  }

type aciDelKwParams struct {
  *AciDelArgs
  *AciDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciDelResponse struct {
	Error  *Error      `json:"error"`
	Result *AciDelResult `json:"result"`
}
type AciDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AciDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciDelResult%v", string(b))
}

/*
Search for ACIs.

    Returns a list of ACIs

    EXAMPLES:

     To find all ACIs that apply directly to members of the group ipausers:
       ipa aci-find --memberof=ipausers

     To find all ACIs that grant add access:
       ipa aci-find --permissions=add

    Note that the find command only looks for the given text in the set of
    ACIs, it does not evaluate the ACIs to see if something would apply.
    For example, searching on memberof=ipausers will find all ACIs that
    have ipausers as a memberof. There may be other ACIs that apply to
    members of that group indirectly.
*/
func (c *Client) AciFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AciFindArgs,
  optArgs *AciFindOptionalArgs, // can be nil
) (*AciFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciFindKwParams{
    AciFindArgs: reqArgs,
    AciFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciFindArgs struct {
  }

type AciFindOptionalArgs struct {
  
    /*
ACI name

    */
    Aciname *string `json:"aciname,omitempty"`
  
    /*
Permission
Permission ACI grants access to
    */
    Permission *string `json:"permission,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*
Permissions
Permissions to grant(read, write, add, delete, all)
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes to which the permission applies
Attributes
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Type
type of IPA object (user, group, host, hostgroup, service, netgroup)
    */
    Type *string `json:"type,omitempty"`
  
    /*
Member of
Member of a group
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
Filter
Legal LDAP filter (e.g. ou=Engineering)
    */
    Filter *string `json:"filter,omitempty"`
  
    /*
Subtree
Subtree to apply ACI to
    */
    Subtree *string `json:"subtree,omitempty"`
  
    /*
Target group
Group to apply ACI to
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Target your own entry (self)
Apply ACI to your own entry (self)
    */
    Selfaci *bool `json:"selfaci,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix *string `json:"aciprefix,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type aciFindKwParams struct {
  *AciFindArgs
  *AciFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciFindResponse struct {
	Error  *Error      `json:"error"`
	Result *AciFindResult `json:"result"`
}
type AciFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Aci `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *AciFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciFindResult%v", string(b))
}

/*
Modify ACI.
*/
func (c *Client) AciMod(
  reqArgs *AciModArgs,
  optArgs *AciModOptionalArgs, // can be nil
) (*AciModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciModKwParams{
    AciModArgs: reqArgs,
    AciModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciModArgs struct {
  
    /*
ACI name

    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix string `json:"aciprefix,omitempty"`
  }

type AciModOptionalArgs struct {
  
    /*
Permission
Permission ACI grants access to
    */
    Permission *string `json:"permission,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*
Permissions
Permissions to grant(read, write, add, delete, all)
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes to which the permission applies
Attributes
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Type
type of IPA object (user, group, host, hostgroup, service, netgroup)
    */
    Type *string `json:"type,omitempty"`
  
    /*
Member of
Member of a group
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
Filter
Legal LDAP filter (e.g. ou=Engineering)
    */
    Filter *string `json:"filter,omitempty"`
  
    /*
Subtree
Subtree to apply ACI to
    */
    Subtree *string `json:"subtree,omitempty"`
  
    /*
Target group
Group to apply ACI to
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Target your own entry (self)
Apply ACI to your own entry (self)
    */
    Selfaci *bool `json:"selfaci,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type aciModKwParams struct {
  *AciModArgs
  *AciModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciModResponse struct {
	Error  *Error      `json:"error"`
	Result *AciModResult `json:"result"`
}
type AciModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Aci `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AciModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciModResult%v", string(b))
}

/*
Rename an ACI.
*/
func (c *Client) AciRename(
  reqArgs *AciRenameArgs,
  optArgs *AciRenameOptionalArgs, // can be nil
) (*AciRenameResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciRenameKwParams{
    AciRenameArgs: reqArgs,
    AciRenameOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_rename",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciRenameResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciRenameArgs struct {
  
    /*
ACI name

    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix string `json:"aciprefix,omitempty"`
  
    /*

New ACI name
    */
    Newname string `json:"newname,omitempty"`
  }

type AciRenameOptionalArgs struct {
  
    /*
Permission
Permission ACI grants access to
    */
    Permission *string `json:"permission,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*
Permissions
Permissions to grant(read, write, add, delete, all)
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes to which the permission applies
Attributes
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Type
type of IPA object (user, group, host, hostgroup, service, netgroup)
    */
    Type *string `json:"type,omitempty"`
  
    /*
Member of
Member of a group
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
Filter
Legal LDAP filter (e.g. ou=Engineering)
    */
    Filter *string `json:"filter,omitempty"`
  
    /*
Subtree
Subtree to apply ACI to
    */
    Subtree *string `json:"subtree,omitempty"`
  
    /*
Target group
Group to apply ACI to
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Target your own entry (self)
Apply ACI to your own entry (self)
    */
    Selfaci *bool `json:"selfaci,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type aciRenameKwParams struct {
  *AciRenameArgs
  *AciRenameOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciRenameResponse struct {
	Error  *Error      `json:"error"`
	Result *AciRenameResult `json:"result"`
}
type AciRenameResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AciRenameResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciRenameResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciRenameResult%v", string(b))
}

/*
Display a single ACI given an ACI name.
*/
func (c *Client) AciShow(
  reqArgs *AciShowArgs,
  optArgs *AciShowOptionalArgs, // can be nil
) (*AciShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := aciShowKwParams{
    AciShowArgs: reqArgs,
    AciShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "aci_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res aciShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AciShowArgs struct {
  
    /*
ACI name

    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix string `json:"aciprefix,omitempty"`
  }

type AciShowOptionalArgs struct {
  
    /*
Location of the ACI

    */
    Location *string `json:"location,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type aciShowKwParams struct {
  *AciShowArgs
  *AciShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type aciShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AciShowResult `json:"result"`
}
type AciShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Aci `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AciShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AciShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AciShowResult%v", string(b))
}

/*
Determine whether ipa-adtrust-install has been run on this system
*/
func (c *Client) AdtrustIsEnabled(
  reqArgs *AdtrustIsEnabledArgs,
  optArgs *AdtrustIsEnabledOptionalArgs, // can be nil
) (*AdtrustIsEnabledResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := adtrustIsEnabledKwParams{
    AdtrustIsEnabledArgs: reqArgs,
    AdtrustIsEnabledOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "adtrust_is_enabled",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res adtrustIsEnabledResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AdtrustIsEnabledArgs struct {
  }

type AdtrustIsEnabledOptionalArgs struct {
  }

type adtrustIsEnabledKwParams struct {
  *AdtrustIsEnabledArgs
  *AdtrustIsEnabledOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type adtrustIsEnabledResponse struct {
	Error  *Error      `json:"error"`
	Result *AdtrustIsEnabledResult `json:"result"`
}
type AdtrustIsEnabledResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *AdtrustIsEnabledResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AdtrustIsEnabledResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AdtrustIsEnabledResult%v", string(b))
}

/*
Add an automember rule.
*/
func (c *Client) AutomemberAdd(
  reqArgs *AutomemberAddArgs,
  optArgs *AutomemberAddOptionalArgs, // can be nil
) (*AutomemberAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberAddKwParams{
    AutomemberAddArgs: reqArgs,
    AutomemberAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberAddArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberAddOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberAddKwParams struct {
  *AutomemberAddArgs
  *AutomemberAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberAddResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberAddResult `json:"result"`
}
type AutomemberAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Automember `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomemberAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberAddResult%v", string(b))
}

/*
Add conditions to an automember rule.
*/
func (c *Client) AutomemberAddCondition(
  reqArgs *AutomemberAddConditionArgs,
  optArgs *AutomemberAddConditionOptionalArgs, // can be nil
) (*AutomemberAddConditionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberAddConditionKwParams{
    AutomemberAddConditionArgs: reqArgs,
    AutomemberAddConditionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_add_condition",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberAddConditionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberAddConditionArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Attribute Key
Attribute to filter via regex. For example fqdn for a host, or manager for a user
    */
    Key string `json:"key,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberAddConditionOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*
Inclusive Regex
Inclusive Regex
    */
    Automemberinclusiveregex *[]string `json:"automemberinclusiveregex,omitempty"`
  
    /*
Exclusive Regex
Exclusive Regex
    */
    Automemberexclusiveregex *[]string `json:"automemberexclusiveregex,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberAddConditionKwParams struct {
  *AutomemberAddConditionArgs
  *AutomemberAddConditionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberAddConditionResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberAddConditionResult `json:"result"`
}
type AutomemberAddConditionResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  
    /*
Conditions that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of conditions added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *AutomemberAddConditionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberAddConditionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberAddConditionResult%v", string(b))
}

/*
Remove default (fallback) group for all unmatched entries.
*/
func (c *Client) AutomemberDefaultGroupRemove(
  reqArgs *AutomemberDefaultGroupRemoveArgs,
  optArgs *AutomemberDefaultGroupRemoveOptionalArgs, // can be nil
) (*AutomemberDefaultGroupRemoveResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberDefaultGroupRemoveKwParams{
    AutomemberDefaultGroupRemoveArgs: reqArgs,
    AutomemberDefaultGroupRemoveOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_default_group_remove",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberDefaultGroupRemoveResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberDefaultGroupRemoveArgs struct {
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberDefaultGroupRemoveOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberDefaultGroupRemoveKwParams struct {
  *AutomemberDefaultGroupRemoveArgs
  *AutomemberDefaultGroupRemoveOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberDefaultGroupRemoveResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberDefaultGroupRemoveResult `json:"result"`
}
type AutomemberDefaultGroupRemoveResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomemberDefaultGroupRemoveResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberDefaultGroupRemoveResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberDefaultGroupRemoveResult%v", string(b))
}

/*
Set default (fallback) group for all unmatched entries.
*/
func (c *Client) AutomemberDefaultGroupSet(
  reqArgs *AutomemberDefaultGroupSetArgs,
  optArgs *AutomemberDefaultGroupSetOptionalArgs, // can be nil
) (*AutomemberDefaultGroupSetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberDefaultGroupSetKwParams{
    AutomemberDefaultGroupSetArgs: reqArgs,
    AutomemberDefaultGroupSetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_default_group_set",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberDefaultGroupSetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberDefaultGroupSetArgs struct {
  
    /*
Default (fallback) Group
Default (fallback) group for entries to land
    */
    Automemberdefaultgroup string `json:"automemberdefaultgroup,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberDefaultGroupSetOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberDefaultGroupSetKwParams struct {
  *AutomemberDefaultGroupSetArgs
  *AutomemberDefaultGroupSetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberDefaultGroupSetResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberDefaultGroupSetResult `json:"result"`
}
type AutomemberDefaultGroupSetResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomemberDefaultGroupSetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberDefaultGroupSetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberDefaultGroupSetResult%v", string(b))
}

/*
Display information about the default (fallback) automember groups.
*/
func (c *Client) AutomemberDefaultGroupShow(
  reqArgs *AutomemberDefaultGroupShowArgs,
  optArgs *AutomemberDefaultGroupShowOptionalArgs, // can be nil
) (*AutomemberDefaultGroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberDefaultGroupShowKwParams{
    AutomemberDefaultGroupShowArgs: reqArgs,
    AutomemberDefaultGroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_default_group_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberDefaultGroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberDefaultGroupShowArgs struct {
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberDefaultGroupShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberDefaultGroupShowKwParams struct {
  *AutomemberDefaultGroupShowArgs
  *AutomemberDefaultGroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberDefaultGroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberDefaultGroupShowResult `json:"result"`
}
type AutomemberDefaultGroupShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result AutomemberDefaultGroup `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomemberDefaultGroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberDefaultGroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberDefaultGroupShowResult%v", string(b))
}

/*
Delete an automember rule.
*/
func (c *Client) AutomemberDel(
  reqArgs *AutomemberDelArgs,
  optArgs *AutomemberDelOptionalArgs, // can be nil
) (*AutomemberDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberDelKwParams{
    AutomemberDelArgs: reqArgs,
    AutomemberDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberDelArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn []string `json:"cn,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberDelOptionalArgs struct {
  }

type automemberDelKwParams struct {
  *AutomemberDelArgs
  *AutomemberDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberDelResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberDelResult `json:"result"`
}
type AutomemberDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *AutomemberDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberDelResult%v", string(b))
}

/*
Search for automember rules.
*/
func (c *Client) AutomemberFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AutomemberFindArgs,
  optArgs *AutomemberFindOptionalArgs, // can be nil
) (*AutomemberFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberFindKwParams{
    AutomemberFindArgs: reqArgs,
    AutomemberFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberFindArgs struct {
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberFindOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("automember-rule")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type automemberFindKwParams struct {
  *AutomemberFindArgs
  *AutomemberFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberFindResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberFindResult `json:"result"`
}
type AutomemberFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Automember `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *AutomemberFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberFindResult%v", string(b))
}

/*
Search for orphan automember rules. The command might need to be run as
    a privileged user user to get all orphan rules.
*/
func (c *Client) AutomemberFindOrphans(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AutomemberFindOrphansArgs,
  optArgs *AutomemberFindOrphansOptionalArgs, // can be nil
) (*AutomemberFindOrphansResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberFindOrphansKwParams{
    AutomemberFindOrphansArgs: reqArgs,
    AutomemberFindOrphansOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_find_orphans",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberFindOrphansResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberFindOrphansArgs struct {
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberFindOrphansOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*

Remove orphan automember rules
    */
    Remove *bool `json:"remove,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("automember-rule")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type automemberFindOrphansKwParams struct {
  *AutomemberFindOrphansArgs
  *AutomemberFindOrphansOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberFindOrphansResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberFindOrphansResult `json:"result"`
}
type AutomemberFindOrphansResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []interface{} `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *AutomemberFindOrphansResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberFindOrphansResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberFindOrphansResult%v", string(b))
}

/*
Modify an automember rule.
*/
func (c *Client) AutomemberMod(
  reqArgs *AutomemberModArgs,
  optArgs *AutomemberModOptionalArgs, // can be nil
) (*AutomemberModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberModKwParams{
    AutomemberModArgs: reqArgs,
    AutomemberModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberModArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberModOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberModKwParams struct {
  *AutomemberModArgs
  *AutomemberModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberModResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberModResult `json:"result"`
}
type AutomemberModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Automember `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomemberModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberModResult%v", string(b))
}

/*
Rebuild auto membership.
*/
func (c *Client) AutomemberRebuild(
  reqArgs *AutomemberRebuildArgs,
  optArgs *AutomemberRebuildOptionalArgs, // can be nil
) (*AutomemberRebuildResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberRebuildKwParams{
    AutomemberRebuildArgs: reqArgs,
    AutomemberRebuildOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_rebuild",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberRebuildResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberRebuildArgs struct {
  }

type AutomemberRebuildOptionalArgs struct {
  
    /*
Rebuild membership for all members of a grouping
Grouping to which the rule applies
    */
    Type *string `json:"type,omitempty"`
  
    /*
Users
Rebuild membership for specified users
    */
    Users *[]string `json:"users,omitempty"`
  
    /*
Hosts
Rebuild membership for specified hosts
    */
    Hosts *[]string `json:"hosts,omitempty"`
  
    /*
No wait
Don't wait for rebuilding membership
    */
    NoWait *bool `json:"no_wait,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberRebuildKwParams struct {
  *AutomemberRebuildArgs
  *AutomemberRebuildOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberRebuildResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberRebuildResult `json:"result"`
}
type AutomemberRebuildResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *AutomemberRebuildResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberRebuildResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberRebuildResult%v", string(b))
}

/*
Remove conditions from an automember rule.
*/
func (c *Client) AutomemberRemoveCondition(
  reqArgs *AutomemberRemoveConditionArgs,
  optArgs *AutomemberRemoveConditionOptionalArgs, // can be nil
) (*AutomemberRemoveConditionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberRemoveConditionKwParams{
    AutomemberRemoveConditionArgs: reqArgs,
    AutomemberRemoveConditionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_remove_condition",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberRemoveConditionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberRemoveConditionArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Attribute Key
Attribute to filter via regex. For example fqdn for a host, or manager for a user
    */
    Key string `json:"key,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberRemoveConditionOptionalArgs struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*
Inclusive Regex
Inclusive Regex
    */
    Automemberinclusiveregex *[]string `json:"automemberinclusiveregex,omitempty"`
  
    /*
Exclusive Regex
Exclusive Regex
    */
    Automemberexclusiveregex *[]string `json:"automemberexclusiveregex,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberRemoveConditionKwParams struct {
  *AutomemberRemoveConditionArgs
  *AutomemberRemoveConditionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberRemoveConditionResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberRemoveConditionResult `json:"result"`
}
type AutomemberRemoveConditionResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  
    /*
Conditions that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of conditions removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *AutomemberRemoveConditionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberRemoveConditionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberRemoveConditionResult%v", string(b))
}

/*
Display information about an automember rule.
*/
func (c *Client) AutomemberShow(
  reqArgs *AutomemberShowArgs,
  optArgs *AutomemberShowOptionalArgs, // can be nil
) (*AutomemberShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automemberShowKwParams{
    AutomemberShowArgs: reqArgs,
    AutomemberShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automember_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automemberShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomemberShowArgs struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Grouping Type
Grouping to which the rule applies
    */
    Type string `json:"type,omitempty"`
  }

type AutomemberShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automemberShowKwParams struct {
  *AutomemberShowArgs
  *AutomemberShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automemberShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomemberShowResult `json:"result"`
}
type AutomemberShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Automember `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomemberShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberShowResult%v", string(b))
}

/*
Create a new automount key.
*/
func (c *Client) AutomountkeyAdd(
  reqArgs *AutomountkeyAddArgs,
  optArgs *AutomountkeyAddOptionalArgs, // can be nil
) (*AutomountkeyAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountkeyAddKwParams{
    AutomountkeyAddArgs: reqArgs,
    AutomountkeyAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountkey_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountkeyAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountkeyAddArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapautomountmapname string `json:"automountmapautomountmapname,omitempty"`
  
    /*
Key
Automount key name.
    */
    Automountkey string `json:"automountkey,omitempty"`
  
    /*
Mount information

    */
    Automountinformation string `json:"automountinformation,omitempty"`
  }

type AutomountkeyAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountkeyAddKwParams struct {
  *AutomountkeyAddArgs
  *AutomountkeyAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountkeyAddResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountkeyAddResult `json:"result"`
}
type AutomountkeyAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Automountkey `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomountkeyAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountkeyAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountkeyAddResult%v", string(b))
}

/*
Delete an automount key.
*/
func (c *Client) AutomountkeyDel(
  reqArgs *AutomountkeyDelArgs,
  optArgs *AutomountkeyDelOptionalArgs, // can be nil
) (*AutomountkeyDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountkeyDelKwParams{
    AutomountkeyDelArgs: reqArgs,
    AutomountkeyDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountkey_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountkeyDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountkeyDelArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapautomountmapname string `json:"automountmapautomountmapname,omitempty"`
  
    /*
Key
Automount key name.
    */
    Automountkey string `json:"automountkey,omitempty"`
  }

type AutomountkeyDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Mount information

    */
    Automountinformation *string `json:"automountinformation,omitempty"`
  }

type automountkeyDelKwParams struct {
  *AutomountkeyDelArgs
  *AutomountkeyDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountkeyDelResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountkeyDelResult `json:"result"`
}
type AutomountkeyDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *AutomountkeyDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountkeyDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountkeyDelResult%v", string(b))
}

/*
Search for an automount key.
*/
func (c *Client) AutomountkeyFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AutomountkeyFindArgs,
  optArgs *AutomountkeyFindOptionalArgs, // can be nil
) (*AutomountkeyFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountkeyFindKwParams{
    AutomountkeyFindArgs: reqArgs,
    AutomountkeyFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountkey_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountkeyFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountkeyFindArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapautomountmapname string `json:"automountmapautomountmapname,omitempty"`
  }

type AutomountkeyFindOptionalArgs struct {
  
    /*
Key
Automount key name.
    */
    Automountkey *string `json:"automountkey,omitempty"`
  
    /*
Mount information

    */
    Automountinformation *string `json:"automountinformation,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountkeyFindKwParams struct {
  *AutomountkeyFindArgs
  *AutomountkeyFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountkeyFindResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountkeyFindResult `json:"result"`
}
type AutomountkeyFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Automountkey `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *AutomountkeyFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountkeyFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountkeyFindResult%v", string(b))
}

/*
Modify an automount key.
*/
func (c *Client) AutomountkeyMod(
  reqArgs *AutomountkeyModArgs,
  optArgs *AutomountkeyModOptionalArgs, // can be nil
) (*AutomountkeyModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountkeyModKwParams{
    AutomountkeyModArgs: reqArgs,
    AutomountkeyModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountkey_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountkeyModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountkeyModArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapautomountmapname string `json:"automountmapautomountmapname,omitempty"`
  
    /*
Key
Automount key name.
    */
    Automountkey string `json:"automountkey,omitempty"`
  }

type AutomountkeyModOptionalArgs struct {
  
    /*
Mount information

    */
    Automountinformation *string `json:"automountinformation,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
New mount information

    */
    Newautomountinformation *string `json:"newautomountinformation,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the automount key object
    */
    Rename *string `json:"rename,omitempty"`
  }

type automountkeyModKwParams struct {
  *AutomountkeyModArgs
  *AutomountkeyModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountkeyModResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountkeyModResult `json:"result"`
}
type AutomountkeyModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Automountkey `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomountkeyModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountkeyModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountkeyModResult%v", string(b))
}

/*
Display an automount key.
*/
func (c *Client) AutomountkeyShow(
  reqArgs *AutomountkeyShowArgs,
  optArgs *AutomountkeyShowOptionalArgs, // can be nil
) (*AutomountkeyShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountkeyShowKwParams{
    AutomountkeyShowArgs: reqArgs,
    AutomountkeyShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountkey_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountkeyShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountkeyShowArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapautomountmapname string `json:"automountmapautomountmapname,omitempty"`
  
    /*
Key
Automount key name.
    */
    Automountkey string `json:"automountkey,omitempty"`
  }

type AutomountkeyShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Mount information

    */
    Automountinformation *string `json:"automountinformation,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountkeyShowKwParams struct {
  *AutomountkeyShowArgs
  *AutomountkeyShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountkeyShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountkeyShowResult `json:"result"`
}
type AutomountkeyShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Automountkey `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomountkeyShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountkeyShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountkeyShowResult%v", string(b))
}

/*
Create a new automount location.
*/
func (c *Client) AutomountlocationAdd(
  reqArgs *AutomountlocationAddArgs,
  optArgs *AutomountlocationAddOptionalArgs, // can be nil
) (*AutomountlocationAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountlocationAddKwParams{
    AutomountlocationAddArgs: reqArgs,
    AutomountlocationAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountlocation_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountlocationAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountlocationAddArgs struct {
  
    /*
Location
Automount location name.
    */
    Cn string `json:"cn,omitempty"`
  }

type AutomountlocationAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountlocationAddKwParams struct {
  *AutomountlocationAddArgs
  *AutomountlocationAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountlocationAddResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountlocationAddResult `json:"result"`
}
type AutomountlocationAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Automountlocation `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomountlocationAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountlocationAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountlocationAddResult%v", string(b))
}

/*
Delete an automount location.
*/
func (c *Client) AutomountlocationDel(
  reqArgs *AutomountlocationDelArgs,
  optArgs *AutomountlocationDelOptionalArgs, // can be nil
) (*AutomountlocationDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountlocationDelKwParams{
    AutomountlocationDelArgs: reqArgs,
    AutomountlocationDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountlocation_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountlocationDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountlocationDelArgs struct {
  
    /*
Location
Automount location name.
    */
    Cn []string `json:"cn,omitempty"`
  }

type AutomountlocationDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type automountlocationDelKwParams struct {
  *AutomountlocationDelArgs
  *AutomountlocationDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountlocationDelResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountlocationDelResult `json:"result"`
}
type AutomountlocationDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *AutomountlocationDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountlocationDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountlocationDelResult%v", string(b))
}

/*
Search for an automount location.
*/
func (c *Client) AutomountlocationFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AutomountlocationFindArgs,
  optArgs *AutomountlocationFindOptionalArgs, // can be nil
) (*AutomountlocationFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountlocationFindKwParams{
    AutomountlocationFindArgs: reqArgs,
    AutomountlocationFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountlocation_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountlocationFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountlocationFindArgs struct {
  }

type AutomountlocationFindOptionalArgs struct {
  
    /*
Location
Automount location name.
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("location")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type automountlocationFindKwParams struct {
  *AutomountlocationFindArgs
  *AutomountlocationFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountlocationFindResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountlocationFindResult `json:"result"`
}
type AutomountlocationFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Automountlocation `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *AutomountlocationFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountlocationFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountlocationFindResult%v", string(b))
}

/*
Display an automount location.
*/
func (c *Client) AutomountlocationShow(
  reqArgs *AutomountlocationShowArgs,
  optArgs *AutomountlocationShowOptionalArgs, // can be nil
) (*AutomountlocationShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountlocationShowKwParams{
    AutomountlocationShowArgs: reqArgs,
    AutomountlocationShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountlocation_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountlocationShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountlocationShowArgs struct {
  
    /*
Location
Automount location name.
    */
    Cn string `json:"cn,omitempty"`
  }

type AutomountlocationShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountlocationShowKwParams struct {
  *AutomountlocationShowArgs
  *AutomountlocationShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountlocationShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountlocationShowResult `json:"result"`
}
type AutomountlocationShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Automountlocation `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomountlocationShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountlocationShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountlocationShowResult%v", string(b))
}

/*
Generate automount files for a specific location.
*/
func (c *Client) AutomountlocationTofiles(
  reqArgs *AutomountlocationTofilesArgs,
  optArgs *AutomountlocationTofilesOptionalArgs, // can be nil
) (*AutomountlocationTofilesResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountlocationTofilesKwParams{
    AutomountlocationTofilesArgs: reqArgs,
    AutomountlocationTofilesOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountlocation_tofiles",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountlocationTofilesResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountlocationTofilesArgs struct {
  
    /*
Location
Automount location name.
    */
    Cn string `json:"cn,omitempty"`
  }

type AutomountlocationTofilesOptionalArgs struct {
  }

type automountlocationTofilesKwParams struct {
  *AutomountlocationTofilesArgs
  *AutomountlocationTofilesOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountlocationTofilesResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountlocationTofilesResult `json:"result"`
}
type AutomountlocationTofilesResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *AutomountlocationTofilesResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountlocationTofilesResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountlocationTofilesResult%v", string(b))
}

/*
Create a new automount map.
*/
func (c *Client) AutomountmapAdd(
  reqArgs *AutomountmapAddArgs,
  optArgs *AutomountmapAddOptionalArgs, // can be nil
) (*AutomountmapAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapAddKwParams{
    AutomountmapAddArgs: reqArgs,
    AutomountmapAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapAddArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapname string `json:"automountmapname,omitempty"`
  }

type AutomountmapAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountmapAddKwParams struct {
  *AutomountmapAddArgs
  *AutomountmapAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapAddResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapAddResult `json:"result"`
}
type AutomountmapAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Automountmap `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomountmapAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapAddResult%v", string(b))
}

/*
Create a new indirect mount point.
*/
func (c *Client) AutomountmapAddIndirect(
  reqArgs *AutomountmapAddIndirectArgs,
  optArgs *AutomountmapAddIndirectOptionalArgs, // can be nil
) (*AutomountmapAddIndirectResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapAddIndirectKwParams{
    AutomountmapAddIndirectArgs: reqArgs,
    AutomountmapAddIndirectOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_add_indirect",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapAddIndirectResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapAddIndirectArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapname string `json:"automountmapname,omitempty"`
  
    /*
Mount point

    */
    Key string `json:"key,omitempty"`
  }

type AutomountmapAddIndirectOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Parent map
Name of parent automount map (default: auto.master).
    */
    Parentmap *string `json:"parentmap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountmapAddIndirectKwParams struct {
  *AutomountmapAddIndirectArgs
  *AutomountmapAddIndirectOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapAddIndirectResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapAddIndirectResult `json:"result"`
}
type AutomountmapAddIndirectResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomountmapAddIndirectResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapAddIndirectResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapAddIndirectResult%v", string(b))
}

/*
Delete an automount map.
*/
func (c *Client) AutomountmapDel(
  reqArgs *AutomountmapDelArgs,
  optArgs *AutomountmapDelOptionalArgs, // can be nil
) (*AutomountmapDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapDelKwParams{
    AutomountmapDelArgs: reqArgs,
    AutomountmapDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapDelArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapname []string `json:"automountmapname,omitempty"`
  }

type AutomountmapDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type automountmapDelKwParams struct {
  *AutomountmapDelArgs
  *AutomountmapDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapDelResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapDelResult `json:"result"`
}
type AutomountmapDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *AutomountmapDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapDelResult%v", string(b))
}

/*
Search for an automount map.
*/
func (c *Client) AutomountmapFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *AutomountmapFindArgs,
  optArgs *AutomountmapFindOptionalArgs, // can be nil
) (*AutomountmapFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapFindKwParams{
    AutomountmapFindArgs: reqArgs,
    AutomountmapFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapFindArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  }

type AutomountmapFindOptionalArgs struct {
  
    /*
Map
Automount map name.
    */
    Automountmapname *string `json:"automountmapname,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("map")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type automountmapFindKwParams struct {
  *AutomountmapFindArgs
  *AutomountmapFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapFindResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapFindResult `json:"result"`
}
type AutomountmapFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Automountmap `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *AutomountmapFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapFindResult%v", string(b))
}

/*
Modify an automount map.
*/
func (c *Client) AutomountmapMod(
  reqArgs *AutomountmapModArgs,
  optArgs *AutomountmapModOptionalArgs, // can be nil
) (*AutomountmapModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapModKwParams{
    AutomountmapModArgs: reqArgs,
    AutomountmapModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapModArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapname string `json:"automountmapname,omitempty"`
  }

type AutomountmapModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountmapModKwParams struct {
  *AutomountmapModArgs
  *AutomountmapModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapModResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapModResult `json:"result"`
}
type AutomountmapModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Automountmap `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomountmapModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapModResult%v", string(b))
}

/*
Display an automount map.
*/
func (c *Client) AutomountmapShow(
  reqArgs *AutomountmapShowArgs,
  optArgs *AutomountmapShowOptionalArgs, // can be nil
) (*AutomountmapShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := automountmapShowKwParams{
    AutomountmapShowArgs: reqArgs,
    AutomountmapShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "automountmap_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res automountmapShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type AutomountmapShowArgs struct {
  
    /*
Location
Automount location name.
    */
    Automountlocationcn string `json:"automountlocationcn,omitempty"`
  
    /*
Map
Automount map name.
    */
    Automountmapname string `json:"automountmapname,omitempty"`
  }

type AutomountmapShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type automountmapShowKwParams struct {
  *AutomountmapShowArgs
  *AutomountmapShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type automountmapShowResponse struct {
	Error  *Error      `json:"error"`
	Result *AutomountmapShowResult `json:"result"`
}
type AutomountmapShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Automountmap `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *AutomountmapShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomountmapShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomountmapShowResult%v", string(b))
}

/*
Create a CA.
*/
func (c *Client) CaAdd(
  reqArgs *CaAddArgs,
  optArgs *CaAddOptionalArgs, // can be nil
) (*CaAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caAddKwParams{
    CaAddArgs: reqArgs,
    CaAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaAddArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Subject DN
Subject Distinguished Name
    */
    Ipacasubjectdn string `json:"ipacasubjectdn,omitempty"`
  }

type CaAddOptionalArgs struct {
  
    /*
Description
Description of the purpose of the CA
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Include certificate chain in output
    */
    Chain *bool `json:"chain,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type caAddKwParams struct {
  *CaAddArgs
  *CaAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caAddResponse struct {
	Error  *Error      `json:"error"`
	Result *CaAddResult `json:"result"`
}
type CaAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Ca `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CaAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaAddResult%v", string(b))
}

/*
Delete a CA.
*/
func (c *Client) CaDel(
  reqArgs *CaDelArgs,
  optArgs *CaDelOptionalArgs, // can be nil
) (*CaDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caDelKwParams{
    CaDelArgs: reqArgs,
    CaDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaDelArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn []string `json:"cn,omitempty"`
  }

type CaDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type caDelKwParams struct {
  *CaDelArgs
  *CaDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caDelResponse struct {
	Error  *Error      `json:"error"`
	Result *CaDelResult `json:"result"`
}
type CaDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *CaDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaDelResult%v", string(b))
}

/*
Disable a CA.
*/
func (c *Client) CaDisable(
  reqArgs *CaDisableArgs,
  optArgs *CaDisableOptionalArgs, // can be nil
) (*CaDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caDisableKwParams{
    CaDisableArgs: reqArgs,
    CaDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaDisableArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn string `json:"cn,omitempty"`
  }

type CaDisableOptionalArgs struct {
  }

type caDisableKwParams struct {
  *CaDisableArgs
  *CaDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *CaDisableResult `json:"result"`
}
type CaDisableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CaDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaDisableResult%v", string(b))
}

/*
Enable a CA.
*/
func (c *Client) CaEnable(
  reqArgs *CaEnableArgs,
  optArgs *CaEnableOptionalArgs, // can be nil
) (*CaEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caEnableKwParams{
    CaEnableArgs: reqArgs,
    CaEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_enable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaEnableArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn string `json:"cn,omitempty"`
  }

type CaEnableOptionalArgs struct {
  }

type caEnableKwParams struct {
  *CaEnableArgs
  *CaEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *CaEnableResult `json:"result"`
}
type CaEnableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CaEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaEnableResult%v", string(b))
}

/*
Search for CAs.
*/
func (c *Client) CaFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CaFindArgs,
  optArgs *CaFindOptionalArgs, // can be nil
) (*CaFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caFindKwParams{
    CaFindArgs: reqArgs,
    CaFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaFindArgs struct {
  }

type CaFindOptionalArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Description of the purpose of the CA
    */
    Description *string `json:"description,omitempty"`
  
    /*
Authority ID
Dogtag Authority ID
    */
    Ipacaid *string `json:"ipacaid,omitempty"`
  
    /*
Subject DN
Subject Distinguished Name
    */
    Ipacasubjectdn *string `json:"ipacasubjectdn,omitempty"`
  
    /*
Issuer DN
Issuer Distinguished Name
    */
    Ipacaissuerdn *string `json:"ipacaissuerdn,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type caFindKwParams struct {
  *CaFindArgs
  *CaFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CaFindResult `json:"result"`
}
type CaFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Ca `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *CaFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaFindResult%v", string(b))
}

/*
Checks if any of the servers has the CA service enabled.
*/
func (c *Client) CaIsEnabled(
  reqArgs *CaIsEnabledArgs,
  optArgs *CaIsEnabledOptionalArgs, // can be nil
) (*CaIsEnabledResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caIsEnabledKwParams{
    CaIsEnabledArgs: reqArgs,
    CaIsEnabledOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_is_enabled",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caIsEnabledResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaIsEnabledArgs struct {
  }

type CaIsEnabledOptionalArgs struct {
  }

type caIsEnabledKwParams struct {
  *CaIsEnabledArgs
  *CaIsEnabledOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caIsEnabledResponse struct {
	Error  *Error      `json:"error"`
	Result *CaIsEnabledResult `json:"result"`
}
type CaIsEnabledResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *CaIsEnabledResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaIsEnabledResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaIsEnabledResult%v", string(b))
}

/*
Modify CA configuration.
*/
func (c *Client) CaMod(
  reqArgs *CaModArgs,
  optArgs *CaModOptionalArgs, // can be nil
) (*CaModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caModKwParams{
    CaModArgs: reqArgs,
    CaModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaModArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn string `json:"cn,omitempty"`
  }

type CaModOptionalArgs struct {
  
    /*
Description
Description of the purpose of the CA
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the Certificate Authority object
    */
    Rename *string `json:"rename,omitempty"`
  }

type caModKwParams struct {
  *CaModArgs
  *CaModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caModResponse struct {
	Error  *Error      `json:"error"`
	Result *CaModResult `json:"result"`
}
type CaModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Ca `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CaModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaModResult%v", string(b))
}

/*
Display the properties of a CA.
*/
func (c *Client) CaShow(
  reqArgs *CaShowArgs,
  optArgs *CaShowOptionalArgs, // can be nil
) (*CaShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caShowKwParams{
    CaShowArgs: reqArgs,
    CaShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ca_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaShowArgs struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn string `json:"cn,omitempty"`
  }

type CaShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Include certificate chain in output
    */
    Chain *bool `json:"chain,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type caShowKwParams struct {
  *CaShowArgs
  *CaShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CaShowResult `json:"result"`
}
type CaShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Ca `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CaShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaShowResult%v", string(b))
}

/*
Create a new CA ACL.
*/
func (c *Client) CaaclAdd(
  reqArgs *CaaclAddArgs,
  optArgs *CaaclAddOptionalArgs, // can be nil
) (*CaaclAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddKwParams{
    CaaclAddArgs: reqArgs,
    CaaclAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
CA category
CA category the ACL applies to
    */
    Ipacacategory *string `json:"ipacacategory,omitempty"`
  
    /*
Profile category
Profile category the ACL applies to
    */
    Ipacertprofilecategory *string `json:"ipacertprofilecategory,omitempty"`
  
    /*
User category
User category the ACL applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the ACL applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Service category
Service category the ACL applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type caaclAddKwParams struct {
  *CaaclAddArgs
  *CaaclAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddResult `json:"result"`
}
type CaaclAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Caacl `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CaaclAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddResult%v", string(b))
}

/*
Add CAs to a CA ACL.
*/
func (c *Client) CaaclAddCa(
  reqArgs *CaaclAddCaArgs,
  optArgs *CaaclAddCaOptionalArgs, // can be nil
) (*CaaclAddCaResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddCaKwParams{
    CaaclAddCaArgs: reqArgs,
    CaaclAddCaOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add_ca",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddCaResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddCaArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddCaOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member Certificate Authority
Certificate Authorities to add
    */
    Ca *[]string `json:"ca,omitempty"`
  }

type caaclAddCaKwParams struct {
  *CaaclAddCaArgs
  *CaaclAddCaOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddCaResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddCaResult `json:"result"`
}
type CaaclAddCaResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *CaaclAddCaResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddCaResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddCaResult%v", string(b))
}

/*
Add target hosts and hostgroups to a CA ACL.
*/
func (c *Client) CaaclAddHost(
  reqArgs *CaaclAddHostArgs,
  optArgs *CaaclAddHostOptionalArgs, // can be nil
) (*CaaclAddHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddHostKwParams{
    CaaclAddHostArgs: reqArgs,
    CaaclAddHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add_host",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddHostArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type caaclAddHostKwParams struct {
  *CaaclAddHostArgs
  *CaaclAddHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddHostResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddHostResult `json:"result"`
}
type CaaclAddHostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *CaaclAddHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddHostResult%v", string(b))
}

/*
Add profiles to a CA ACL.
*/
func (c *Client) CaaclAddProfile(
  reqArgs *CaaclAddProfileArgs,
  optArgs *CaaclAddProfileOptionalArgs, // can be nil
) (*CaaclAddProfileResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddProfileKwParams{
    CaaclAddProfileArgs: reqArgs,
    CaaclAddProfileOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add_profile",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddProfileResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddProfileArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddProfileOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member Certificate Profile
Certificate Profiles to add
    */
    Certprofile *[]string `json:"certprofile,omitempty"`
  }

type caaclAddProfileKwParams struct {
  *CaaclAddProfileArgs
  *CaaclAddProfileOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddProfileResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddProfileResult `json:"result"`
}
type CaaclAddProfileResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *CaaclAddProfileResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddProfileResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddProfileResult%v", string(b))
}

/*
Add services to a CA ACL.
*/
func (c *Client) CaaclAddService(
  reqArgs *CaaclAddServiceArgs,
  optArgs *CaaclAddServiceOptionalArgs, // can be nil
) (*CaaclAddServiceResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddServiceKwParams{
    CaaclAddServiceArgs: reqArgs,
    CaaclAddServiceOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add_service",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddServiceResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddServiceArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddServiceOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member service
services to add
    */
    Service *[]string `json:"service,omitempty"`
  }

type caaclAddServiceKwParams struct {
  *CaaclAddServiceArgs
  *CaaclAddServiceOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddServiceResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddServiceResult `json:"result"`
}
type CaaclAddServiceResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *CaaclAddServiceResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddServiceResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddServiceResult%v", string(b))
}

/*
Add users and groups to a CA ACL.
*/
func (c *Client) CaaclAddUser(
  reqArgs *CaaclAddUserArgs,
  optArgs *CaaclAddUserOptionalArgs, // can be nil
) (*CaaclAddUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclAddUserKwParams{
    CaaclAddUserArgs: reqArgs,
    CaaclAddUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_add_user",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclAddUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclAddUserArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclAddUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type caaclAddUserKwParams struct {
  *CaaclAddUserArgs
  *CaaclAddUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclAddUserResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclAddUserResult `json:"result"`
}
type CaaclAddUserResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *CaaclAddUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclAddUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclAddUserResult%v", string(b))
}

/*
Delete a CA ACL.
*/
func (c *Client) CaaclDel(
  reqArgs *CaaclDelArgs,
  optArgs *CaaclDelOptionalArgs, // can be nil
) (*CaaclDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclDelKwParams{
    CaaclDelArgs: reqArgs,
    CaaclDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclDelArgs struct {
  
    /*
ACL name

    */
    Cn []string `json:"cn,omitempty"`
  }

type CaaclDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type caaclDelKwParams struct {
  *CaaclDelArgs
  *CaaclDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclDelResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclDelResult `json:"result"`
}
type CaaclDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *CaaclDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclDelResult%v", string(b))
}

/*
Disable a CA ACL.
*/
func (c *Client) CaaclDisable(
  reqArgs *CaaclDisableArgs,
  optArgs *CaaclDisableOptionalArgs, // can be nil
) (*CaaclDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclDisableKwParams{
    CaaclDisableArgs: reqArgs,
    CaaclDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclDisableArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclDisableOptionalArgs struct {
  }

type caaclDisableKwParams struct {
  *CaaclDisableArgs
  *CaaclDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclDisableResult `json:"result"`
}
type CaaclDisableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CaaclDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclDisableResult%v", string(b))
}

/*
Enable a CA ACL.
*/
func (c *Client) CaaclEnable(
  reqArgs *CaaclEnableArgs,
  optArgs *CaaclEnableOptionalArgs, // can be nil
) (*CaaclEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclEnableKwParams{
    CaaclEnableArgs: reqArgs,
    CaaclEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_enable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclEnableArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclEnableOptionalArgs struct {
  }

type caaclEnableKwParams struct {
  *CaaclEnableArgs
  *CaaclEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclEnableResult `json:"result"`
}
type CaaclEnableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CaaclEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclEnableResult%v", string(b))
}

/*
Search for CA ACLs.
*/
func (c *Client) CaaclFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CaaclFindArgs,
  optArgs *CaaclFindOptionalArgs, // can be nil
) (*CaaclFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclFindKwParams{
    CaaclFindArgs: reqArgs,
    CaaclFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclFindArgs struct {
  }

type CaaclFindOptionalArgs struct {
  
    /*
ACL name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
CA category
CA category the ACL applies to
    */
    Ipacacategory *string `json:"ipacacategory,omitempty"`
  
    /*
Profile category
Profile category the ACL applies to
    */
    Ipacertprofilecategory *string `json:"ipacertprofilecategory,omitempty"`
  
    /*
User category
User category the ACL applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the ACL applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Service category
Service category the ACL applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type caaclFindKwParams struct {
  *CaaclFindArgs
  *CaaclFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclFindResult `json:"result"`
}
type CaaclFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Caacl `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *CaaclFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclFindResult%v", string(b))
}

/*
Modify a CA ACL.
*/
func (c *Client) CaaclMod(
  reqArgs *CaaclModArgs,
  optArgs *CaaclModOptionalArgs, // can be nil
) (*CaaclModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclModKwParams{
    CaaclModArgs: reqArgs,
    CaaclModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclModArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
CA category
CA category the ACL applies to
    */
    Ipacacategory *string `json:"ipacacategory,omitempty"`
  
    /*
Profile category
Profile category the ACL applies to
    */
    Ipacertprofilecategory *string `json:"ipacertprofilecategory,omitempty"`
  
    /*
User category
User category the ACL applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the ACL applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Service category
Service category the ACL applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type caaclModKwParams struct {
  *CaaclModArgs
  *CaaclModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclModResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclModResult `json:"result"`
}
type CaaclModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Caacl `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CaaclModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclModResult%v", string(b))
}

/*
Remove CAs from a CA ACL.
*/
func (c *Client) CaaclRemoveCa(
  reqArgs *CaaclRemoveCaArgs,
  optArgs *CaaclRemoveCaOptionalArgs, // can be nil
) (*CaaclRemoveCaResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclRemoveCaKwParams{
    CaaclRemoveCaArgs: reqArgs,
    CaaclRemoveCaOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_remove_ca",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclRemoveCaResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclRemoveCaArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclRemoveCaOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member Certificate Authority
Certificate Authorities to remove
    */
    Ca *[]string `json:"ca,omitempty"`
  }

type caaclRemoveCaKwParams struct {
  *CaaclRemoveCaArgs
  *CaaclRemoveCaOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclRemoveCaResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclRemoveCaResult `json:"result"`
}
type CaaclRemoveCaResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *CaaclRemoveCaResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclRemoveCaResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclRemoveCaResult%v", string(b))
}

/*
Remove target hosts and hostgroups from a CA ACL.
*/
func (c *Client) CaaclRemoveHost(
  reqArgs *CaaclRemoveHostArgs,
  optArgs *CaaclRemoveHostOptionalArgs, // can be nil
) (*CaaclRemoveHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclRemoveHostKwParams{
    CaaclRemoveHostArgs: reqArgs,
    CaaclRemoveHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_remove_host",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclRemoveHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclRemoveHostArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclRemoveHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type caaclRemoveHostKwParams struct {
  *CaaclRemoveHostArgs
  *CaaclRemoveHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclRemoveHostResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclRemoveHostResult `json:"result"`
}
type CaaclRemoveHostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *CaaclRemoveHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclRemoveHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclRemoveHostResult%v", string(b))
}

/*
Remove profiles from a CA ACL.
*/
func (c *Client) CaaclRemoveProfile(
  reqArgs *CaaclRemoveProfileArgs,
  optArgs *CaaclRemoveProfileOptionalArgs, // can be nil
) (*CaaclRemoveProfileResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclRemoveProfileKwParams{
    CaaclRemoveProfileArgs: reqArgs,
    CaaclRemoveProfileOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_remove_profile",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclRemoveProfileResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclRemoveProfileArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclRemoveProfileOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member Certificate Profile
Certificate Profiles to remove
    */
    Certprofile *[]string `json:"certprofile,omitempty"`
  }

type caaclRemoveProfileKwParams struct {
  *CaaclRemoveProfileArgs
  *CaaclRemoveProfileOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclRemoveProfileResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclRemoveProfileResult `json:"result"`
}
type CaaclRemoveProfileResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *CaaclRemoveProfileResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclRemoveProfileResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclRemoveProfileResult%v", string(b))
}

/*
Remove services from a CA ACL.
*/
func (c *Client) CaaclRemoveService(
  reqArgs *CaaclRemoveServiceArgs,
  optArgs *CaaclRemoveServiceOptionalArgs, // can be nil
) (*CaaclRemoveServiceResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclRemoveServiceKwParams{
    CaaclRemoveServiceArgs: reqArgs,
    CaaclRemoveServiceOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_remove_service",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclRemoveServiceResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclRemoveServiceArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclRemoveServiceOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member service
services to remove
    */
    Service *[]string `json:"service,omitempty"`
  }

type caaclRemoveServiceKwParams struct {
  *CaaclRemoveServiceArgs
  *CaaclRemoveServiceOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclRemoveServiceResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclRemoveServiceResult `json:"result"`
}
type CaaclRemoveServiceResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *CaaclRemoveServiceResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclRemoveServiceResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclRemoveServiceResult%v", string(b))
}

/*
Remove users and groups from a CA ACL.
*/
func (c *Client) CaaclRemoveUser(
  reqArgs *CaaclRemoveUserArgs,
  optArgs *CaaclRemoveUserOptionalArgs, // can be nil
) (*CaaclRemoveUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclRemoveUserKwParams{
    CaaclRemoveUserArgs: reqArgs,
    CaaclRemoveUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_remove_user",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclRemoveUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclRemoveUserArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclRemoveUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type caaclRemoveUserKwParams struct {
  *CaaclRemoveUserArgs
  *CaaclRemoveUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclRemoveUserResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclRemoveUserResult `json:"result"`
}
type CaaclRemoveUserResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *CaaclRemoveUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclRemoveUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclRemoveUserResult%v", string(b))
}

/*
Display the properties of a CA ACL.
*/
func (c *Client) CaaclShow(
  reqArgs *CaaclShowArgs,
  optArgs *CaaclShowOptionalArgs, // can be nil
) (*CaaclShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := caaclShowKwParams{
    CaaclShowArgs: reqArgs,
    CaaclShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "caacl_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res caaclShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CaaclShowArgs struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  }

type CaaclShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type caaclShowKwParams struct {
  *CaaclShowArgs
  *CaaclShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type caaclShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CaaclShowResult `json:"result"`
}
type CaaclShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Caacl `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CaaclShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CaaclShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CaaclShowResult%v", string(b))
}

/*
Search for existing certificates.
*/
func (c *Client) CertFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CertFindArgs,
  optArgs *CertFindOptionalArgs, // can be nil
) (*CertFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certFindKwParams{
    CertFindArgs: reqArgs,
    CertFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertFindArgs struct {
  }

type CertFindOptionalArgs struct {
  
    /*
Certificate
Base-64 encoded certificate.
    */
    Certificate *interface{} `json:"certificate,omitempty"`
  
    /*
Issuer
Issuer DN
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Revocation reason
Reason for revoking the certificate (0-10). Type "ipa help cert" for revocation reason details. 
    */
    RevocationReason *int `json:"revocation_reason,omitempty"`
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  
    /*
Subject
Subject
    */
    Subject *string `json:"subject,omitempty"`
  
    /*

minimum serial number
    */
    MinSerialNumber *int `json:"min_serial_number,omitempty"`
  
    /*

maximum serial number
    */
    MaxSerialNumber *int `json:"max_serial_number,omitempty"`
  
    /*

match the common name exactly
    */
    Exactly *bool `json:"exactly,omitempty"`
  
    /*

Valid not after from this date (YYYY-mm-dd)
    */
    ValidnotafterFrom *time.Time `json:"validnotafter_from,omitempty"`
  
    /*

Valid not after to this date (YYYY-mm-dd)
    */
    ValidnotafterTo *time.Time `json:"validnotafter_to,omitempty"`
  
    /*

Valid not before from this date (YYYY-mm-dd)
    */
    ValidnotbeforeFrom *time.Time `json:"validnotbefore_from,omitempty"`
  
    /*

Valid not before to this date (YYYY-mm-dd)
    */
    ValidnotbeforeTo *time.Time `json:"validnotbefore_to,omitempty"`
  
    /*

Issued on from this date (YYYY-mm-dd)
    */
    IssuedonFrom *time.Time `json:"issuedon_from,omitempty"`
  
    /*

Issued on to this date (YYYY-mm-dd)
    */
    IssuedonTo *time.Time `json:"issuedon_to,omitempty"`
  
    /*

Revoked on from this date (YYYY-mm-dd)
    */
    RevokedonFrom *time.Time `json:"revokedon_from,omitempty"`
  
    /*

Revoked on to this date (YYYY-mm-dd)
    */
    RevokedonTo *time.Time `json:"revokedon_to,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("certificate")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
user
Search for certificates with these owner users.
    */
    User *[]string `json:"user,omitempty"`
  
    /*
user
Search for certificates without these owner users.
    */
    NoUser *[]string `json:"no_user,omitempty"`
  
    /*
host
Search for certificates with these owner hosts.
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
host
Search for certificates without these owner hosts.
    */
    NoHost *[]string `json:"no_host,omitempty"`
  
    /*
service
Search for certificates with these owner services.
    */
    Service *[]string `json:"service,omitempty"`
  
    /*
service
Search for certificates without these owner services.
    */
    NoService *[]string `json:"no_service,omitempty"`
  }

type certFindKwParams struct {
  *CertFindArgs
  *CertFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CertFindResult `json:"result"`
}
type CertFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Cert `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *CertFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertFindResult%v", string(b))
}

/*
Take a revoked certificate off hold.
*/
func (c *Client) CertRemoveHold(
  reqArgs *CertRemoveHoldArgs,
  optArgs *CertRemoveHoldOptionalArgs, // can be nil
) (*CertRemoveHoldResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certRemoveHoldKwParams{
    CertRemoveHoldArgs: reqArgs,
    CertRemoveHoldOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_remove_hold",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certRemoveHoldResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertRemoveHoldArgs struct {
  
    /*
Serial number
Serial number in decimal or if prefixed with 0x in hexadecimal
    */
    SerialNumber int `json:"serial_number,omitempty"`
  }

type CertRemoveHoldOptionalArgs struct {
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  }

type certRemoveHoldKwParams struct {
  *CertRemoveHoldArgs
  *CertRemoveHoldOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certRemoveHoldResponse struct {
	Error  *Error      `json:"error"`
	Result *CertRemoveHoldResult `json:"result"`
}
type CertRemoveHoldResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *CertRemoveHoldResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertRemoveHoldResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertRemoveHoldResult%v", string(b))
}

/*
Submit a certificate signing request.
*/
func (c *Client) CertRequest(
  reqArgs *CertRequestArgs,
  optArgs *CertRequestOptionalArgs, // can be nil
) (*CertRequestResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certRequestKwParams{
    CertRequestArgs: reqArgs,
    CertRequestOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_request",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certRequestResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertRequestArgs struct {
  
    /*
CSR

    */
    Csr string `json:"csr,omitempty"`
  
    /*
Principal
Principal for this certificate (e.g. HTTP/test.example.com)
    */
    Principal string `json:"principal,omitempty"`
  }

type CertRequestOptionalArgs struct {
  
    /*


    */
    RequestType *string `json:"request_type,omitempty"`
  
    /*
Profile ID
Certificate Profile to use
    */
    ProfileID *string `json:"profile_id,omitempty"`
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  
    /*

automatically add the principal if it doesn't exist (service principals only)
    */
    Add *bool `json:"add,omitempty"`
  
    /*

Include certificate chain in output
    */
    Chain *bool `json:"chain,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certRequestKwParams struct {
  *CertRequestArgs
  *CertRequestOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certRequestResponse struct {
	Error  *Error      `json:"error"`
	Result *CertRequestResult `json:"result"`
}
type CertRequestResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value int `json:"value,omitempty"`
    
  }

func (t *CertRequestResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertRequestResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertRequestResult%v", string(b))
}

/*
Revoke a certificate.
*/
func (c *Client) CertRevoke(
  reqArgs *CertRevokeArgs,
  optArgs *CertRevokeOptionalArgs, // can be nil
) (*CertRevokeResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certRevokeKwParams{
    CertRevokeArgs: reqArgs,
    CertRevokeOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_revoke",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certRevokeResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertRevokeArgs struct {
  
    /*
Serial number
Serial number in decimal or if prefixed with 0x in hexadecimal
    */
    SerialNumber int `json:"serial_number,omitempty"`
  }

type CertRevokeOptionalArgs struct {
  
    /*
Revocation reason
Reason for revoking the certificate (0-10). Type "ipa help cert" for revocation reason details. 
    */
    RevocationReason *int `json:"revocation_reason,omitempty"`
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  }

type certRevokeKwParams struct {
  *CertRevokeArgs
  *CertRevokeOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certRevokeResponse struct {
	Error  *Error      `json:"error"`
	Result *CertRevokeResult `json:"result"`
}
type CertRevokeResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *CertRevokeResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertRevokeResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertRevokeResult%v", string(b))
}

/*
Retrieve an existing certificate.
*/
func (c *Client) CertShow(
  reqArgs *CertShowArgs,
  optArgs *CertShowOptionalArgs, // can be nil
) (*CertShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certShowKwParams{
    CertShowArgs: reqArgs,
    CertShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertShowArgs struct {
  
    /*
Serial number
Serial number in decimal or if prefixed with 0x in hexadecimal
    */
    SerialNumber int `json:"serial_number,omitempty"`
  }

type CertShowOptionalArgs struct {
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  
    /*
Output filename
File to store the certificate in.
    */
    Out *string `json:"out,omitempty"`
  
    /*

Include certificate chain in output
    */
    Chain *bool `json:"chain,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type certShowKwParams struct {
  *CertShowArgs
  *CertShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CertShowResult `json:"result"`
}
type CertShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Cert `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value int `json:"value,omitempty"`
    
  }

func (t *CertShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertShowResult%v", string(b))
}

/*
Check the status of a certificate signing request.
*/
func (c *Client) CertStatus(
  reqArgs *CertStatusArgs,
  optArgs *CertStatusOptionalArgs, // can be nil
) (*CertStatusResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certStatusKwParams{
    CertStatusArgs: reqArgs,
    CertStatusOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cert_status",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certStatusResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertStatusArgs struct {
  
    /*
Request id

    */
    RequestID int `json:"request_id,omitempty"`
  }

type CertStatusOptionalArgs struct {
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certStatusKwParams struct {
  *CertStatusArgs
  *CertStatusOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certStatusResponse struct {
	Error  *Error      `json:"error"`
	Result *CertStatusResult `json:"result"`
}
type CertStatusResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value int `json:"value,omitempty"`
    
  }

func (t *CertStatusResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertStatusResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertStatusResult%v", string(b))
}

/*
Search for users matching the provided certificate.

    This command relies on SSSD to retrieve the list of matching users and
    may return cached data. For more information on purging SSSD cache,
    please refer to sss_cache documentation.
*/
func (c *Client) CertmapMatch(
  reqArgs *CertmapMatchArgs,
  optArgs *CertmapMatchOptionalArgs, // can be nil
) (*CertmapMatchResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapMatchKwParams{
    CertmapMatchArgs: reqArgs,
    CertmapMatchOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmap_match",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapMatchResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapMatchArgs struct {
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Certificate interface{} `json:"certificate,omitempty"`
  }

type CertmapMatchOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapMatchKwParams struct {
  *CertmapMatchArgs
  *CertmapMatchOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapMatchResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapMatchResult `json:"result"`
}
type CertmapMatchResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []interface{} `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *CertmapMatchResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapMatchResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapMatchResult%v", string(b))
}

/*
Modify Certificate Identity Mapping configuration.
*/
func (c *Client) CertmapconfigMod(
  reqArgs *CertmapconfigModArgs,
  optArgs *CertmapconfigModOptionalArgs, // can be nil
) (*CertmapconfigModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapconfigModKwParams{
    CertmapconfigModArgs: reqArgs,
    CertmapconfigModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmapconfig_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapconfigModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapconfigModArgs struct {
  }

type CertmapconfigModOptionalArgs struct {
  
    /*
Prompt for the username
Prompt for the username when multiple identities are mapped to a certificate
    */
    Ipacertmappromptusername *bool `json:"ipacertmappromptusername,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapconfigModKwParams struct {
  *CertmapconfigModArgs
  *CertmapconfigModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapconfigModResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapconfigModResult `json:"result"`
}
type CertmapconfigModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Certmapconfig `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *CertmapconfigModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapconfigModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapconfigModResult%v", string(b))
}

/*
Show the current Certificate Identity Mapping configuration.
*/
func (c *Client) CertmapconfigShow(
  reqArgs *CertmapconfigShowArgs,
  optArgs *CertmapconfigShowOptionalArgs, // can be nil
) (*CertmapconfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapconfigShowKwParams{
    CertmapconfigShowArgs: reqArgs,
    CertmapconfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmapconfig_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapconfigShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapconfigShowArgs struct {
  }

type CertmapconfigShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapconfigShowKwParams struct {
  *CertmapconfigShowArgs
  *CertmapconfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapconfigShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapconfigShowResult `json:"result"`
}
type CertmapconfigShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Certmapconfig `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *CertmapconfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapconfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapconfigShowResult%v", string(b))
}

/*
Create a new Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleAdd(
  reqArgs *CertmapruleAddArgs,
  optArgs *CertmapruleAddOptionalArgs, // can be nil
) (*CertmapruleAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleAddKwParams{
    CertmapruleAddArgs: reqArgs,
    CertmapruleAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleAddArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn string `json:"cn,omitempty"`
  }

type CertmapruleAddOptionalArgs struct {
  
    /*
Description
Certificate Identity Mapping Rule description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Mapping rule
Rule used to map the certificate with a user entry
    */
    Ipacertmapmaprule *string `json:"ipacertmapmaprule,omitempty"`
  
    /*
Matching rule
Rule used to check if a certificate can be used for authentication
    */
    Ipacertmapmatchrule *string `json:"ipacertmapmatchrule,omitempty"`
  
    /*
Domain name
Domain where the user entry will be searched
    */
    Associateddomain *[]interface{} `json:"associateddomain,omitempty"`
  
    /*
Priority
Priority of the rule (higher number means lower priority
    */
    Ipacertmappriority *int `json:"ipacertmappriority,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapruleAddKwParams struct {
  *CertmapruleAddArgs
  *CertmapruleAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleAddResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleAddResult `json:"result"`
}
type CertmapruleAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Certmaprule `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CertmapruleAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleAddResult%v", string(b))
}

/*
Delete a Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleDel(
  reqArgs *CertmapruleDelArgs,
  optArgs *CertmapruleDelOptionalArgs, // can be nil
) (*CertmapruleDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleDelKwParams{
    CertmapruleDelArgs: reqArgs,
    CertmapruleDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleDelArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn []string `json:"cn,omitempty"`
  }

type CertmapruleDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type certmapruleDelKwParams struct {
  *CertmapruleDelArgs
  *CertmapruleDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleDelResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleDelResult `json:"result"`
}
type CertmapruleDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *CertmapruleDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleDelResult%v", string(b))
}

/*
Disable a Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleDisable(
  reqArgs *CertmapruleDisableArgs,
  optArgs *CertmapruleDisableOptionalArgs, // can be nil
) (*CertmapruleDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleDisableKwParams{
    CertmapruleDisableArgs: reqArgs,
    CertmapruleDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleDisableArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn string `json:"cn,omitempty"`
  }

type CertmapruleDisableOptionalArgs struct {
  }

type certmapruleDisableKwParams struct {
  *CertmapruleDisableArgs
  *CertmapruleDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleDisableResult `json:"result"`
}
type CertmapruleDisableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CertmapruleDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleDisableResult%v", string(b))
}

/*
Enable a Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleEnable(
  reqArgs *CertmapruleEnableArgs,
  optArgs *CertmapruleEnableOptionalArgs, // can be nil
) (*CertmapruleEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleEnableKwParams{
    CertmapruleEnableArgs: reqArgs,
    CertmapruleEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_enable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleEnableArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn string `json:"cn,omitempty"`
  }

type CertmapruleEnableOptionalArgs struct {
  }

type certmapruleEnableKwParams struct {
  *CertmapruleEnableArgs
  *CertmapruleEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleEnableResult `json:"result"`
}
type CertmapruleEnableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CertmapruleEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleEnableResult%v", string(b))
}

/*
Search for Certificate Identity Mapping Rules.
*/
func (c *Client) CertmapruleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CertmapruleFindArgs,
  optArgs *CertmapruleFindOptionalArgs, // can be nil
) (*CertmapruleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleFindKwParams{
    CertmapruleFindArgs: reqArgs,
    CertmapruleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleFindArgs struct {
  }

type CertmapruleFindOptionalArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Certificate Identity Mapping Rule description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Mapping rule
Rule used to map the certificate with a user entry
    */
    Ipacertmapmaprule *string `json:"ipacertmapmaprule,omitempty"`
  
    /*
Matching rule
Rule used to check if a certificate can be used for authentication
    */
    Ipacertmapmatchrule *string `json:"ipacertmapmatchrule,omitempty"`
  
    /*
Domain name
Domain where the user entry will be searched
    */
    Associateddomain *[]interface{} `json:"associateddomain,omitempty"`
  
    /*
Priority
Priority of the rule (higher number means lower priority
    */
    Ipacertmappriority *int `json:"ipacertmappriority,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("rulename")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type certmapruleFindKwParams struct {
  *CertmapruleFindArgs
  *CertmapruleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleFindResult `json:"result"`
}
type CertmapruleFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Certmaprule `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *CertmapruleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleFindResult%v", string(b))
}

/*
Modify a Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleMod(
  reqArgs *CertmapruleModArgs,
  optArgs *CertmapruleModOptionalArgs, // can be nil
) (*CertmapruleModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleModKwParams{
    CertmapruleModArgs: reqArgs,
    CertmapruleModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleModArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn string `json:"cn,omitempty"`
  }

type CertmapruleModOptionalArgs struct {
  
    /*
Description
Certificate Identity Mapping Rule description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Mapping rule
Rule used to map the certificate with a user entry
    */
    Ipacertmapmaprule *string `json:"ipacertmapmaprule,omitempty"`
  
    /*
Matching rule
Rule used to check if a certificate can be used for authentication
    */
    Ipacertmapmatchrule *string `json:"ipacertmapmatchrule,omitempty"`
  
    /*
Domain name
Domain where the user entry will be searched
    */
    Associateddomain *[]interface{} `json:"associateddomain,omitempty"`
  
    /*
Priority
Priority of the rule (higher number means lower priority
    */
    Ipacertmappriority *int `json:"ipacertmappriority,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapruleModKwParams struct {
  *CertmapruleModArgs
  *CertmapruleModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleModResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleModResult `json:"result"`
}
type CertmapruleModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Certmaprule `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CertmapruleModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleModResult%v", string(b))
}

/*
Display information about a Certificate Identity Mapping Rule.
*/
func (c *Client) CertmapruleShow(
  reqArgs *CertmapruleShowArgs,
  optArgs *CertmapruleShowOptionalArgs, // can be nil
) (*CertmapruleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certmapruleShowKwParams{
    CertmapruleShowArgs: reqArgs,
    CertmapruleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certmaprule_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certmapruleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertmapruleShowArgs struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn string `json:"cn,omitempty"`
  }

type CertmapruleShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certmapruleShowKwParams struct {
  *CertmapruleShowArgs
  *CertmapruleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certmapruleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CertmapruleShowResult `json:"result"`
}
type CertmapruleShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Certmaprule `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CertmapruleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertmapruleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertmapruleShowResult%v", string(b))
}

/*
Delete a Certificate Profile.
*/
func (c *Client) CertprofileDel(
  reqArgs *CertprofileDelArgs,
  optArgs *CertprofileDelOptionalArgs, // can be nil
) (*CertprofileDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certprofileDelKwParams{
    CertprofileDelArgs: reqArgs,
    CertprofileDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certprofile_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certprofileDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertprofileDelArgs struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn []string `json:"cn,omitempty"`
  }

type CertprofileDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type certprofileDelKwParams struct {
  *CertprofileDelArgs
  *CertprofileDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certprofileDelResponse struct {
	Error  *Error      `json:"error"`
	Result *CertprofileDelResult `json:"result"`
}
type CertprofileDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *CertprofileDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertprofileDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertprofileDelResult%v", string(b))
}

/*
Search for Certificate Profiles.
*/
func (c *Client) CertprofileFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CertprofileFindArgs,
  optArgs *CertprofileFindOptionalArgs, // can be nil
) (*CertprofileFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certprofileFindKwParams{
    CertprofileFindArgs: reqArgs,
    CertprofileFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certprofile_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certprofileFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertprofileFindArgs struct {
  }

type CertprofileFindOptionalArgs struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Profile description
Brief description of this profile
    */
    Description *string `json:"description,omitempty"`
  
    /*
Store issued certificates
Whether to store certs issued using this profile
    */
    Ipacertprofilestoreissued *bool `json:"ipacertprofilestoreissued,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("id")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type certprofileFindKwParams struct {
  *CertprofileFindArgs
  *CertprofileFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certprofileFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CertprofileFindResult `json:"result"`
}
type CertprofileFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Certprofile `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *CertprofileFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertprofileFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertprofileFindResult%v", string(b))
}

/*
Import a Certificate Profile.
*/
func (c *Client) CertprofileImport(
  reqArgs *CertprofileImportArgs,
  optArgs *CertprofileImportOptionalArgs, // can be nil
) (*CertprofileImportResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certprofileImportKwParams{
    CertprofileImportArgs: reqArgs,
    CertprofileImportOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certprofile_import",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certprofileImportResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertprofileImportArgs struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Profile description
Brief description of this profile
    */
    Description string `json:"description,omitempty"`
  
    /*
Filename of a raw profile. The XML format is not supported.

    */
    File string `json:"file,omitempty"`
  }

type CertprofileImportOptionalArgs struct {
  
    /*
Store issued certificates
Whether to store certs issued using this profile
    */
    Ipacertprofilestoreissued *bool `json:"ipacertprofilestoreissued,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certprofileImportKwParams struct {
  *CertprofileImportArgs
  *CertprofileImportOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certprofileImportResponse struct {
	Error  *Error      `json:"error"`
	Result *CertprofileImportResult `json:"result"`
}
type CertprofileImportResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CertprofileImportResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertprofileImportResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertprofileImportResult%v", string(b))
}

/*
Modify Certificate Profile configuration.
*/
func (c *Client) CertprofileMod(
  reqArgs *CertprofileModArgs,
  optArgs *CertprofileModOptionalArgs, // can be nil
) (*CertprofileModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certprofileModKwParams{
    CertprofileModArgs: reqArgs,
    CertprofileModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certprofile_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certprofileModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertprofileModArgs struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn string `json:"cn,omitempty"`
  }

type CertprofileModOptionalArgs struct {
  
    /*
Profile description
Brief description of this profile
    */
    Description *string `json:"description,omitempty"`
  
    /*
Store issued certificates
Whether to store certs issued using this profile
    */
    Ipacertprofilestoreissued *bool `json:"ipacertprofilestoreissued,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
File containing profile configuration

    */
    File *string `json:"file,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certprofileModKwParams struct {
  *CertprofileModArgs
  *CertprofileModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certprofileModResponse struct {
	Error  *Error      `json:"error"`
	Result *CertprofileModResult `json:"result"`
}
type CertprofileModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Certprofile `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CertprofileModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertprofileModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertprofileModResult%v", string(b))
}

/*
Display the properties of a Certificate Profile.
*/
func (c *Client) CertprofileShow(
  reqArgs *CertprofileShowArgs,
  optArgs *CertprofileShowOptionalArgs, // can be nil
) (*CertprofileShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := certprofileShowKwParams{
    CertprofileShowArgs: reqArgs,
    CertprofileShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "certprofile_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res certprofileShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CertprofileShowArgs struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn string `json:"cn,omitempty"`
  }

type CertprofileShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Write profile configuration to file
    */
    Out *string `json:"out,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type certprofileShowKwParams struct {
  *CertprofileShowArgs
  *CertprofileShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type certprofileShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CertprofileShowResult `json:"result"`
}
type CertprofileShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Certprofile `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CertprofileShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CertprofileShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CertprofileShowResult%v", string(b))
}

/*
Search for classes.
*/
func (c *Client) ClassFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ClassFindArgs,
  optArgs *ClassFindOptionalArgs, // can be nil
) (*ClassFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := classFindKwParams{
    ClassFindArgs: reqArgs,
    ClassFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "class_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res classFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ClassFindArgs struct {
  }

type ClassFindOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type classFindKwParams struct {
  *ClassFindArgs
  *ClassFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type classFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ClassFindResult `json:"result"`
}
type ClassFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Class `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *ClassFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ClassFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ClassFindResult%v", string(b))
}

/*
Display information about a class.
*/
func (c *Client) ClassShow(
  reqArgs *ClassShowArgs,
  optArgs *ClassShowOptionalArgs, // can be nil
) (*ClassShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := classShowKwParams{
    ClassShowArgs: reqArgs,
    ClassShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "class_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res classShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ClassShowArgs struct {
  
    /*
Full name

    */
    FullName string `json:"full_name,omitempty"`
  }

type ClassShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type classShowKwParams struct {
  *ClassShowArgs
  *ClassShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type classShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ClassShowResult `json:"result"`
}
type ClassShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Class `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ClassShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ClassShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ClassShowResult%v", string(b))
}

/*
Search for commands.
*/
func (c *Client) CommandFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CommandFindArgs,
  optArgs *CommandFindOptionalArgs, // can be nil
) (*CommandFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := commandFindKwParams{
    CommandFindArgs: reqArgs,
    CommandFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "command_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res commandFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CommandFindArgs struct {
  }

type CommandFindOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type commandFindKwParams struct {
  *CommandFindArgs
  *CommandFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type commandFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CommandFindResult `json:"result"`
}
type CommandFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Command `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *CommandFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CommandFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CommandFindResult%v", string(b))
}

/*
Display information about a command.
*/
func (c *Client) CommandShow(
  reqArgs *CommandShowArgs,
  optArgs *CommandShowOptionalArgs, // can be nil
) (*CommandShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := commandShowKwParams{
    CommandShowArgs: reqArgs,
    CommandShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "command_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res commandShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CommandShowArgs struct {
  
    /*
Full name

    */
    FullName string `json:"full_name,omitempty"`
  }

type CommandShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type commandShowKwParams struct {
  *CommandShowArgs
  *CommandShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type commandShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CommandShowResult `json:"result"`
}
type CommandShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Command `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CommandShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CommandShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CommandShowResult%v", string(b))
}

/*
Determine whether Schema Compatibility plugin is configured to serve trusted domain users and groups
*/
func (c *Client) CompatIsEnabled(
  reqArgs *CompatIsEnabledArgs,
  optArgs *CompatIsEnabledOptionalArgs, // can be nil
) (*CompatIsEnabledResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := compatIsEnabledKwParams{
    CompatIsEnabledArgs: reqArgs,
    CompatIsEnabledOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "compat_is_enabled",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res compatIsEnabledResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CompatIsEnabledArgs struct {
  }

type CompatIsEnabledOptionalArgs struct {
  }

type compatIsEnabledKwParams struct {
  *CompatIsEnabledArgs
  *CompatIsEnabledOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type compatIsEnabledResponse struct {
	Error  *Error      `json:"error"`
	Result *CompatIsEnabledResult `json:"result"`
}
type CompatIsEnabledResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *CompatIsEnabledResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CompatIsEnabledResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CompatIsEnabledResult%v", string(b))
}

/*
Modify configuration options.
*/
func (c *Client) ConfigMod(
  reqArgs *ConfigModArgs,
  optArgs *ConfigModOptionalArgs, // can be nil
) (*ConfigModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := configModKwParams{
    ConfigModArgs: reqArgs,
    ConfigModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "config_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res configModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ConfigModArgs struct {
  }

type ConfigModOptionalArgs struct {
  
    /*
Maximum username length

    */
    Ipamaxusernamelength *int `json:"ipamaxusernamelength,omitempty"`
  
    /*
Home directory base
Default location of home directories
    */
    Ipahomesrootdir *string `json:"ipahomesrootdir,omitempty"`
  
    /*
Default shell
Default shell for new users
    */
    Ipadefaultloginshell *string `json:"ipadefaultloginshell,omitempty"`
  
    /*
Default users group
Default group for new users
    */
    Ipadefaultprimarygroup *string `json:"ipadefaultprimarygroup,omitempty"`
  
    /*
Default e-mail domain
Default e-mail domain
    */
    Ipadefaultemaildomain *string `json:"ipadefaultemaildomain,omitempty"`
  
    /*
Search time limit
Maximum amount of time (seconds) for a search (-1 or 0 is unlimited)
    */
    Ipasearchtimelimit *int `json:"ipasearchtimelimit,omitempty"`
  
    /*
Search size limit
Maximum number of records to search (-1 or 0 is unlimited)
    */
    Ipasearchrecordslimit *int `json:"ipasearchrecordslimit,omitempty"`
  
    /*
User search fields
A comma-separated list of fields to search in when searching for users
    */
    Ipausersearchfields *string `json:"ipausersearchfields,omitempty"`
  
    /*
Group search fields
A comma-separated list of fields to search in when searching for groups
    */
    Ipagroupsearchfields *string `json:"ipagroupsearchfields,omitempty"`
  
    /*
Enable migration mode
Enable migration mode
    */
    Ipamigrationenabled *bool `json:"ipamigrationenabled,omitempty"`
  
    /*
Default group objectclasses
Default group objectclasses (comma-separated list)
    */
    Ipagroupobjectclasses *[]string `json:"ipagroupobjectclasses,omitempty"`
  
    /*
Default user objectclasses
Default user objectclasses (comma-separated list)
    */
    Ipauserobjectclasses *[]string `json:"ipauserobjectclasses,omitempty"`
  
    /*
Password Expiration Notification (days)
Number of days's notice of impending password expiration
    */
    Ipapwdexpadvnotify *int `json:"ipapwdexpadvnotify,omitempty"`
  
    /*
Password plugin features
Extra hashes to generate in password plug-in
    */
    Ipaconfigstring *[]string `json:"ipaconfigstring,omitempty"`
  
    /*
SELinux user map order
Order in increasing priority of SELinux users, delimited by $
    */
    Ipaselinuxusermaporder *string `json:"ipaselinuxusermaporder,omitempty"`
  
    /*
Default SELinux user
Default SELinux user when no match is found in SELinux map rule
    */
    Ipaselinuxusermapdefault *string `json:"ipaselinuxusermapdefault,omitempty"`
  
    /*
Default PAC types
Default types of PAC supported for services
    */
    Ipakrbauthzdata *[]string `json:"ipakrbauthzdata,omitempty"`
  
    /*
Default user authentication types
Default types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
IPA CA renewal master
Renewal master for IPA certificate authority
    */
    CaRenewalMasterServer *string `json:"ca_renewal_master_server,omitempty"`
  
    /*
Domain resolution order
colon-separated list of domains used for short name qualification
    */
    Ipadomainresolutionorder *string `json:"ipadomainresolutionorder,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type configModKwParams struct {
  *ConfigModArgs
  *ConfigModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type configModResponse struct {
	Error  *Error      `json:"error"`
	Result *ConfigModResult `json:"result"`
}
type ConfigModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Config `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *ConfigModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ConfigModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ConfigModResult%v", string(b))
}

/*
Show the current configuration.
*/
func (c *Client) ConfigShow(
  reqArgs *ConfigShowArgs,
  optArgs *ConfigShowOptionalArgs, // can be nil
) (*ConfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := configShowKwParams{
    ConfigShowArgs: reqArgs,
    ConfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "config_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res configShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ConfigShowArgs struct {
  }

type ConfigShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type configShowKwParams struct {
  *ConfigShowArgs
  *ConfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type configShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ConfigShowResult `json:"result"`
}
type ConfigShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Config `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *ConfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ConfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ConfigShowResult%v", string(b))
}

/*

*/
func (c *Client) CosentryAdd(
  reqArgs *CosentryAddArgs,
  optArgs *CosentryAddOptionalArgs, // can be nil
) (*CosentryAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := cosentryAddKwParams{
    CosentryAddArgs: reqArgs,
    CosentryAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cosentry_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res cosentryAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CosentryAddArgs struct {
  
    /*


    */
    Cn string `json:"cn,omitempty"`
  
    /*


    */
    Krbpwdpolicyreference string `json:"krbpwdpolicyreference,omitempty"`
  
    /*


    */
    Cospriority int `json:"cospriority,omitempty"`
  }

type CosentryAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type cosentryAddKwParams struct {
  *CosentryAddArgs
  *CosentryAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type cosentryAddResponse struct {
	Error  *Error      `json:"error"`
	Result *CosentryAddResult `json:"result"`
}
type CosentryAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Cosentry `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CosentryAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CosentryAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CosentryAddResult%v", string(b))
}

/*

*/
func (c *Client) CosentryDel(
  reqArgs *CosentryDelArgs,
  optArgs *CosentryDelOptionalArgs, // can be nil
) (*CosentryDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := cosentryDelKwParams{
    CosentryDelArgs: reqArgs,
    CosentryDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cosentry_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res cosentryDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CosentryDelArgs struct {
  
    /*


    */
    Cn []string `json:"cn,omitempty"`
  }

type CosentryDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type cosentryDelKwParams struct {
  *CosentryDelArgs
  *CosentryDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type cosentryDelResponse struct {
	Error  *Error      `json:"error"`
	Result *CosentryDelResult `json:"result"`
}
type CosentryDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *CosentryDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CosentryDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CosentryDelResult%v", string(b))
}

/*

*/
func (c *Client) CosentryFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *CosentryFindArgs,
  optArgs *CosentryFindOptionalArgs, // can be nil
) (*CosentryFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := cosentryFindKwParams{
    CosentryFindArgs: reqArgs,
    CosentryFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cosentry_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res cosentryFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CosentryFindArgs struct {
  }

type CosentryFindOptionalArgs struct {
  
    /*


    */
    Cn *string `json:"cn,omitempty"`
  
    /*


    */
    Krbpwdpolicyreference *string `json:"krbpwdpolicyreference,omitempty"`
  
    /*


    */
    Cospriority *int `json:"cospriority,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("cn")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type cosentryFindKwParams struct {
  *CosentryFindArgs
  *CosentryFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type cosentryFindResponse struct {
	Error  *Error      `json:"error"`
	Result *CosentryFindResult `json:"result"`
}
type CosentryFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Cosentry `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *CosentryFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CosentryFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CosentryFindResult%v", string(b))
}

/*

*/
func (c *Client) CosentryMod(
  reqArgs *CosentryModArgs,
  optArgs *CosentryModOptionalArgs, // can be nil
) (*CosentryModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := cosentryModKwParams{
    CosentryModArgs: reqArgs,
    CosentryModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cosentry_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res cosentryModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CosentryModArgs struct {
  
    /*


    */
    Cn string `json:"cn,omitempty"`
  }

type CosentryModOptionalArgs struct {
  
    /*


    */
    Krbpwdpolicyreference *string `json:"krbpwdpolicyreference,omitempty"`
  
    /*


    */
    Cospriority *int `json:"cospriority,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type cosentryModKwParams struct {
  *CosentryModArgs
  *CosentryModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type cosentryModResponse struct {
	Error  *Error      `json:"error"`
	Result *CosentryModResult `json:"result"`
}
type CosentryModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Cosentry `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CosentryModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CosentryModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CosentryModResult%v", string(b))
}

/*

*/
func (c *Client) CosentryShow(
  reqArgs *CosentryShowArgs,
  optArgs *CosentryShowOptionalArgs, // can be nil
) (*CosentryShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := cosentryShowKwParams{
    CosentryShowArgs: reqArgs,
    CosentryShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "cosentry_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res cosentryShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type CosentryShowArgs struct {
  
    /*


    */
    Cn string `json:"cn,omitempty"`
  }

type CosentryShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type cosentryShowKwParams struct {
  *CosentryShowArgs
  *CosentryShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type cosentryShowResponse struct {
	Error  *Error      `json:"error"`
	Result *CosentryShowResult `json:"result"`
}
type CosentryShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Cosentry `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *CosentryShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("CosentryShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("CosentryShowResult%v", string(b))
}

/*
Add a new delegation.
*/
func (c *Client) DelegationAdd(
  reqArgs *DelegationAddArgs,
  optArgs *DelegationAddOptionalArgs, // can be nil
) (*DelegationAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := delegationAddKwParams{
    DelegationAddArgs: reqArgs,
    DelegationAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "delegation_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res delegationAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DelegationAddArgs struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
Attributes
Attributes to which the delegation applies
    */
    Attrs []string `json:"attrs,omitempty"`
  
    /*
Member user group
User group to apply delegation to
    */
    Memberof string `json:"memberof,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group string `json:"group,omitempty"`
  }

type DelegationAddOptionalArgs struct {
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type delegationAddKwParams struct {
  *DelegationAddArgs
  *DelegationAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type delegationAddResponse struct {
	Error  *Error      `json:"error"`
	Result *DelegationAddResult `json:"result"`
}
type DelegationAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Delegation `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *DelegationAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DelegationAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DelegationAddResult%v", string(b))
}

/*
Delete a delegation.
*/
func (c *Client) DelegationDel(
  reqArgs *DelegationDelArgs,
  optArgs *DelegationDelOptionalArgs, // can be nil
) (*DelegationDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := delegationDelKwParams{
    DelegationDelArgs: reqArgs,
    DelegationDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "delegation_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res delegationDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DelegationDelArgs struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type DelegationDelOptionalArgs struct {
  }

type delegationDelKwParams struct {
  *DelegationDelArgs
  *DelegationDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type delegationDelResponse struct {
	Error  *Error      `json:"error"`
	Result *DelegationDelResult `json:"result"`
}
type DelegationDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *DelegationDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DelegationDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DelegationDelResult%v", string(b))
}

/*
Search for delegations.
*/
func (c *Client) DelegationFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *DelegationFindArgs,
  optArgs *DelegationFindOptionalArgs, // can be nil
) (*DelegationFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := delegationFindKwParams{
    DelegationFindArgs: reqArgs,
    DelegationFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "delegation_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res delegationFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DelegationFindArgs struct {
  }

type DelegationFindOptionalArgs struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname *string `json:"aciname,omitempty"`
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the delegation applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Member user group
User group to apply delegation to
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type delegationFindKwParams struct {
  *DelegationFindArgs
  *DelegationFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type delegationFindResponse struct {
	Error  *Error      `json:"error"`
	Result *DelegationFindResult `json:"result"`
}
type DelegationFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Delegation `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *DelegationFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DelegationFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DelegationFindResult%v", string(b))
}

/*
Modify a delegation.
*/
func (c *Client) DelegationMod(
  reqArgs *DelegationModArgs,
  optArgs *DelegationModOptionalArgs, // can be nil
) (*DelegationModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := delegationModKwParams{
    DelegationModArgs: reqArgs,
    DelegationModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "delegation_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res delegationModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DelegationModArgs struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type DelegationModOptionalArgs struct {
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the delegation applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Member user group
User group to apply delegation to
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type delegationModKwParams struct {
  *DelegationModArgs
  *DelegationModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type delegationModResponse struct {
	Error  *Error      `json:"error"`
	Result *DelegationModResult `json:"result"`
}
type DelegationModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Delegation `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *DelegationModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DelegationModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DelegationModResult%v", string(b))
}

/*
Display information about a delegation.
*/
func (c *Client) DelegationShow(
  reqArgs *DelegationShowArgs,
  optArgs *DelegationShowOptionalArgs, // can be nil
) (*DelegationShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := delegationShowKwParams{
    DelegationShowArgs: reqArgs,
    DelegationShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "delegation_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res delegationShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DelegationShowArgs struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type DelegationShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type delegationShowKwParams struct {
  *DelegationShowArgs
  *DelegationShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type delegationShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DelegationShowResult `json:"result"`
}
type DelegationShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Delegation `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *DelegationShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DelegationShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DelegationShowResult%v", string(b))
}

/*
Checks if any of the servers has the DNS service enabled.
*/
func (c *Client) DNSIsEnabled(
  reqArgs *DNSIsEnabledArgs,
  optArgs *DNSIsEnabledOptionalArgs, // can be nil
) (*DNSIsEnabledResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsIsEnabledKwParams{
    DNSIsEnabledArgs: reqArgs,
    DNSIsEnabledOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dns_is_enabled",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsIsEnabledResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DNSIsEnabledArgs struct {
  }

type DNSIsEnabledOptionalArgs struct {
  }

type dnsIsEnabledKwParams struct {
  *DNSIsEnabledArgs
  *DNSIsEnabledOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsIsEnabledResponse struct {
	Error  *Error      `json:"error"`
	Result *DNSIsEnabledResult `json:"result"`
}
type DNSIsEnabledResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DNSIsEnabledResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DNSIsEnabledResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DNSIsEnabledResult%v", string(b))
}

/*
Resolve a host name in DNS. (Deprecated)
*/
func (c *Client) DNSResolve(
  reqArgs *DNSResolveArgs,
  optArgs *DNSResolveOptionalArgs, // can be nil
) (*DNSResolveResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsResolveKwParams{
    DNSResolveArgs: reqArgs,
    DNSResolveOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dns_resolve",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsResolveResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DNSResolveArgs struct {
  
    /*
Hostname (FQDN)

    */
    Hostname string `json:"hostname,omitempty"`
  }

type DNSResolveOptionalArgs struct {
  }

type dnsResolveKwParams struct {
  *DNSResolveArgs
  *DNSResolveOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsResolveResponse struct {
	Error  *Error      `json:"error"`
	Result *DNSResolveResult `json:"result"`
}
type DNSResolveResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *DNSResolveResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DNSResolveResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DNSResolveResult%v", string(b))
}

/*
Update location and IPA server DNS records
*/
func (c *Client) DNSUpdateSystemRecords(
  reqArgs *DNSUpdateSystemRecordsArgs,
  optArgs *DNSUpdateSystemRecordsOptionalArgs, // can be nil
) (*DNSUpdateSystemRecordsResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsUpdateSystemRecordsKwParams{
    DNSUpdateSystemRecordsArgs: reqArgs,
    DNSUpdateSystemRecordsOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dns_update_system_records",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsUpdateSystemRecordsResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DNSUpdateSystemRecordsArgs struct {
  }

type DNSUpdateSystemRecordsOptionalArgs struct {
  
    /*
Dry run
Do not update records only return expected records
    */
    DryRun *bool `json:"dry_run,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsUpdateSystemRecordsKwParams struct {
  *DNSUpdateSystemRecordsArgs
  *DNSUpdateSystemRecordsOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsUpdateSystemRecordsResponse struct {
	Error  *Error      `json:"error"`
	Result *DNSUpdateSystemRecordsResult `json:"result"`
}
type DNSUpdateSystemRecordsResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Result of the command
    (required)
    */
    
    Value bool `json:"value,omitempty"`
    
  }

func (t *DNSUpdateSystemRecordsResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DNSUpdateSystemRecordsResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DNSUpdateSystemRecordsResult%v", string(b))
}

/*
Modify global DNS configuration.
*/
func (c *Client) DnsconfigMod(
  reqArgs *DnsconfigModArgs,
  optArgs *DnsconfigModOptionalArgs, // can be nil
) (*DnsconfigModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsconfigModKwParams{
    DnsconfigModArgs: reqArgs,
    DnsconfigModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsconfig_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsconfigModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsconfigModArgs struct {
  }

type DnsconfigModOptionalArgs struct {
  
    /*
Global forwarders
Global forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Global forwarding policy. Set to "none" to disable any configured global forwarders.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records
    */
    Idnsallowsyncptr *bool `json:"idnsallowsyncptr,omitempty"`
  
    /*
Zone refresh interval
An interval between regular polls of the name server for new DNS zones
    */
    Idnszonerefresh *int `json:"idnszonerefresh,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsconfigModKwParams struct {
  *DnsconfigModArgs
  *DnsconfigModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsconfigModResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsconfigModResult `json:"result"`
}
type DnsconfigModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnsconfig `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnsconfigModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsconfigModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsconfigModResult%v", string(b))
}

/*
Show the current global DNS configuration.
*/
func (c *Client) DnsconfigShow(
  reqArgs *DnsconfigShowArgs,
  optArgs *DnsconfigShowOptionalArgs, // can be nil
) (*DnsconfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsconfigShowKwParams{
    DnsconfigShowArgs: reqArgs,
    DnsconfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsconfig_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsconfigShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsconfigShowArgs struct {
  }

type DnsconfigShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsconfigShowKwParams struct {
  *DnsconfigShowArgs
  *DnsconfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsconfigShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsconfigShowResult `json:"result"`
}
type DnsconfigShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnsconfig `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnsconfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsconfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsconfigShowResult%v", string(b))
}

/*
Create new DNS forward zone.
*/
func (c *Client) DnsforwardzoneAdd(
  reqArgs *DnsforwardzoneAddArgs,
  optArgs *DnsforwardzoneAddOptionalArgs, // can be nil
) (*DnsforwardzoneAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneAddKwParams{
    DnsforwardzoneAddArgs: reqArgs,
    DnsforwardzoneAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneAddArgs struct {
  }

type DnsforwardzoneAddOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Force DNS zone creation even if it will overlap with an existing zone.
    */
    SkipOverlapCheck *bool `json:"skip_overlap_check,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsforwardzoneAddKwParams struct {
  *DnsforwardzoneAddArgs
  *DnsforwardzoneAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneAddResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneAddResult `json:"result"`
}
type DnsforwardzoneAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnsforwardzone `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnsforwardzoneAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneAddResult%v", string(b))
}

/*
Add a permission for per-forward zone access delegation.
*/
func (c *Client) DnsforwardzoneAddPermission(
  reqArgs *DnsforwardzoneAddPermissionArgs,
  optArgs *DnsforwardzoneAddPermissionOptionalArgs, // can be nil
) (*DnsforwardzoneAddPermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneAddPermissionKwParams{
    DnsforwardzoneAddPermissionArgs: reqArgs,
    DnsforwardzoneAddPermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_add_permission",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneAddPermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneAddPermissionArgs struct {
  }

type DnsforwardzoneAddPermissionOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  }

type dnsforwardzoneAddPermissionKwParams struct {
  *DnsforwardzoneAddPermissionArgs
  *DnsforwardzoneAddPermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneAddPermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneAddPermissionResult `json:"result"`
}
type DnsforwardzoneAddPermissionResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
Permission value
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *DnsforwardzoneAddPermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneAddPermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneAddPermissionResult%v", string(b))
}

/*
Delete DNS forward zone.
*/
func (c *Client) DnsforwardzoneDel(
  reqArgs *DnsforwardzoneDelArgs,
  optArgs *DnsforwardzoneDelOptionalArgs, // can be nil
) (*DnsforwardzoneDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneDelKwParams{
    DnsforwardzoneDelArgs: reqArgs,
    DnsforwardzoneDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneDelArgs struct {
  }

type DnsforwardzoneDelOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *[]interface{} `json:"idnsname,omitempty"`
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type dnsforwardzoneDelKwParams struct {
  *DnsforwardzoneDelArgs
  *DnsforwardzoneDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneDelResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneDelResult `json:"result"`
}
type DnsforwardzoneDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []interface{} `json:"value,omitempty"`
    
  }

func (t *DnsforwardzoneDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneDelResult%v", string(b))
}

/*
Disable DNS Forward Zone.
*/
func (c *Client) DnsforwardzoneDisable(
  reqArgs *DnsforwardzoneDisableArgs,
  optArgs *DnsforwardzoneDisableOptionalArgs, // can be nil
) (*DnsforwardzoneDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneDisableKwParams{
    DnsforwardzoneDisableArgs: reqArgs,
    DnsforwardzoneDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneDisableArgs struct {
  }

type DnsforwardzoneDisableOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  }

type dnsforwardzoneDisableKwParams struct {
  *DnsforwardzoneDisableArgs
  *DnsforwardzoneDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneDisableResult `json:"result"`
}
type DnsforwardzoneDisableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnsforwardzoneDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneDisableResult%v", string(b))
}

/*
Enable DNS Forward Zone.
*/
func (c *Client) DnsforwardzoneEnable(
  reqArgs *DnsforwardzoneEnableArgs,
  optArgs *DnsforwardzoneEnableOptionalArgs, // can be nil
) (*DnsforwardzoneEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneEnableKwParams{
    DnsforwardzoneEnableArgs: reqArgs,
    DnsforwardzoneEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_enable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneEnableArgs struct {
  }

type DnsforwardzoneEnableOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  }

type dnsforwardzoneEnableKwParams struct {
  *DnsforwardzoneEnableArgs
  *DnsforwardzoneEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneEnableResult `json:"result"`
}
type DnsforwardzoneEnableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnsforwardzoneEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneEnableResult%v", string(b))
}

/*
Search for DNS forward zones.
*/
func (c *Client) DnsforwardzoneFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *DnsforwardzoneFindArgs,
  optArgs *DnsforwardzoneFindOptionalArgs, // can be nil
) (*DnsforwardzoneFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneFindKwParams{
    DnsforwardzoneFindArgs: reqArgs,
    DnsforwardzoneFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneFindArgs struct {
  }

type DnsforwardzoneFindOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Active zone
Is zone active?
    */
    Idnszoneactive *bool `json:"idnszoneactive,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type dnsforwardzoneFindKwParams struct {
  *DnsforwardzoneFindArgs
  *DnsforwardzoneFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneFindResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneFindResult `json:"result"`
}
type DnsforwardzoneFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Dnsforwardzone `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *DnsforwardzoneFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneFindResult%v", string(b))
}

/*
Modify DNS forward zone.
*/
func (c *Client) DnsforwardzoneMod(
  reqArgs *DnsforwardzoneModArgs,
  optArgs *DnsforwardzoneModOptionalArgs, // can be nil
) (*DnsforwardzoneModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneModKwParams{
    DnsforwardzoneModArgs: reqArgs,
    DnsforwardzoneModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneModArgs struct {
  }

type DnsforwardzoneModOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsforwardzoneModKwParams struct {
  *DnsforwardzoneModArgs
  *DnsforwardzoneModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneModResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneModResult `json:"result"`
}
type DnsforwardzoneModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnsforwardzone `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnsforwardzoneModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneModResult%v", string(b))
}

/*
Remove a permission for per-forward zone access delegation.
*/
func (c *Client) DnsforwardzoneRemovePermission(
  reqArgs *DnsforwardzoneRemovePermissionArgs,
  optArgs *DnsforwardzoneRemovePermissionOptionalArgs, // can be nil
) (*DnsforwardzoneRemovePermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneRemovePermissionKwParams{
    DnsforwardzoneRemovePermissionArgs: reqArgs,
    DnsforwardzoneRemovePermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_remove_permission",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneRemovePermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneRemovePermissionArgs struct {
  }

type DnsforwardzoneRemovePermissionOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  }

type dnsforwardzoneRemovePermissionKwParams struct {
  *DnsforwardzoneRemovePermissionArgs
  *DnsforwardzoneRemovePermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneRemovePermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneRemovePermissionResult `json:"result"`
}
type DnsforwardzoneRemovePermissionResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
Permission value
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *DnsforwardzoneRemovePermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneRemovePermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneRemovePermissionResult%v", string(b))
}

/*
Display information about a DNS forward zone.
*/
func (c *Client) DnsforwardzoneShow(
  reqArgs *DnsforwardzoneShowArgs,
  optArgs *DnsforwardzoneShowOptionalArgs, // can be nil
) (*DnsforwardzoneShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsforwardzoneShowKwParams{
    DnsforwardzoneShowArgs: reqArgs,
    DnsforwardzoneShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsforwardzone_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsforwardzoneShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsforwardzoneShowArgs struct {
  }

type DnsforwardzoneShowOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsforwardzoneShowKwParams struct {
  *DnsforwardzoneShowArgs
  *DnsforwardzoneShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsforwardzoneShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsforwardzoneShowResult `json:"result"`
}
type DnsforwardzoneShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnsforwardzone `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnsforwardzoneShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsforwardzoneShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsforwardzoneShowResult%v", string(b))
}

/*
Add new DNS resource record.
*/
func (c *Client) DnsrecordAdd(
  reqArgs *DnsrecordAddArgs,
  optArgs *DnsrecordAddOptionalArgs, // can be nil
) (*DnsrecordAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordAddKwParams{
    DnsrecordAddArgs: reqArgs,
    DnsrecordAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordAddArgs struct {
  
    /*
Record name
Record name
    */
    Idnsname interface{} `json:"idnsname,omitempty"`
  }

type DnsrecordAddOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname *interface{} `json:"dnszoneidnsname,omitempty"`
  
    /*
Time to live
Time to live
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
A record
Raw A records
    */
    Arecord *[]string `json:"arecord,omitempty"`
  
    /*
A IP Address

    */
    APartIPAddress *string `json:"a_part_ip_address,omitempty"`
  
    /*
A Create reverse
Create reverse record for this IP Address
    */
    AExtraCreateReverse *bool `json:"a_extra_create_reverse,omitempty"`
  
    /*
AAAA record
Raw AAAA records
    */
    Aaaarecord *[]string `json:"aaaarecord,omitempty"`
  
    /*
AAAA IP Address

    */
    AaaaPartIPAddress *string `json:"aaaa_part_ip_address,omitempty"`
  
    /*
AAAA Create reverse
Create reverse record for this IP Address
    */
    AaaaExtraCreateReverse *bool `json:"aaaa_extra_create_reverse,omitempty"`
  
    /*
A6 record
Raw A6 records
    */
    A6record *[]string `json:"a6record,omitempty"`
  
    /*
A6 Record data

    */
    A6PartData *string `json:"a6_part_data,omitempty"`
  
    /*
AFSDB record
Raw AFSDB records
    */
    Afsdbrecord *[]string `json:"afsdbrecord,omitempty"`
  
    /*
AFSDB Subtype

    */
    AfsdbPartSubtype *int `json:"afsdb_part_subtype,omitempty"`
  
    /*
AFSDB Hostname

    */
    AfsdbPartHostname *interface{} `json:"afsdb_part_hostname,omitempty"`
  
    /*
APL record
Raw APL records
    */
    Aplrecord *[]string `json:"aplrecord,omitempty"`
  
    /*
CERT record
Raw CERT records
    */
    Certrecord *[]string `json:"certrecord,omitempty"`
  
    /*
CERT Certificate Type

    */
    CertPartType *int `json:"cert_part_type,omitempty"`
  
    /*
CERT Key Tag

    */
    CertPartKeyTag *int `json:"cert_part_key_tag,omitempty"`
  
    /*
CERT Algorithm

    */
    CertPartAlgorithm *int `json:"cert_part_algorithm,omitempty"`
  
    /*
CERT Certificate/CRL

    */
    CertPartCertificateOrCrl *string `json:"cert_part_certificate_or_crl,omitempty"`
  
    /*
CNAME record
Raw CNAME records
    */
    Cnamerecord *[]string `json:"cnamerecord,omitempty"`
  
    /*
CNAME Hostname
A hostname which this alias hostname points to
    */
    CnamePartHostname *interface{} `json:"cname_part_hostname,omitempty"`
  
    /*
DHCID record
Raw DHCID records
    */
    Dhcidrecord *[]string `json:"dhcidrecord,omitempty"`
  
    /*
DLV record
Raw DLV records
    */
    Dlvrecord *[]string `json:"dlvrecord,omitempty"`
  
    /*
DLV Key Tag

    */
    DlvPartKeyTag *int `json:"dlv_part_key_tag,omitempty"`
  
    /*
DLV Algorithm

    */
    DlvPartAlgorithm *int `json:"dlv_part_algorithm,omitempty"`
  
    /*
DLV Digest Type

    */
    DlvPartDigestType *int `json:"dlv_part_digest_type,omitempty"`
  
    /*
DLV Digest

    */
    DlvPartDigest *string `json:"dlv_part_digest,omitempty"`
  
    /*
DNAME record
Raw DNAME records
    */
    Dnamerecord *[]string `json:"dnamerecord,omitempty"`
  
    /*
DNAME Target

    */
    DnamePartTarget *interface{} `json:"dname_part_target,omitempty"`
  
    /*
DS record
Raw DS records
    */
    Dsrecord *[]string `json:"dsrecord,omitempty"`
  
    /*
DS Key Tag

    */
    DsPartKeyTag *int `json:"ds_part_key_tag,omitempty"`
  
    /*
DS Algorithm

    */
    DsPartAlgorithm *int `json:"ds_part_algorithm,omitempty"`
  
    /*
DS Digest Type

    */
    DsPartDigestType *int `json:"ds_part_digest_type,omitempty"`
  
    /*
DS Digest

    */
    DsPartDigest *string `json:"ds_part_digest,omitempty"`
  
    /*
HIP record
Raw HIP records
    */
    Hiprecord *[]string `json:"hiprecord,omitempty"`
  
    /*
IPSECKEY record
Raw IPSECKEY records
    */
    Ipseckeyrecord *[]string `json:"ipseckeyrecord,omitempty"`
  
    /*
KEY record
Raw KEY records
    */
    Keyrecord *[]string `json:"keyrecord,omitempty"`
  
    /*
KX record
Raw KX records
    */
    Kxrecord *[]string `json:"kxrecord,omitempty"`
  
    /*
KX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    KxPartPreference *int `json:"kx_part_preference,omitempty"`
  
    /*
KX Exchanger
A host willing to act as a key exchanger
    */
    KxPartExchanger *interface{} `json:"kx_part_exchanger,omitempty"`
  
    /*
LOC record
Raw LOC records
    */
    Locrecord *[]string `json:"locrecord,omitempty"`
  
    /*
LOC Degrees Latitude

    */
    LocPartLatDeg *int `json:"loc_part_lat_deg,omitempty"`
  
    /*
LOC Minutes Latitude

    */
    LocPartLatMin *int `json:"loc_part_lat_min,omitempty"`
  
    /*
LOC Seconds Latitude

    */
    LocPartLatSec *float64 `json:"loc_part_lat_sec,omitempty"`
  
    /*
LOC Direction Latitude

    */
    LocPartLatDir *string `json:"loc_part_lat_dir,omitempty"`
  
    /*
LOC Degrees Longitude

    */
    LocPartLonDeg *int `json:"loc_part_lon_deg,omitempty"`
  
    /*
LOC Minutes Longitude

    */
    LocPartLonMin *int `json:"loc_part_lon_min,omitempty"`
  
    /*
LOC Seconds Longitude

    */
    LocPartLonSec *float64 `json:"loc_part_lon_sec,omitempty"`
  
    /*
LOC Direction Longitude

    */
    LocPartLonDir *string `json:"loc_part_lon_dir,omitempty"`
  
    /*
LOC Altitude

    */
    LocPartAltitude *float64 `json:"loc_part_altitude,omitempty"`
  
    /*
LOC Size

    */
    LocPartSize *float64 `json:"loc_part_size,omitempty"`
  
    /*
LOC Horizontal Precision

    */
    LocPartHPrecision *float64 `json:"loc_part_h_precision,omitempty"`
  
    /*
LOC Vertical Precision

    */
    LocPartVPrecision *float64 `json:"loc_part_v_precision,omitempty"`
  
    /*
MX record
Raw MX records
    */
    Mxrecord *[]string `json:"mxrecord,omitempty"`
  
    /*
MX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    MxPartPreference *int `json:"mx_part_preference,omitempty"`
  
    /*
MX Exchanger
A host willing to act as a mail exchanger
    */
    MxPartExchanger *interface{} `json:"mx_part_exchanger,omitempty"`
  
    /*
NAPTR record
Raw NAPTR records
    */
    Naptrrecord *[]string `json:"naptrrecord,omitempty"`
  
    /*
NAPTR Order

    */
    NaptrPartOrder *int `json:"naptr_part_order,omitempty"`
  
    /*
NAPTR Preference

    */
    NaptrPartPreference *int `json:"naptr_part_preference,omitempty"`
  
    /*
NAPTR Flags

    */
    NaptrPartFlags *string `json:"naptr_part_flags,omitempty"`
  
    /*
NAPTR Service

    */
    NaptrPartService *string `json:"naptr_part_service,omitempty"`
  
    /*
NAPTR Regular Expression

    */
    NaptrPartRegexp *string `json:"naptr_part_regexp,omitempty"`
  
    /*
NAPTR Replacement

    */
    NaptrPartReplacement *string `json:"naptr_part_replacement,omitempty"`
  
    /*
NS record
Raw NS records
    */
    Nsrecord *[]string `json:"nsrecord,omitempty"`
  
    /*
NS Hostname

    */
    NsPartHostname *interface{} `json:"ns_part_hostname,omitempty"`
  
    /*
NSEC record
Raw NSEC records
    */
    Nsecrecord *[]string `json:"nsecrecord,omitempty"`
  
    /*
PTR record
Raw PTR records
    */
    Ptrrecord *[]string `json:"ptrrecord,omitempty"`
  
    /*
PTR Hostname
The hostname this reverse record points to
    */
    PtrPartHostname *interface{} `json:"ptr_part_hostname,omitempty"`
  
    /*
RRSIG record
Raw RRSIG records
    */
    Rrsigrecord *[]string `json:"rrsigrecord,omitempty"`
  
    /*
RP record
Raw RP records
    */
    Rprecord *[]string `json:"rprecord,omitempty"`
  
    /*
SIG record
Raw SIG records
    */
    Sigrecord *[]string `json:"sigrecord,omitempty"`
  
    /*
SPF record
Raw SPF records
    */
    Spfrecord *[]string `json:"spfrecord,omitempty"`
  
    /*
SRV record
Raw SRV records
    */
    Srvrecord *[]string `json:"srvrecord,omitempty"`
  
    /*
SRV Priority (order)
Lower number means higher priority. Clients will attempt to contact the server with the lowest-numbered priority they can reach.
    */
    SrvPartPriority *int `json:"srv_part_priority,omitempty"`
  
    /*
SRV Weight
Relative weight for entries with the same priority.
    */
    SrvPartWeight *int `json:"srv_part_weight,omitempty"`
  
    /*
SRV Port

    */
    SrvPartPort *int `json:"srv_part_port,omitempty"`
  
    /*
SRV Target
The domain name of the target host or '.' if the service is decidedly not available at this domain
    */
    SrvPartTarget *interface{} `json:"srv_part_target,omitempty"`
  
    /*
SSHFP record
Raw SSHFP records
    */
    Sshfprecord *[]string `json:"sshfprecord,omitempty"`
  
    /*
SSHFP Algorithm

    */
    SshfpPartAlgorithm *int `json:"sshfp_part_algorithm,omitempty"`
  
    /*
SSHFP Fingerprint Type

    */
    SshfpPartFpType *int `json:"sshfp_part_fp_type,omitempty"`
  
    /*
SSHFP Fingerprint

    */
    SshfpPartFingerprint *string `json:"sshfp_part_fingerprint,omitempty"`
  
    /*
TLSA record
Raw TLSA records
    */
    Tlsarecord *[]string `json:"tlsarecord,omitempty"`
  
    /*
TLSA Certificate Usage

    */
    TlsaPartCertUsage *int `json:"tlsa_part_cert_usage,omitempty"`
  
    /*
TLSA Selector

    */
    TlsaPartSelector *int `json:"tlsa_part_selector,omitempty"`
  
    /*
TLSA Matching Type

    */
    TlsaPartMatchingType *int `json:"tlsa_part_matching_type,omitempty"`
  
    /*
TLSA Certificate Association Data

    */
    TlsaPartCertAssociationData *string `json:"tlsa_part_cert_association_data,omitempty"`
  
    /*
TXT record
Raw TXT records
    */
    Txtrecord *[]string `json:"txtrecord,omitempty"`
  
    /*
TXT Text Data

    */
    TxtPartData *string `json:"txt_part_data,omitempty"`
  
    /*
URI record
Raw URI records
    */
    Urirecord *[]string `json:"urirecord,omitempty"`
  
    /*
URI Priority (order)
Lower number means higher priority. Clients will attempt to contact the URI with the lowest-numbered priority they can reach.
    */
    URIPartPriority *int `json:"uri_part_priority,omitempty"`
  
    /*
URI Weight
Relative weight for entries with the same priority.
    */
    URIPartWeight *int `json:"uri_part_weight,omitempty"`
  
    /*
URI Target Uniform Resource Identifier
Target Uniform Resource Identifier according to RFC 3986
    */
    URIPartTarget *string `json:"uri_part_target,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Force
force NS record creation even if its hostname is not in DNS
    */
    Force *bool `json:"force,omitempty"`
  
    /*
Structured
Parse all raw DNS records and return them in a structured way
    */
    Structured *bool `json:"structured,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsrecordAddKwParams struct {
  *DnsrecordAddArgs
  *DnsrecordAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordAddResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordAddResult `json:"result"`
}
type DnsrecordAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnsrecord `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnsrecordAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordAddResult%v", string(b))
}

/*
Delete DNS resource record.
*/
func (c *Client) DnsrecordDel(
  reqArgs *DnsrecordDelArgs,
  optArgs *DnsrecordDelOptionalArgs, // can be nil
) (*DnsrecordDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordDelKwParams{
    DnsrecordDelArgs: reqArgs,
    DnsrecordDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordDelArgs struct {
  
    /*
Record name
Record name
    */
    Idnsname interface{} `json:"idnsname,omitempty"`
  }

type DnsrecordDelOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname *interface{} `json:"dnszoneidnsname,omitempty"`
  
    /*
Time to live
Time to live
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
A record
Raw A records
    */
    Arecord *[]string `json:"arecord,omitempty"`
  
    /*
AAAA record
Raw AAAA records
    */
    Aaaarecord *[]string `json:"aaaarecord,omitempty"`
  
    /*
A6 record
Raw A6 records
    */
    A6record *[]string `json:"a6record,omitempty"`
  
    /*
AFSDB record
Raw AFSDB records
    */
    Afsdbrecord *[]string `json:"afsdbrecord,omitempty"`
  
    /*
APL record
Raw APL records
    */
    Aplrecord *[]string `json:"aplrecord,omitempty"`
  
    /*
CERT record
Raw CERT records
    */
    Certrecord *[]string `json:"certrecord,omitempty"`
  
    /*
CNAME record
Raw CNAME records
    */
    Cnamerecord *[]string `json:"cnamerecord,omitempty"`
  
    /*
DHCID record
Raw DHCID records
    */
    Dhcidrecord *[]string `json:"dhcidrecord,omitempty"`
  
    /*
DLV record
Raw DLV records
    */
    Dlvrecord *[]string `json:"dlvrecord,omitempty"`
  
    /*
DNAME record
Raw DNAME records
    */
    Dnamerecord *[]string `json:"dnamerecord,omitempty"`
  
    /*
DS record
Raw DS records
    */
    Dsrecord *[]string `json:"dsrecord,omitempty"`
  
    /*
HIP record
Raw HIP records
    */
    Hiprecord *[]string `json:"hiprecord,omitempty"`
  
    /*
IPSECKEY record
Raw IPSECKEY records
    */
    Ipseckeyrecord *[]string `json:"ipseckeyrecord,omitempty"`
  
    /*
KEY record
Raw KEY records
    */
    Keyrecord *[]string `json:"keyrecord,omitempty"`
  
    /*
KX record
Raw KX records
    */
    Kxrecord *[]string `json:"kxrecord,omitempty"`
  
    /*
LOC record
Raw LOC records
    */
    Locrecord *[]string `json:"locrecord,omitempty"`
  
    /*
MX record
Raw MX records
    */
    Mxrecord *[]string `json:"mxrecord,omitempty"`
  
    /*
NAPTR record
Raw NAPTR records
    */
    Naptrrecord *[]string `json:"naptrrecord,omitempty"`
  
    /*
NS record
Raw NS records
    */
    Nsrecord *[]string `json:"nsrecord,omitempty"`
  
    /*
NSEC record
Raw NSEC records
    */
    Nsecrecord *[]string `json:"nsecrecord,omitempty"`
  
    /*
PTR record
Raw PTR records
    */
    Ptrrecord *[]string `json:"ptrrecord,omitempty"`
  
    /*
RRSIG record
Raw RRSIG records
    */
    Rrsigrecord *[]string `json:"rrsigrecord,omitempty"`
  
    /*
RP record
Raw RP records
    */
    Rprecord *[]string `json:"rprecord,omitempty"`
  
    /*
SIG record
Raw SIG records
    */
    Sigrecord *[]string `json:"sigrecord,omitempty"`
  
    /*
SPF record
Raw SPF records
    */
    Spfrecord *[]string `json:"spfrecord,omitempty"`
  
    /*
SRV record
Raw SRV records
    */
    Srvrecord *[]string `json:"srvrecord,omitempty"`
  
    /*
SSHFP record
Raw SSHFP records
    */
    Sshfprecord *[]string `json:"sshfprecord,omitempty"`
  
    /*
TLSA record
Raw TLSA records
    */
    Tlsarecord *[]string `json:"tlsarecord,omitempty"`
  
    /*
TXT record
Raw TXT records
    */
    Txtrecord *[]string `json:"txtrecord,omitempty"`
  
    /*
URI record
Raw URI records
    */
    Urirecord *[]string `json:"urirecord,omitempty"`
  
    /*
Delete all associated records

    */
    DelAll *bool `json:"del_all,omitempty"`
  
    /*
Structured
Parse all raw DNS records and return them in a structured way
    */
    Structured *bool `json:"structured,omitempty"`
  
    /*


    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsrecordDelKwParams struct {
  *DnsrecordDelArgs
  *DnsrecordDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordDelResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordDelResult `json:"result"`
}
type DnsrecordDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []interface{} `json:"value,omitempty"`
    
  }

func (t *DnsrecordDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordDelResult%v", string(b))
}

/*
Delete DNS record entry.
*/
func (c *Client) DnsrecordDelentry(
  reqArgs *DnsrecordDelentryArgs,
  optArgs *DnsrecordDelentryOptionalArgs, // can be nil
) (*DnsrecordDelentryResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordDelentryKwParams{
    DnsrecordDelentryArgs: reqArgs,
    DnsrecordDelentryOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_delentry",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordDelentryResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordDelentryArgs struct {
  
    /*
Record name
Record name
    */
    Idnsname []interface{} `json:"idnsname,omitempty"`
  }

type DnsrecordDelentryOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname *interface{} `json:"dnszoneidnsname,omitempty"`
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type dnsrecordDelentryKwParams struct {
  *DnsrecordDelentryArgs
  *DnsrecordDelentryOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordDelentryResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordDelentryResult `json:"result"`
}
type DnsrecordDelentryResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []interface{} `json:"value,omitempty"`
    
  }

func (t *DnsrecordDelentryResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordDelentryResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordDelentryResult%v", string(b))
}

/*
Search for DNS resources.
*/
func (c *Client) DnsrecordFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *DnsrecordFindArgs,
  optArgs *DnsrecordFindOptionalArgs, // can be nil
) (*DnsrecordFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordFindKwParams{
    DnsrecordFindArgs: reqArgs,
    DnsrecordFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordFindArgs struct {
  }

type DnsrecordFindOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname *interface{} `json:"dnszoneidnsname,omitempty"`
  
    /*
Record name
Record name
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  
    /*
Time to live
Time to live
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
A record
Raw A records
    */
    Arecord *[]string `json:"arecord,omitempty"`
  
    /*
AAAA record
Raw AAAA records
    */
    Aaaarecord *[]string `json:"aaaarecord,omitempty"`
  
    /*
A6 record
Raw A6 records
    */
    A6record *[]string `json:"a6record,omitempty"`
  
    /*
AFSDB record
Raw AFSDB records
    */
    Afsdbrecord *[]string `json:"afsdbrecord,omitempty"`
  
    /*
APL record
Raw APL records
    */
    Aplrecord *[]string `json:"aplrecord,omitempty"`
  
    /*
CERT record
Raw CERT records
    */
    Certrecord *[]string `json:"certrecord,omitempty"`
  
    /*
CNAME record
Raw CNAME records
    */
    Cnamerecord *[]string `json:"cnamerecord,omitempty"`
  
    /*
DHCID record
Raw DHCID records
    */
    Dhcidrecord *[]string `json:"dhcidrecord,omitempty"`
  
    /*
DLV record
Raw DLV records
    */
    Dlvrecord *[]string `json:"dlvrecord,omitempty"`
  
    /*
DNAME record
Raw DNAME records
    */
    Dnamerecord *[]string `json:"dnamerecord,omitempty"`
  
    /*
DS record
Raw DS records
    */
    Dsrecord *[]string `json:"dsrecord,omitempty"`
  
    /*
HIP record
Raw HIP records
    */
    Hiprecord *[]string `json:"hiprecord,omitempty"`
  
    /*
IPSECKEY record
Raw IPSECKEY records
    */
    Ipseckeyrecord *[]string `json:"ipseckeyrecord,omitempty"`
  
    /*
KEY record
Raw KEY records
    */
    Keyrecord *[]string `json:"keyrecord,omitempty"`
  
    /*
KX record
Raw KX records
    */
    Kxrecord *[]string `json:"kxrecord,omitempty"`
  
    /*
LOC record
Raw LOC records
    */
    Locrecord *[]string `json:"locrecord,omitempty"`
  
    /*
MX record
Raw MX records
    */
    Mxrecord *[]string `json:"mxrecord,omitempty"`
  
    /*
NAPTR record
Raw NAPTR records
    */
    Naptrrecord *[]string `json:"naptrrecord,omitempty"`
  
    /*
NS record
Raw NS records
    */
    Nsrecord *[]string `json:"nsrecord,omitempty"`
  
    /*
NSEC record
Raw NSEC records
    */
    Nsecrecord *[]string `json:"nsecrecord,omitempty"`
  
    /*
PTR record
Raw PTR records
    */
    Ptrrecord *[]string `json:"ptrrecord,omitempty"`
  
    /*
RRSIG record
Raw RRSIG records
    */
    Rrsigrecord *[]string `json:"rrsigrecord,omitempty"`
  
    /*
RP record
Raw RP records
    */
    Rprecord *[]string `json:"rprecord,omitempty"`
  
    /*
SIG record
Raw SIG records
    */
    Sigrecord *[]string `json:"sigrecord,omitempty"`
  
    /*
SPF record
Raw SPF records
    */
    Spfrecord *[]string `json:"spfrecord,omitempty"`
  
    /*
SRV record
Raw SRV records
    */
    Srvrecord *[]string `json:"srvrecord,omitempty"`
  
    /*
SSHFP record
Raw SSHFP records
    */
    Sshfprecord *[]string `json:"sshfprecord,omitempty"`
  
    /*
TLSA record
Raw TLSA records
    */
    Tlsarecord *[]string `json:"tlsarecord,omitempty"`
  
    /*
TXT record
Raw TXT records
    */
    Txtrecord *[]string `json:"txtrecord,omitempty"`
  
    /*
URI record
Raw URI records
    */
    Urirecord *[]string `json:"urirecord,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*
Structured
Parse all raw DNS records and return them in a structured way
    */
    Structured *bool `json:"structured,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type dnsrecordFindKwParams struct {
  *DnsrecordFindArgs
  *DnsrecordFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordFindResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordFindResult `json:"result"`
}
type DnsrecordFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Dnsrecord `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *DnsrecordFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordFindResult%v", string(b))
}

/*
Modify a DNS resource record.
*/
func (c *Client) DnsrecordMod(
  reqArgs *DnsrecordModArgs,
  optArgs *DnsrecordModOptionalArgs, // can be nil
) (*DnsrecordModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordModKwParams{
    DnsrecordModArgs: reqArgs,
    DnsrecordModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordModArgs struct {
  
    /*
Record name
Record name
    */
    Idnsname interface{} `json:"idnsname,omitempty"`
  }

type DnsrecordModOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname *interface{} `json:"dnszoneidnsname,omitempty"`
  
    /*
Time to live
Time to live
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
A record
Raw A records
    */
    Arecord *[]string `json:"arecord,omitempty"`
  
    /*
A IP Address

    */
    APartIPAddress *string `json:"a_part_ip_address,omitempty"`
  
    /*
AAAA record
Raw AAAA records
    */
    Aaaarecord *[]string `json:"aaaarecord,omitempty"`
  
    /*
AAAA IP Address

    */
    AaaaPartIPAddress *string `json:"aaaa_part_ip_address,omitempty"`
  
    /*
A6 record
Raw A6 records
    */
    A6record *[]string `json:"a6record,omitempty"`
  
    /*
A6 Record data

    */
    A6PartData *string `json:"a6_part_data,omitempty"`
  
    /*
AFSDB record
Raw AFSDB records
    */
    Afsdbrecord *[]string `json:"afsdbrecord,omitempty"`
  
    /*
AFSDB Subtype

    */
    AfsdbPartSubtype *int `json:"afsdb_part_subtype,omitempty"`
  
    /*
AFSDB Hostname

    */
    AfsdbPartHostname *interface{} `json:"afsdb_part_hostname,omitempty"`
  
    /*
APL record
Raw APL records
    */
    Aplrecord *[]string `json:"aplrecord,omitempty"`
  
    /*
CERT record
Raw CERT records
    */
    Certrecord *[]string `json:"certrecord,omitempty"`
  
    /*
CERT Certificate Type

    */
    CertPartType *int `json:"cert_part_type,omitempty"`
  
    /*
CERT Key Tag

    */
    CertPartKeyTag *int `json:"cert_part_key_tag,omitempty"`
  
    /*
CERT Algorithm

    */
    CertPartAlgorithm *int `json:"cert_part_algorithm,omitempty"`
  
    /*
CERT Certificate/CRL

    */
    CertPartCertificateOrCrl *string `json:"cert_part_certificate_or_crl,omitempty"`
  
    /*
CNAME record
Raw CNAME records
    */
    Cnamerecord *[]string `json:"cnamerecord,omitempty"`
  
    /*
CNAME Hostname
A hostname which this alias hostname points to
    */
    CnamePartHostname *interface{} `json:"cname_part_hostname,omitempty"`
  
    /*
DHCID record
Raw DHCID records
    */
    Dhcidrecord *[]string `json:"dhcidrecord,omitempty"`
  
    /*
DLV record
Raw DLV records
    */
    Dlvrecord *[]string `json:"dlvrecord,omitempty"`
  
    /*
DLV Key Tag

    */
    DlvPartKeyTag *int `json:"dlv_part_key_tag,omitempty"`
  
    /*
DLV Algorithm

    */
    DlvPartAlgorithm *int `json:"dlv_part_algorithm,omitempty"`
  
    /*
DLV Digest Type

    */
    DlvPartDigestType *int `json:"dlv_part_digest_type,omitempty"`
  
    /*
DLV Digest

    */
    DlvPartDigest *string `json:"dlv_part_digest,omitempty"`
  
    /*
DNAME record
Raw DNAME records
    */
    Dnamerecord *[]string `json:"dnamerecord,omitempty"`
  
    /*
DNAME Target

    */
    DnamePartTarget *interface{} `json:"dname_part_target,omitempty"`
  
    /*
DS record
Raw DS records
    */
    Dsrecord *[]string `json:"dsrecord,omitempty"`
  
    /*
DS Key Tag

    */
    DsPartKeyTag *int `json:"ds_part_key_tag,omitempty"`
  
    /*
DS Algorithm

    */
    DsPartAlgorithm *int `json:"ds_part_algorithm,omitempty"`
  
    /*
DS Digest Type

    */
    DsPartDigestType *int `json:"ds_part_digest_type,omitempty"`
  
    /*
DS Digest

    */
    DsPartDigest *string `json:"ds_part_digest,omitempty"`
  
    /*
HIP record
Raw HIP records
    */
    Hiprecord *[]string `json:"hiprecord,omitempty"`
  
    /*
IPSECKEY record
Raw IPSECKEY records
    */
    Ipseckeyrecord *[]string `json:"ipseckeyrecord,omitempty"`
  
    /*
KEY record
Raw KEY records
    */
    Keyrecord *[]string `json:"keyrecord,omitempty"`
  
    /*
KX record
Raw KX records
    */
    Kxrecord *[]string `json:"kxrecord,omitempty"`
  
    /*
KX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    KxPartPreference *int `json:"kx_part_preference,omitempty"`
  
    /*
KX Exchanger
A host willing to act as a key exchanger
    */
    KxPartExchanger *interface{} `json:"kx_part_exchanger,omitempty"`
  
    /*
LOC record
Raw LOC records
    */
    Locrecord *[]string `json:"locrecord,omitempty"`
  
    /*
LOC Degrees Latitude

    */
    LocPartLatDeg *int `json:"loc_part_lat_deg,omitempty"`
  
    /*
LOC Minutes Latitude

    */
    LocPartLatMin *int `json:"loc_part_lat_min,omitempty"`
  
    /*
LOC Seconds Latitude

    */
    LocPartLatSec *float64 `json:"loc_part_lat_sec,omitempty"`
  
    /*
LOC Direction Latitude

    */
    LocPartLatDir *string `json:"loc_part_lat_dir,omitempty"`
  
    /*
LOC Degrees Longitude

    */
    LocPartLonDeg *int `json:"loc_part_lon_deg,omitempty"`
  
    /*
LOC Minutes Longitude

    */
    LocPartLonMin *int `json:"loc_part_lon_min,omitempty"`
  
    /*
LOC Seconds Longitude

    */
    LocPartLonSec *float64 `json:"loc_part_lon_sec,omitempty"`
  
    /*
LOC Direction Longitude

    */
    LocPartLonDir *string `json:"loc_part_lon_dir,omitempty"`
  
    /*
LOC Altitude

    */
    LocPartAltitude *float64 `json:"loc_part_altitude,omitempty"`
  
    /*
LOC Size

    */
    LocPartSize *float64 `json:"loc_part_size,omitempty"`
  
    /*
LOC Horizontal Precision

    */
    LocPartHPrecision *float64 `json:"loc_part_h_precision,omitempty"`
  
    /*
LOC Vertical Precision

    */
    LocPartVPrecision *float64 `json:"loc_part_v_precision,omitempty"`
  
    /*
MX record
Raw MX records
    */
    Mxrecord *[]string `json:"mxrecord,omitempty"`
  
    /*
MX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    MxPartPreference *int `json:"mx_part_preference,omitempty"`
  
    /*
MX Exchanger
A host willing to act as a mail exchanger
    */
    MxPartExchanger *interface{} `json:"mx_part_exchanger,omitempty"`
  
    /*
NAPTR record
Raw NAPTR records
    */
    Naptrrecord *[]string `json:"naptrrecord,omitempty"`
  
    /*
NAPTR Order

    */
    NaptrPartOrder *int `json:"naptr_part_order,omitempty"`
  
    /*
NAPTR Preference

    */
    NaptrPartPreference *int `json:"naptr_part_preference,omitempty"`
  
    /*
NAPTR Flags

    */
    NaptrPartFlags *string `json:"naptr_part_flags,omitempty"`
  
    /*
NAPTR Service

    */
    NaptrPartService *string `json:"naptr_part_service,omitempty"`
  
    /*
NAPTR Regular Expression

    */
    NaptrPartRegexp *string `json:"naptr_part_regexp,omitempty"`
  
    /*
NAPTR Replacement

    */
    NaptrPartReplacement *string `json:"naptr_part_replacement,omitempty"`
  
    /*
NS record
Raw NS records
    */
    Nsrecord *[]string `json:"nsrecord,omitempty"`
  
    /*
NS Hostname

    */
    NsPartHostname *interface{} `json:"ns_part_hostname,omitempty"`
  
    /*
NSEC record
Raw NSEC records
    */
    Nsecrecord *[]string `json:"nsecrecord,omitempty"`
  
    /*
PTR record
Raw PTR records
    */
    Ptrrecord *[]string `json:"ptrrecord,omitempty"`
  
    /*
PTR Hostname
The hostname this reverse record points to
    */
    PtrPartHostname *interface{} `json:"ptr_part_hostname,omitempty"`
  
    /*
RRSIG record
Raw RRSIG records
    */
    Rrsigrecord *[]string `json:"rrsigrecord,omitempty"`
  
    /*
RP record
Raw RP records
    */
    Rprecord *[]string `json:"rprecord,omitempty"`
  
    /*
SIG record
Raw SIG records
    */
    Sigrecord *[]string `json:"sigrecord,omitempty"`
  
    /*
SPF record
Raw SPF records
    */
    Spfrecord *[]string `json:"spfrecord,omitempty"`
  
    /*
SRV record
Raw SRV records
    */
    Srvrecord *[]string `json:"srvrecord,omitempty"`
  
    /*
SRV Priority (order)
Lower number means higher priority. Clients will attempt to contact the server with the lowest-numbered priority they can reach.
    */
    SrvPartPriority *int `json:"srv_part_priority,omitempty"`
  
    /*
SRV Weight
Relative weight for entries with the same priority.
    */
    SrvPartWeight *int `json:"srv_part_weight,omitempty"`
  
    /*
SRV Port

    */
    SrvPartPort *int `json:"srv_part_port,omitempty"`
  
    /*
SRV Target
The domain name of the target host or '.' if the service is decidedly not available at this domain
    */
    SrvPartTarget *interface{} `json:"srv_part_target,omitempty"`
  
    /*
SSHFP record
Raw SSHFP records
    */
    Sshfprecord *[]string `json:"sshfprecord,omitempty"`
  
    /*
SSHFP Algorithm

    */
    SshfpPartAlgorithm *int `json:"sshfp_part_algorithm,omitempty"`
  
    /*
SSHFP Fingerprint Type

    */
    SshfpPartFpType *int `json:"sshfp_part_fp_type,omitempty"`
  
    /*
SSHFP Fingerprint

    */
    SshfpPartFingerprint *string `json:"sshfp_part_fingerprint,omitempty"`
  
    /*
TLSA record
Raw TLSA records
    */
    Tlsarecord *[]string `json:"tlsarecord,omitempty"`
  
    /*
TLSA Certificate Usage

    */
    TlsaPartCertUsage *int `json:"tlsa_part_cert_usage,omitempty"`
  
    /*
TLSA Selector

    */
    TlsaPartSelector *int `json:"tlsa_part_selector,omitempty"`
  
    /*
TLSA Matching Type

    */
    TlsaPartMatchingType *int `json:"tlsa_part_matching_type,omitempty"`
  
    /*
TLSA Certificate Association Data

    */
    TlsaPartCertAssociationData *string `json:"tlsa_part_cert_association_data,omitempty"`
  
    /*
TXT record
Raw TXT records
    */
    Txtrecord *[]string `json:"txtrecord,omitempty"`
  
    /*
TXT Text Data

    */
    TxtPartData *string `json:"txt_part_data,omitempty"`
  
    /*
URI record
Raw URI records
    */
    Urirecord *[]string `json:"urirecord,omitempty"`
  
    /*
URI Priority (order)
Lower number means higher priority. Clients will attempt to contact the URI with the lowest-numbered priority they can reach.
    */
    URIPartPriority *int `json:"uri_part_priority,omitempty"`
  
    /*
URI Weight
Relative weight for entries with the same priority.
    */
    URIPartWeight *int `json:"uri_part_weight,omitempty"`
  
    /*
URI Target Uniform Resource Identifier
Target Uniform Resource Identifier according to RFC 3986
    */
    URIPartTarget *string `json:"uri_part_target,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Structured
Parse all raw DNS records and return them in a structured way
    */
    Structured *bool `json:"structured,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the DNS resource record object
    */
    Rename *interface{} `json:"rename,omitempty"`
  }

type dnsrecordModKwParams struct {
  *DnsrecordModArgs
  *DnsrecordModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordModResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordModResult `json:"result"`
}
type DnsrecordModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnsrecord `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnsrecordModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordModResult%v", string(b))
}

/*
Display DNS resource.
*/
func (c *Client) DnsrecordShow(
  reqArgs *DnsrecordShowArgs,
  optArgs *DnsrecordShowOptionalArgs, // can be nil
) (*DnsrecordShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordShowKwParams{
    DnsrecordShowArgs: reqArgs,
    DnsrecordShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordShowArgs struct {
  
    /*
Record name
Record name
    */
    Idnsname interface{} `json:"idnsname,omitempty"`
  }

type DnsrecordShowOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Dnszoneidnsname *interface{} `json:"dnszoneidnsname,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Structured
Parse all raw DNS records and return them in a structured way
    */
    Structured *bool `json:"structured,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsrecordShowKwParams struct {
  *DnsrecordShowArgs
  *DnsrecordShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordShowResult `json:"result"`
}
type DnsrecordShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnsrecord `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnsrecordShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordShowResult%v", string(b))
}

/*

*/
func (c *Client) DnsrecordSplitParts(
  reqArgs *DnsrecordSplitPartsArgs,
  optArgs *DnsrecordSplitPartsOptionalArgs, // can be nil
) (*DnsrecordSplitPartsResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsrecordSplitPartsKwParams{
    DnsrecordSplitPartsArgs: reqArgs,
    DnsrecordSplitPartsOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsrecord_split_parts",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsrecordSplitPartsResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsrecordSplitPartsArgs struct {
  
    /*


    */
    Name string `json:"name,omitempty"`
  
    /*


    */
    Value string `json:"value,omitempty"`
  }

type DnsrecordSplitPartsOptionalArgs struct {
  }

type dnsrecordSplitPartsKwParams struct {
  *DnsrecordSplitPartsArgs
  *DnsrecordSplitPartsOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsrecordSplitPartsResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsrecordSplitPartsResult `json:"result"`
}
type DnsrecordSplitPartsResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *DnsrecordSplitPartsResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsrecordSplitPartsResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsrecordSplitPartsResult%v", string(b))
}

/*
Search for DNS servers.
*/
func (c *Client) DnsserverFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *DnsserverFindArgs,
  optArgs *DnsserverFindOptionalArgs, // can be nil
) (*DnsserverFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsserverFindKwParams{
    DnsserverFindArgs: reqArgs,
    DnsserverFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsserver_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsserverFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsserverFindArgs struct {
  }

type DnsserverFindOptionalArgs struct {
  
    /*
Server name
DNS Server name
    */
    Idnsserverid *string `json:"idnsserverid,omitempty"`
  
    /*
SOA mname override
SOA mname (authoritative server) override
    */
    Idnssoamname *interface{} `json:"idnssoamname,omitempty"`
  
    /*
Forwarders
Per-server forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-server conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("hostname")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type dnsserverFindKwParams struct {
  *DnsserverFindArgs
  *DnsserverFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsserverFindResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsserverFindResult `json:"result"`
}
type DnsserverFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Dnsserver `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *DnsserverFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsserverFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsserverFindResult%v", string(b))
}

/*
Modify DNS server configuration
*/
func (c *Client) DnsserverMod(
  reqArgs *DnsserverModArgs,
  optArgs *DnsserverModOptionalArgs, // can be nil
) (*DnsserverModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsserverModKwParams{
    DnsserverModArgs: reqArgs,
    DnsserverModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsserver_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsserverModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsserverModArgs struct {
  
    /*
Server name
DNS Server name
    */
    Idnsserverid string `json:"idnsserverid,omitempty"`
  }

type DnsserverModOptionalArgs struct {
  
    /*
SOA mname override
SOA mname (authoritative server) override
    */
    Idnssoamname *interface{} `json:"idnssoamname,omitempty"`
  
    /*
Forwarders
Per-server forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-server conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsserverModKwParams struct {
  *DnsserverModArgs
  *DnsserverModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsserverModResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsserverModResult `json:"result"`
}
type DnsserverModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnsserver `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *DnsserverModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsserverModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsserverModResult%v", string(b))
}

/*
Display configuration of a DNS server.
*/
func (c *Client) DnsserverShow(
  reqArgs *DnsserverShowArgs,
  optArgs *DnsserverShowOptionalArgs, // can be nil
) (*DnsserverShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnsserverShowKwParams{
    DnsserverShowArgs: reqArgs,
    DnsserverShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnsserver_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnsserverShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnsserverShowArgs struct {
  
    /*
Server name
DNS Server name
    */
    Idnsserverid string `json:"idnsserverid,omitempty"`
  }

type DnsserverShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnsserverShowKwParams struct {
  *DnsserverShowArgs
  *DnsserverShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnsserverShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DnsserverShowResult `json:"result"`
}
type DnsserverShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnsserver `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *DnsserverShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnsserverShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnsserverShowResult%v", string(b))
}

/*
Create new DNS zone (SOA record).
*/
func (c *Client) DnszoneAdd(
  reqArgs *DnszoneAddArgs,
  optArgs *DnszoneAddOptionalArgs, // can be nil
) (*DnszoneAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneAddKwParams{
    DnszoneAddArgs: reqArgs,
    DnszoneAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneAddArgs struct {
  
    /*
SOA serial
SOA record serial number
    */
    Idnssoaserial int `json:"idnssoaserial,omitempty"`
  }

type DnszoneAddOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Authoritative nameserver
Authoritative nameserver domain name
    */
    Idnssoamname *interface{} `json:"idnssoamname,omitempty"`
  
    /*
Administrator e-mail address
Administrator e-mail address
    */
    Idnssoarname *interface{} `json:"idnssoarname,omitempty"`
  
    /*
SOA refresh
SOA record refresh time
    */
    Idnssoarefresh *int `json:"idnssoarefresh,omitempty"`
  
    /*
SOA retry
SOA record retry time
    */
    Idnssoaretry *int `json:"idnssoaretry,omitempty"`
  
    /*
SOA expire
SOA record expire time
    */
    Idnssoaexpire *int `json:"idnssoaexpire,omitempty"`
  
    /*
SOA minimum
How long should negative responses be cached
    */
    Idnssoaminimum *int `json:"idnssoaminimum,omitempty"`
  
    /*
Time to live
Time to live for records at zone apex
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*
Default time to live
Time to live for records without explicit TTL definition
    */
    Dnsdefaultttl *int `json:"dnsdefaultttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
BIND update policy
BIND update policy
    */
    Idnsupdatepolicy *string `json:"idnsupdatepolicy,omitempty"`
  
    /*
Dynamic update
Allow dynamic updates.
    */
    Idnsallowdynupdate *bool `json:"idnsallowdynupdate,omitempty"`
  
    /*
Allow query
Semicolon separated list of IP addresses or networks which are allowed to issue queries
    */
    Idnsallowquery *string `json:"idnsallowquery,omitempty"`
  
    /*
Allow transfer
Semicolon separated list of IP addresses or networks which are allowed to transfer the zone
    */
    Idnsallowtransfer *string `json:"idnsallowtransfer,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records in the zone
    */
    Idnsallowsyncptr *bool `json:"idnsallowsyncptr,omitempty"`
  
    /*
Allow in-line DNSSEC signing
Allow inline DNSSEC signing of records in the zone
    */
    Idnssecinlinesigning *bool `json:"idnssecinlinesigning,omitempty"`
  
    /*
NSEC3PARAM record
NSEC3PARAM record for zone in format: hash_algorithm flags iterations salt
    */
    Nsec3paramrecord *string `json:"nsec3paramrecord,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Force DNS zone creation even if it will overlap with an existing zone.
    */
    SkipOverlapCheck *bool `json:"skip_overlap_check,omitempty"`
  
    /*

Force DNS zone creation even if nameserver is not resolvable. (Deprecated)
    */
    Force *bool `json:"force,omitempty"`
  
    /*

Force DNS zone creation even if nameserver is not resolvable.
    */
    SkipNameserverCheck *bool `json:"skip_nameserver_check,omitempty"`
  
    /*


    */
    IPAddress *string `json:"ip_address,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnszoneAddKwParams struct {
  *DnszoneAddArgs
  *DnszoneAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneAddResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneAddResult `json:"result"`
}
type DnszoneAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnszone `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnszoneAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneAddResult%v", string(b))
}

/*
Add a permission for per-zone access delegation.
*/
func (c *Client) DnszoneAddPermission(
  reqArgs *DnszoneAddPermissionArgs,
  optArgs *DnszoneAddPermissionOptionalArgs, // can be nil
) (*DnszoneAddPermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneAddPermissionKwParams{
    DnszoneAddPermissionArgs: reqArgs,
    DnszoneAddPermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_add_permission",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneAddPermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneAddPermissionArgs struct {
  }

type DnszoneAddPermissionOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  }

type dnszoneAddPermissionKwParams struct {
  *DnszoneAddPermissionArgs
  *DnszoneAddPermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneAddPermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneAddPermissionResult `json:"result"`
}
type DnszoneAddPermissionResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
Permission value
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *DnszoneAddPermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneAddPermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneAddPermissionResult%v", string(b))
}

/*
Delete DNS zone (SOA record).
*/
func (c *Client) DnszoneDel(
  reqArgs *DnszoneDelArgs,
  optArgs *DnszoneDelOptionalArgs, // can be nil
) (*DnszoneDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneDelKwParams{
    DnszoneDelArgs: reqArgs,
    DnszoneDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneDelArgs struct {
  }

type DnszoneDelOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *[]interface{} `json:"idnsname,omitempty"`
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type dnszoneDelKwParams struct {
  *DnszoneDelArgs
  *DnszoneDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneDelResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneDelResult `json:"result"`
}
type DnszoneDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []interface{} `json:"value,omitempty"`
    
  }

func (t *DnszoneDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneDelResult%v", string(b))
}

/*
Disable DNS Zone.
*/
func (c *Client) DnszoneDisable(
  reqArgs *DnszoneDisableArgs,
  optArgs *DnszoneDisableOptionalArgs, // can be nil
) (*DnszoneDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneDisableKwParams{
    DnszoneDisableArgs: reqArgs,
    DnszoneDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneDisableArgs struct {
  }

type DnszoneDisableOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  }

type dnszoneDisableKwParams struct {
  *DnszoneDisableArgs
  *DnszoneDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneDisableResult `json:"result"`
}
type DnszoneDisableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnszoneDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneDisableResult%v", string(b))
}

/*
Enable DNS Zone.
*/
func (c *Client) DnszoneEnable(
  reqArgs *DnszoneEnableArgs,
  optArgs *DnszoneEnableOptionalArgs, // can be nil
) (*DnszoneEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneEnableKwParams{
    DnszoneEnableArgs: reqArgs,
    DnszoneEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_enable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneEnableArgs struct {
  }

type DnszoneEnableOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  }

type dnszoneEnableKwParams struct {
  *DnszoneEnableArgs
  *DnszoneEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneEnableResult `json:"result"`
}
type DnszoneEnableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnszoneEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneEnableResult%v", string(b))
}

/*
Search for DNS zones (SOA records).
*/
func (c *Client) DnszoneFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *DnszoneFindArgs,
  optArgs *DnszoneFindOptionalArgs, // can be nil
) (*DnszoneFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneFindKwParams{
    DnszoneFindArgs: reqArgs,
    DnszoneFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneFindArgs struct {
  }

type DnszoneFindOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Active zone
Is zone active?
    */
    Idnszoneactive *bool `json:"idnszoneactive,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Authoritative nameserver
Authoritative nameserver domain name
    */
    Idnssoamname *interface{} `json:"idnssoamname,omitempty"`
  
    /*
Administrator e-mail address
Administrator e-mail address
    */
    Idnssoarname *interface{} `json:"idnssoarname,omitempty"`
  
    /*
SOA serial
SOA record serial number
    */
    Idnssoaserial *int `json:"idnssoaserial,omitempty"`
  
    /*
SOA refresh
SOA record refresh time
    */
    Idnssoarefresh *int `json:"idnssoarefresh,omitempty"`
  
    /*
SOA retry
SOA record retry time
    */
    Idnssoaretry *int `json:"idnssoaretry,omitempty"`
  
    /*
SOA expire
SOA record expire time
    */
    Idnssoaexpire *int `json:"idnssoaexpire,omitempty"`
  
    /*
SOA minimum
How long should negative responses be cached
    */
    Idnssoaminimum *int `json:"idnssoaminimum,omitempty"`
  
    /*
Time to live
Time to live for records at zone apex
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*
Default time to live
Time to live for records without explicit TTL definition
    */
    Dnsdefaultttl *int `json:"dnsdefaultttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
BIND update policy
BIND update policy
    */
    Idnsupdatepolicy *string `json:"idnsupdatepolicy,omitempty"`
  
    /*
Dynamic update
Allow dynamic updates.
    */
    Idnsallowdynupdate *bool `json:"idnsallowdynupdate,omitempty"`
  
    /*
Allow query
Semicolon separated list of IP addresses or networks which are allowed to issue queries
    */
    Idnsallowquery *string `json:"idnsallowquery,omitempty"`
  
    /*
Allow transfer
Semicolon separated list of IP addresses or networks which are allowed to transfer the zone
    */
    Idnsallowtransfer *string `json:"idnsallowtransfer,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records in the zone
    */
    Idnsallowsyncptr *bool `json:"idnsallowsyncptr,omitempty"`
  
    /*
Allow in-line DNSSEC signing
Allow inline DNSSEC signing of records in the zone
    */
    Idnssecinlinesigning *bool `json:"idnssecinlinesigning,omitempty"`
  
    /*
NSEC3PARAM record
NSEC3PARAM record for zone in format: hash_algorithm flags iterations salt
    */
    Nsec3paramrecord *string `json:"nsec3paramrecord,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*
Forward zones only
Search for forward zones only
    */
    ForwardOnly *bool `json:"forward_only,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type dnszoneFindKwParams struct {
  *DnszoneFindArgs
  *DnszoneFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneFindResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneFindResult `json:"result"`
}
type DnszoneFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Dnszone `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *DnszoneFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneFindResult%v", string(b))
}

/*
Modify DNS zone (SOA record).
*/
func (c *Client) DnszoneMod(
  reqArgs *DnszoneModArgs,
  optArgs *DnszoneModOptionalArgs, // can be nil
) (*DnszoneModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneModKwParams{
    DnszoneModArgs: reqArgs,
    DnszoneModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneModArgs struct {
  }

type DnszoneModOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Authoritative nameserver
Authoritative nameserver domain name
    */
    Idnssoamname *interface{} `json:"idnssoamname,omitempty"`
  
    /*
Administrator e-mail address
Administrator e-mail address
    */
    Idnssoarname *interface{} `json:"idnssoarname,omitempty"`
  
    /*
SOA serial
SOA record serial number
    */
    Idnssoaserial *int `json:"idnssoaserial,omitempty"`
  
    /*
SOA refresh
SOA record refresh time
    */
    Idnssoarefresh *int `json:"idnssoarefresh,omitempty"`
  
    /*
SOA retry
SOA record retry time
    */
    Idnssoaretry *int `json:"idnssoaretry,omitempty"`
  
    /*
SOA expire
SOA record expire time
    */
    Idnssoaexpire *int `json:"idnssoaexpire,omitempty"`
  
    /*
SOA minimum
How long should negative responses be cached
    */
    Idnssoaminimum *int `json:"idnssoaminimum,omitempty"`
  
    /*
Time to live
Time to live for records at zone apex
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*
Default time to live
Time to live for records without explicit TTL definition
    */
    Dnsdefaultttl *int `json:"dnsdefaultttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
BIND update policy
BIND update policy
    */
    Idnsupdatepolicy *string `json:"idnsupdatepolicy,omitempty"`
  
    /*
Dynamic update
Allow dynamic updates.
    */
    Idnsallowdynupdate *bool `json:"idnsallowdynupdate,omitempty"`
  
    /*
Allow query
Semicolon separated list of IP addresses or networks which are allowed to issue queries
    */
    Idnsallowquery *string `json:"idnsallowquery,omitempty"`
  
    /*
Allow transfer
Semicolon separated list of IP addresses or networks which are allowed to transfer the zone
    */
    Idnsallowtransfer *string `json:"idnsallowtransfer,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records in the zone
    */
    Idnsallowsyncptr *bool `json:"idnsallowsyncptr,omitempty"`
  
    /*
Allow in-line DNSSEC signing
Allow inline DNSSEC signing of records in the zone
    */
    Idnssecinlinesigning *bool `json:"idnssecinlinesigning,omitempty"`
  
    /*
NSEC3PARAM record
NSEC3PARAM record for zone in format: hash_algorithm flags iterations salt
    */
    Nsec3paramrecord *string `json:"nsec3paramrecord,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Force
Force nameserver change even if nameserver not in DNS
    */
    Force *bool `json:"force,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnszoneModKwParams struct {
  *DnszoneModArgs
  *DnszoneModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneModResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneModResult `json:"result"`
}
type DnszoneModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnszone `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnszoneModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneModResult%v", string(b))
}

/*
Remove a permission for per-zone access delegation.
*/
func (c *Client) DnszoneRemovePermission(
  reqArgs *DnszoneRemovePermissionArgs,
  optArgs *DnszoneRemovePermissionOptionalArgs, // can be nil
) (*DnszoneRemovePermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneRemovePermissionKwParams{
    DnszoneRemovePermissionArgs: reqArgs,
    DnszoneRemovePermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_remove_permission",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneRemovePermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneRemovePermissionArgs struct {
  }

type DnszoneRemovePermissionOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  }

type dnszoneRemovePermissionKwParams struct {
  *DnszoneRemovePermissionArgs
  *DnszoneRemovePermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneRemovePermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneRemovePermissionResult `json:"result"`
}
type DnszoneRemovePermissionResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
Permission value
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *DnszoneRemovePermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneRemovePermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneRemovePermissionResult%v", string(b))
}

/*
Display information about a DNS zone (SOA record).
*/
func (c *Client) DnszoneShow(
  reqArgs *DnszoneShowArgs,
  optArgs *DnszoneShowOptionalArgs, // can be nil
) (*DnszoneShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := dnszoneShowKwParams{
    DnszoneShowArgs: reqArgs,
    DnszoneShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "dnszone_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res dnszoneShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DnszoneShowArgs struct {
  }

type DnszoneShowOptionalArgs struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type dnszoneShowKwParams struct {
  *DnszoneShowArgs
  *DnszoneShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type dnszoneShowResponse struct {
	Error  *Error      `json:"error"`
	Result *DnszoneShowResult `json:"result"`
}
type DnszoneShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Dnszone `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *DnszoneShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DnszoneShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DnszoneShowResult%v", string(b))
}

/*
Query current Domain Level.
*/
func (c *Client) DomainlevelGet(
  reqArgs *DomainlevelGetArgs,
  optArgs *DomainlevelGetOptionalArgs, // can be nil
) (*DomainlevelGetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := domainlevelGetKwParams{
    DomainlevelGetArgs: reqArgs,
    DomainlevelGetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "domainlevel_get",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res domainlevelGetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DomainlevelGetArgs struct {
  }

type DomainlevelGetOptionalArgs struct {
  }

type domainlevelGetKwParams struct {
  *DomainlevelGetArgs
  *DomainlevelGetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type domainlevelGetResponse struct {
	Error  *Error      `json:"error"`
	Result *DomainlevelGetResult `json:"result"`
}
type DomainlevelGetResult struct {
  
  
  
    /*
Current domain level:
    (required)
    */
    
    Result int `json:"result,omitempty"`
    
  }

func (t *DomainlevelGetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DomainlevelGetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DomainlevelGetResult%v", string(b))
}

/*
Change current Domain Level.
*/
func (c *Client) DomainlevelSet(
  reqArgs *DomainlevelSetArgs,
  optArgs *DomainlevelSetOptionalArgs, // can be nil
) (*DomainlevelSetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := domainlevelSetKwParams{
    DomainlevelSetArgs: reqArgs,
    DomainlevelSetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "domainlevel_set",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res domainlevelSetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type DomainlevelSetArgs struct {
  
    /*
Domain Level

    */
    Ipadomainlevel int `json:"ipadomainlevel,omitempty"`
  }

type DomainlevelSetOptionalArgs struct {
  }

type domainlevelSetKwParams struct {
  *DomainlevelSetArgs
  *DomainlevelSetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type domainlevelSetResponse struct {
	Error  *Error      `json:"error"`
	Result *DomainlevelSetResult `json:"result"`
}
type DomainlevelSetResult struct {
  
  
  
    /*
Current domain level:
    (required)
    */
    
    Result int `json:"result,omitempty"`
    
  }

func (t *DomainlevelSetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DomainlevelSetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DomainlevelSetResult%v", string(b))
}

/*
Create a new group.
*/
func (c *Client) GroupAdd(
  reqArgs *GroupAddArgs,
  optArgs *GroupAddOptionalArgs, // can be nil
) (*GroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupAddKwParams{
    GroupAddArgs: reqArgs,
    GroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupAddArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupAddOptionalArgs struct {
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
GID
GID (use this option to set it manually)
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Create as a non-POSIX group
    */
    Nonposix *bool `json:"nonposix,omitempty"`
  
    /*

Allow adding external non-IPA members from trusted domains
    */
    External *bool `json:"external,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type groupAddKwParams struct {
  *GroupAddArgs
  *GroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupAddResult `json:"result"`
}
type GroupAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Group `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *GroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupAddResult%v", string(b))
}

/*
Add members to a group.
*/
func (c *Client) GroupAddMember(
  reqArgs *GroupAddMemberArgs,
  optArgs *GroupAddMemberOptionalArgs, // can be nil
) (*GroupAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupAddMemberKwParams{
    GroupAddMemberArgs: reqArgs,
    GroupAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_add_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupAddMemberArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupAddMemberOptionalArgs struct {
  
    /*
External member
Members of a trusted domain in DOM\name or name@domain form
    */
    Ipaexternalmember *[]string `json:"ipaexternalmember,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type groupAddMemberKwParams struct {
  *GroupAddMemberArgs
  *GroupAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupAddMemberResult `json:"result"`
}
type GroupAddMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *GroupAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupAddMemberResult%v", string(b))
}

/*
Delete group.
*/
func (c *Client) GroupDel(
  reqArgs *GroupDelArgs,
  optArgs *GroupDelOptionalArgs, // can be nil
) (*GroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupDelKwParams{
    GroupDelArgs: reqArgs,
    GroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupDelArgs struct {
  
    /*
Group name

    */
    Cn []string `json:"cn,omitempty"`
  }

type GroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type groupDelKwParams struct {
  *GroupDelArgs
  *GroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupDelResult `json:"result"`
}
type GroupDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *GroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupDelResult%v", string(b))
}

/*
Detach a managed group from a user.
*/
func (c *Client) GroupDetach(
  reqArgs *GroupDetachArgs,
  optArgs *GroupDetachOptionalArgs, // can be nil
) (*GroupDetachResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupDetachKwParams{
    GroupDetachArgs: reqArgs,
    GroupDetachOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_detach",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupDetachResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupDetachArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupDetachOptionalArgs struct {
  }

type groupDetachKwParams struct {
  *GroupDetachArgs
  *GroupDetachOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupDetachResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupDetachResult `json:"result"`
}
type GroupDetachResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *GroupDetachResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupDetachResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupDetachResult%v", string(b))
}

/*
Search for groups.
*/
func (c *Client) GroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *GroupFindArgs,
  optArgs *GroupFindOptionalArgs, // can be nil
) (*GroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupFindKwParams{
    GroupFindArgs: reqArgs,
    GroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupFindArgs struct {
  }

type GroupFindOptionalArgs struct {
  
    /*
Group name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
GID
GID (use this option to set it manually)
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

search for private groups
    */
    Private *bool `json:"private,omitempty"`
  
    /*

search for POSIX groups
    */
    Posix *bool `json:"posix,omitempty"`
  
    /*

search for groups with support of external non-IPA members from trusted domains
    */
    External *bool `json:"external,omitempty"`
  
    /*

search for non-POSIX groups
    */
    Nonposix *bool `json:"nonposix,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("group-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
user
Search for groups with these member users.
    */
    User *[]string `json:"user,omitempty"`
  
    /*
user
Search for groups without these member users.
    */
    NoUser *[]string `json:"no_user,omitempty"`
  
    /*
group
Search for groups with these member groups.
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
group
Search for groups without these member groups.
    */
    NoGroup *[]string `json:"no_group,omitempty"`
  
    /*
group
Search for groups with these member of groups.
    */
    InGroup *[]string `json:"in_group,omitempty"`
  
    /*
group
Search for groups without these member of groups.
    */
    NotInGroup *[]string `json:"not_in_group,omitempty"`
  
    /*
netgroup
Search for groups with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for groups without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  
    /*
role
Search for groups with these member of roles.
    */
    InRole *[]string `json:"in_role,omitempty"`
  
    /*
role
Search for groups without these member of roles.
    */
    NotInRole *[]string `json:"not_in_role,omitempty"`
  
    /*
HBAC rule
Search for groups with these member of HBAC rules.
    */
    InHbacrule *[]string `json:"in_hbacrule,omitempty"`
  
    /*
HBAC rule
Search for groups without these member of HBAC rules.
    */
    NotInHbacrule *[]string `json:"not_in_hbacrule,omitempty"`
  
    /*
sudo rule
Search for groups with these member of sudo rules.
    */
    InSudorule *[]string `json:"in_sudorule,omitempty"`
  
    /*
sudo rule
Search for groups without these member of sudo rules.
    */
    NotInSudorule *[]string `json:"not_in_sudorule,omitempty"`
  }

type groupFindKwParams struct {
  *GroupFindArgs
  *GroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupFindResult `json:"result"`
}
type GroupFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Group `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *GroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupFindResult%v", string(b))
}

/*
Modify a group.
*/
func (c *Client) GroupMod(
  reqArgs *GroupModArgs,
  optArgs *GroupModOptionalArgs, // can be nil
) (*GroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupModKwParams{
    GroupModArgs: reqArgs,
    GroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupModArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupModOptionalArgs struct {
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
GID
GID (use this option to set it manually)
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

change to a POSIX group
    */
    Posix *bool `json:"posix,omitempty"`
  
    /*

change to support external non-IPA members from trusted domains
    */
    External *bool `json:"external,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the group object
    */
    Rename *string `json:"rename,omitempty"`
  }

type groupModKwParams struct {
  *GroupModArgs
  *GroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupModResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupModResult `json:"result"`
}
type GroupModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Group `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *GroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupModResult%v", string(b))
}

/*
Remove members from a group.
*/
func (c *Client) GroupRemoveMember(
  reqArgs *GroupRemoveMemberArgs,
  optArgs *GroupRemoveMemberOptionalArgs, // can be nil
) (*GroupRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupRemoveMemberKwParams{
    GroupRemoveMemberArgs: reqArgs,
    GroupRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_remove_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupRemoveMemberArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupRemoveMemberOptionalArgs struct {
  
    /*
External member
Members of a trusted domain in DOM\name or name@domain form
    */
    Ipaexternalmember *[]string `json:"ipaexternalmember,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type groupRemoveMemberKwParams struct {
  *GroupRemoveMemberArgs
  *GroupRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupRemoveMemberResult `json:"result"`
}
type GroupRemoveMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *GroupRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupRemoveMemberResult%v", string(b))
}

/*
Display information about a named group.
*/
func (c *Client) GroupShow(
  reqArgs *GroupShowArgs,
  optArgs *GroupShowOptionalArgs, // can be nil
) (*GroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := groupShowKwParams{
    GroupShowArgs: reqArgs,
    GroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "group_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res groupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type GroupShowArgs struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  }

type GroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type groupShowKwParams struct {
  *GroupShowArgs
  *GroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type groupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *GroupShowResult `json:"result"`
}
type GroupShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Group `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *GroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("GroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("GroupShowResult%v", string(b))
}

/*
Create a new HBAC rule.
*/
func (c *Client) HbacruleAdd(
  reqArgs *HbacruleAddArgs,
  optArgs *HbacruleAddOptionalArgs, // can be nil
) (*HbacruleAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleAddKwParams{
    HbacruleAddArgs: reqArgs,
    HbacruleAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleAddArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleAddOptionalArgs struct {
  
    /*
Rule type
Rule type (allow)
    */
    Accessruletype *string `json:"accessruletype,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Source host category
Source host category the rule applies to
    */
    Sourcehostcategory *string `json:"sourcehostcategory,omitempty"`
  
    /*
Service category
Service category the rule applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacruleAddKwParams struct {
  *HbacruleAddArgs
  *HbacruleAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleAddResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleAddResult `json:"result"`
}
type HbacruleAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hbacrule `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HbacruleAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleAddResult%v", string(b))
}

/*
Add target hosts and hostgroups to an HBAC rule.
*/
func (c *Client) HbacruleAddHost(
  reqArgs *HbacruleAddHostArgs,
  optArgs *HbacruleAddHostOptionalArgs, // can be nil
) (*HbacruleAddHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleAddHostKwParams{
    HbacruleAddHostArgs: reqArgs,
    HbacruleAddHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_add_host",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleAddHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleAddHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleAddHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hbacruleAddHostKwParams struct {
  *HbacruleAddHostArgs
  *HbacruleAddHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleAddHostResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleAddHostResult `json:"result"`
}
type HbacruleAddHostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HbacruleAddHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleAddHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleAddHostResult%v", string(b))
}

/*
Add services to an HBAC rule.
*/
func (c *Client) HbacruleAddService(
  reqArgs *HbacruleAddServiceArgs,
  optArgs *HbacruleAddServiceOptionalArgs, // can be nil
) (*HbacruleAddServiceResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleAddServiceKwParams{
    HbacruleAddServiceArgs: reqArgs,
    HbacruleAddServiceOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_add_service",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleAddServiceResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleAddServiceArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleAddServiceOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member HBAC service
HBAC services to add
    */
    Hbacsvc *[]string `json:"hbacsvc,omitempty"`
  
    /*
member HBAC service group
HBAC service groups to add
    */
    Hbacsvcgroup *[]string `json:"hbacsvcgroup,omitempty"`
  }

type hbacruleAddServiceKwParams struct {
  *HbacruleAddServiceArgs
  *HbacruleAddServiceOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleAddServiceResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleAddServiceResult `json:"result"`
}
type HbacruleAddServiceResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HbacruleAddServiceResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleAddServiceResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleAddServiceResult%v", string(b))
}

/*

*/
func (c *Client) HbacruleAddSourcehost(
  reqArgs *HbacruleAddSourcehostArgs,
  optArgs *HbacruleAddSourcehostOptionalArgs, // can be nil
) (*HbacruleAddSourcehostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleAddSourcehostKwParams{
    HbacruleAddSourcehostArgs: reqArgs,
    HbacruleAddSourcehostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_add_sourcehost",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleAddSourcehostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleAddSourcehostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleAddSourcehostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hbacruleAddSourcehostKwParams struct {
  *HbacruleAddSourcehostArgs
  *HbacruleAddSourcehostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleAddSourcehostResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleAddSourcehostResult `json:"result"`
}
type HbacruleAddSourcehostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HbacruleAddSourcehostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleAddSourcehostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleAddSourcehostResult%v", string(b))
}

/*
Add users and groups to an HBAC rule.
*/
func (c *Client) HbacruleAddUser(
  reqArgs *HbacruleAddUserArgs,
  optArgs *HbacruleAddUserOptionalArgs, // can be nil
) (*HbacruleAddUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleAddUserKwParams{
    HbacruleAddUserArgs: reqArgs,
    HbacruleAddUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_add_user",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleAddUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleAddUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleAddUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type hbacruleAddUserKwParams struct {
  *HbacruleAddUserArgs
  *HbacruleAddUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleAddUserResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleAddUserResult `json:"result"`
}
type HbacruleAddUserResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HbacruleAddUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleAddUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleAddUserResult%v", string(b))
}

/*
Delete an HBAC rule.
*/
func (c *Client) HbacruleDel(
  reqArgs *HbacruleDelArgs,
  optArgs *HbacruleDelOptionalArgs, // can be nil
) (*HbacruleDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleDelKwParams{
    HbacruleDelArgs: reqArgs,
    HbacruleDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleDelArgs struct {
  
    /*
Rule name

    */
    Cn []string `json:"cn,omitempty"`
  }

type HbacruleDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type hbacruleDelKwParams struct {
  *HbacruleDelArgs
  *HbacruleDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleDelResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleDelResult `json:"result"`
}
type HbacruleDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *HbacruleDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleDelResult%v", string(b))
}

/*
Disable an HBAC rule.
*/
func (c *Client) HbacruleDisable(
  reqArgs *HbacruleDisableArgs,
  optArgs *HbacruleDisableOptionalArgs, // can be nil
) (*HbacruleDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleDisableKwParams{
    HbacruleDisableArgs: reqArgs,
    HbacruleDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleDisableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleDisableOptionalArgs struct {
  }

type hbacruleDisableKwParams struct {
  *HbacruleDisableArgs
  *HbacruleDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleDisableResult `json:"result"`
}
type HbacruleDisableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HbacruleDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleDisableResult%v", string(b))
}

/*
Enable an HBAC rule.
*/
func (c *Client) HbacruleEnable(
  reqArgs *HbacruleEnableArgs,
  optArgs *HbacruleEnableOptionalArgs, // can be nil
) (*HbacruleEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleEnableKwParams{
    HbacruleEnableArgs: reqArgs,
    HbacruleEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_enable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleEnableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleEnableOptionalArgs struct {
  }

type hbacruleEnableKwParams struct {
  *HbacruleEnableArgs
  *HbacruleEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleEnableResult `json:"result"`
}
type HbacruleEnableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HbacruleEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleEnableResult%v", string(b))
}

/*
Search for HBAC rules.
*/
func (c *Client) HbacruleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *HbacruleFindArgs,
  optArgs *HbacruleFindOptionalArgs, // can be nil
) (*HbacruleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleFindKwParams{
    HbacruleFindArgs: reqArgs,
    HbacruleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleFindArgs struct {
  }

type HbacruleFindOptionalArgs struct {
  
    /*
Rule name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Rule type
Rule type (allow)
    */
    Accessruletype *string `json:"accessruletype,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Source host category
Source host category the rule applies to
    */
    Sourcehostcategory *string `json:"sourcehostcategory,omitempty"`
  
    /*
Service category
Service category the rule applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type hbacruleFindKwParams struct {
  *HbacruleFindArgs
  *HbacruleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleFindResult `json:"result"`
}
type HbacruleFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Hbacrule `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *HbacruleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleFindResult%v", string(b))
}

/*
Modify an HBAC rule.
*/
func (c *Client) HbacruleMod(
  reqArgs *HbacruleModArgs,
  optArgs *HbacruleModOptionalArgs, // can be nil
) (*HbacruleModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleModKwParams{
    HbacruleModArgs: reqArgs,
    HbacruleModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleModArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleModOptionalArgs struct {
  
    /*
Rule type
Rule type (allow)
    */
    Accessruletype *string `json:"accessruletype,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Source host category
Source host category the rule applies to
    */
    Sourcehostcategory *string `json:"sourcehostcategory,omitempty"`
  
    /*
Service category
Service category the rule applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the HBAC rule object
    */
    Rename *string `json:"rename,omitempty"`
  }

type hbacruleModKwParams struct {
  *HbacruleModArgs
  *HbacruleModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleModResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleModResult `json:"result"`
}
type HbacruleModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hbacrule `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HbacruleModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleModResult%v", string(b))
}

/*
Remove target hosts and hostgroups from an HBAC rule.
*/
func (c *Client) HbacruleRemoveHost(
  reqArgs *HbacruleRemoveHostArgs,
  optArgs *HbacruleRemoveHostOptionalArgs, // can be nil
) (*HbacruleRemoveHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleRemoveHostKwParams{
    HbacruleRemoveHostArgs: reqArgs,
    HbacruleRemoveHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_remove_host",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleRemoveHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleRemoveHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleRemoveHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hbacruleRemoveHostKwParams struct {
  *HbacruleRemoveHostArgs
  *HbacruleRemoveHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleRemoveHostResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleRemoveHostResult `json:"result"`
}
type HbacruleRemoveHostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HbacruleRemoveHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleRemoveHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleRemoveHostResult%v", string(b))
}

/*
Remove service and service groups from an HBAC rule.
*/
func (c *Client) HbacruleRemoveService(
  reqArgs *HbacruleRemoveServiceArgs,
  optArgs *HbacruleRemoveServiceOptionalArgs, // can be nil
) (*HbacruleRemoveServiceResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleRemoveServiceKwParams{
    HbacruleRemoveServiceArgs: reqArgs,
    HbacruleRemoveServiceOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_remove_service",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleRemoveServiceResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleRemoveServiceArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleRemoveServiceOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member HBAC service
HBAC services to remove
    */
    Hbacsvc *[]string `json:"hbacsvc,omitempty"`
  
    /*
member HBAC service group
HBAC service groups to remove
    */
    Hbacsvcgroup *[]string `json:"hbacsvcgroup,omitempty"`
  }

type hbacruleRemoveServiceKwParams struct {
  *HbacruleRemoveServiceArgs
  *HbacruleRemoveServiceOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleRemoveServiceResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleRemoveServiceResult `json:"result"`
}
type HbacruleRemoveServiceResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HbacruleRemoveServiceResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleRemoveServiceResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleRemoveServiceResult%v", string(b))
}

/*

*/
func (c *Client) HbacruleRemoveSourcehost(
  reqArgs *HbacruleRemoveSourcehostArgs,
  optArgs *HbacruleRemoveSourcehostOptionalArgs, // can be nil
) (*HbacruleRemoveSourcehostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleRemoveSourcehostKwParams{
    HbacruleRemoveSourcehostArgs: reqArgs,
    HbacruleRemoveSourcehostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_remove_sourcehost",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleRemoveSourcehostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleRemoveSourcehostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleRemoveSourcehostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hbacruleRemoveSourcehostKwParams struct {
  *HbacruleRemoveSourcehostArgs
  *HbacruleRemoveSourcehostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleRemoveSourcehostResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleRemoveSourcehostResult `json:"result"`
}
type HbacruleRemoveSourcehostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HbacruleRemoveSourcehostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleRemoveSourcehostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleRemoveSourcehostResult%v", string(b))
}

/*
Remove users and groups from an HBAC rule.
*/
func (c *Client) HbacruleRemoveUser(
  reqArgs *HbacruleRemoveUserArgs,
  optArgs *HbacruleRemoveUserOptionalArgs, // can be nil
) (*HbacruleRemoveUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleRemoveUserKwParams{
    HbacruleRemoveUserArgs: reqArgs,
    HbacruleRemoveUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_remove_user",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleRemoveUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleRemoveUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleRemoveUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type hbacruleRemoveUserKwParams struct {
  *HbacruleRemoveUserArgs
  *HbacruleRemoveUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleRemoveUserResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleRemoveUserResult `json:"result"`
}
type HbacruleRemoveUserResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HbacruleRemoveUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleRemoveUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleRemoveUserResult%v", string(b))
}

/*
Display the properties of an HBAC rule.
*/
func (c *Client) HbacruleShow(
  reqArgs *HbacruleShowArgs,
  optArgs *HbacruleShowOptionalArgs, // can be nil
) (*HbacruleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacruleShowKwParams{
    HbacruleShowArgs: reqArgs,
    HbacruleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacrule_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacruleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacruleShowArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacruleShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacruleShowKwParams struct {
  *HbacruleShowArgs
  *HbacruleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacruleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacruleShowResult `json:"result"`
}
type HbacruleShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hbacrule `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HbacruleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacruleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacruleShowResult%v", string(b))
}

/*
Add a new HBAC service.
*/
func (c *Client) HbacsvcAdd(
  reqArgs *HbacsvcAddArgs,
  optArgs *HbacsvcAddOptionalArgs, // can be nil
) (*HbacsvcAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcAddKwParams{
    HbacsvcAddArgs: reqArgs,
    HbacsvcAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvc_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcAddArgs struct {
  
    /*
Service name
HBAC service
    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcAddOptionalArgs struct {
  
    /*
Description
HBAC service description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcAddKwParams struct {
  *HbacsvcAddArgs
  *HbacsvcAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcAddResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcAddResult `json:"result"`
}
type HbacsvcAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hbacsvc `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HbacsvcAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcAddResult%v", string(b))
}

/*
Delete an existing HBAC service.
*/
func (c *Client) HbacsvcDel(
  reqArgs *HbacsvcDelArgs,
  optArgs *HbacsvcDelOptionalArgs, // can be nil
) (*HbacsvcDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcDelKwParams{
    HbacsvcDelArgs: reqArgs,
    HbacsvcDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvc_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcDelArgs struct {
  
    /*
Service name
HBAC service
    */
    Cn []string `json:"cn,omitempty"`
  }

type HbacsvcDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type hbacsvcDelKwParams struct {
  *HbacsvcDelArgs
  *HbacsvcDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcDelResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcDelResult `json:"result"`
}
type HbacsvcDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *HbacsvcDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcDelResult%v", string(b))
}

/*
Search for HBAC services.
*/
func (c *Client) HbacsvcFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *HbacsvcFindArgs,
  optArgs *HbacsvcFindOptionalArgs, // can be nil
) (*HbacsvcFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcFindKwParams{
    HbacsvcFindArgs: reqArgs,
    HbacsvcFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvc_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcFindArgs struct {
  }

type HbacsvcFindOptionalArgs struct {
  
    /*
Service name
HBAC service
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
HBAC service description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("service")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type hbacsvcFindKwParams struct {
  *HbacsvcFindArgs
  *HbacsvcFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcFindResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcFindResult `json:"result"`
}
type HbacsvcFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Hbacsvc `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *HbacsvcFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcFindResult%v", string(b))
}

/*
Modify an HBAC service.
*/
func (c *Client) HbacsvcMod(
  reqArgs *HbacsvcModArgs,
  optArgs *HbacsvcModOptionalArgs, // can be nil
) (*HbacsvcModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcModKwParams{
    HbacsvcModArgs: reqArgs,
    HbacsvcModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvc_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcModArgs struct {
  
    /*
Service name
HBAC service
    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcModOptionalArgs struct {
  
    /*
Description
HBAC service description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcModKwParams struct {
  *HbacsvcModArgs
  *HbacsvcModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcModResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcModResult `json:"result"`
}
type HbacsvcModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hbacsvc `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HbacsvcModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcModResult%v", string(b))
}

/*
Display information about an HBAC service.
*/
func (c *Client) HbacsvcShow(
  reqArgs *HbacsvcShowArgs,
  optArgs *HbacsvcShowOptionalArgs, // can be nil
) (*HbacsvcShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcShowKwParams{
    HbacsvcShowArgs: reqArgs,
    HbacsvcShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvc_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcShowArgs struct {
  
    /*
Service name
HBAC service
    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcShowKwParams struct {
  *HbacsvcShowArgs
  *HbacsvcShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcShowResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcShowResult `json:"result"`
}
type HbacsvcShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hbacsvc `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HbacsvcShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcShowResult%v", string(b))
}

/*
Add a new HBAC service group.
*/
func (c *Client) HbacsvcgroupAdd(
  reqArgs *HbacsvcgroupAddArgs,
  optArgs *HbacsvcgroupAddOptionalArgs, // can be nil
) (*HbacsvcgroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupAddKwParams{
    HbacsvcgroupAddArgs: reqArgs,
    HbacsvcgroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupAddArgs struct {
  
    /*
Service group name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcgroupAddOptionalArgs struct {
  
    /*
Description
HBAC service group description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcgroupAddKwParams struct {
  *HbacsvcgroupAddArgs
  *HbacsvcgroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupAddResult `json:"result"`
}
type HbacsvcgroupAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hbacsvcgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HbacsvcgroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupAddResult%v", string(b))
}

/*
Add members to an HBAC service group.
*/
func (c *Client) HbacsvcgroupAddMember(
  reqArgs *HbacsvcgroupAddMemberArgs,
  optArgs *HbacsvcgroupAddMemberOptionalArgs, // can be nil
) (*HbacsvcgroupAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupAddMemberKwParams{
    HbacsvcgroupAddMemberArgs: reqArgs,
    HbacsvcgroupAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_add_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupAddMemberArgs struct {
  
    /*
Service group name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcgroupAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member HBAC service
HBAC services to add
    */
    Hbacsvc *[]string `json:"hbacsvc,omitempty"`
  }

type hbacsvcgroupAddMemberKwParams struct {
  *HbacsvcgroupAddMemberArgs
  *HbacsvcgroupAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupAddMemberResult `json:"result"`
}
type HbacsvcgroupAddMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HbacsvcgroupAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupAddMemberResult%v", string(b))
}

/*
Delete an HBAC service group.
*/
func (c *Client) HbacsvcgroupDel(
  reqArgs *HbacsvcgroupDelArgs,
  optArgs *HbacsvcgroupDelOptionalArgs, // can be nil
) (*HbacsvcgroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupDelKwParams{
    HbacsvcgroupDelArgs: reqArgs,
    HbacsvcgroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupDelArgs struct {
  
    /*
Service group name

    */
    Cn []string `json:"cn,omitempty"`
  }

type HbacsvcgroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type hbacsvcgroupDelKwParams struct {
  *HbacsvcgroupDelArgs
  *HbacsvcgroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupDelResult `json:"result"`
}
type HbacsvcgroupDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *HbacsvcgroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupDelResult%v", string(b))
}

/*
Search for an HBAC service group.
*/
func (c *Client) HbacsvcgroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *HbacsvcgroupFindArgs,
  optArgs *HbacsvcgroupFindOptionalArgs, // can be nil
) (*HbacsvcgroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupFindKwParams{
    HbacsvcgroupFindArgs: reqArgs,
    HbacsvcgroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupFindArgs struct {
  }

type HbacsvcgroupFindOptionalArgs struct {
  
    /*
Service group name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
HBAC service group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type hbacsvcgroupFindKwParams struct {
  *HbacsvcgroupFindArgs
  *HbacsvcgroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupFindResult `json:"result"`
}
type HbacsvcgroupFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Hbacsvcgroup `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *HbacsvcgroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupFindResult%v", string(b))
}

/*
Modify an HBAC service group.
*/
func (c *Client) HbacsvcgroupMod(
  reqArgs *HbacsvcgroupModArgs,
  optArgs *HbacsvcgroupModOptionalArgs, // can be nil
) (*HbacsvcgroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupModKwParams{
    HbacsvcgroupModArgs: reqArgs,
    HbacsvcgroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupModArgs struct {
  
    /*
Service group name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcgroupModOptionalArgs struct {
  
    /*
Description
HBAC service group description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcgroupModKwParams struct {
  *HbacsvcgroupModArgs
  *HbacsvcgroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupModResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupModResult `json:"result"`
}
type HbacsvcgroupModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hbacsvcgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HbacsvcgroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupModResult%v", string(b))
}

/*
Remove members from an HBAC service group.
*/
func (c *Client) HbacsvcgroupRemoveMember(
  reqArgs *HbacsvcgroupRemoveMemberArgs,
  optArgs *HbacsvcgroupRemoveMemberOptionalArgs, // can be nil
) (*HbacsvcgroupRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupRemoveMemberKwParams{
    HbacsvcgroupRemoveMemberArgs: reqArgs,
    HbacsvcgroupRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_remove_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupRemoveMemberArgs struct {
  
    /*
Service group name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcgroupRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member HBAC service
HBAC services to remove
    */
    Hbacsvc *[]string `json:"hbacsvc,omitempty"`
  }

type hbacsvcgroupRemoveMemberKwParams struct {
  *HbacsvcgroupRemoveMemberArgs
  *HbacsvcgroupRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupRemoveMemberResult `json:"result"`
}
type HbacsvcgroupRemoveMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HbacsvcgroupRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupRemoveMemberResult%v", string(b))
}

/*
Display information about an HBAC service group.
*/
func (c *Client) HbacsvcgroupShow(
  reqArgs *HbacsvcgroupShowArgs,
  optArgs *HbacsvcgroupShowOptionalArgs, // can be nil
) (*HbacsvcgroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbacsvcgroupShowKwParams{
    HbacsvcgroupShowArgs: reqArgs,
    HbacsvcgroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbacsvcgroup_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbacsvcgroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbacsvcgroupShowArgs struct {
  
    /*
Service group name

    */
    Cn string `json:"cn,omitempty"`
  }

type HbacsvcgroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hbacsvcgroupShowKwParams struct {
  *HbacsvcgroupShowArgs
  *HbacsvcgroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbacsvcgroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *HbacsvcgroupShowResult `json:"result"`
}
type HbacsvcgroupShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hbacsvcgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HbacsvcgroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbacsvcgroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbacsvcgroupShowResult%v", string(b))
}

/*
Simulate use of Host-based access controls
*/
func (c *Client) Hbactest(
  reqArgs *HbactestArgs,
  optArgs *HbactestOptionalArgs, // can be nil
) (*HbactestResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hbactestKwParams{
    HbactestArgs: reqArgs,
    HbactestOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hbactest",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hbactestResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HbactestArgs struct {
  
    /*
User name

    */
    User string `json:"user,omitempty"`
  
    /*
Target host

    */
    Targethost string `json:"targethost,omitempty"`
  
    /*
Service

    */
    Service string `json:"service,omitempty"`
  }

type HbactestOptionalArgs struct {
  
    /*
Source host

    */
    Sourcehost *string `json:"sourcehost,omitempty"`
  
    /*
Rules to test. If not specified, --enabled is assumed

    */
    Rules *[]string `json:"rules,omitempty"`
  
    /*
Hide details which rules are matched, not matched, or invalid

    */
    Nodetail *bool `json:"nodetail,omitempty"`
  
    /*
Include all enabled IPA rules into test [default]

    */
    Enabled *bool `json:"enabled,omitempty"`
  
    /*
Include all disabled IPA rules into test

    */
    Disabled *bool `json:"disabled,omitempty"`
  
    /*
Size Limit
Maximum number of rules to process when no --rules is specified
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  }

type hbactestKwParams struct {
  *HbactestArgs
  *HbactestOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hbactestResponse struct {
	Error  *Error      `json:"error"`
	Result *HbactestResult `json:"result"`
}
type HbactestResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
Warning
    (optional)
    */
    
    Warning *[]interface{} `json:"warning,omitempty"`
    
  
    /*
Matched rules
    (optional)
    */
    
    Matched *[]interface{} `json:"matched,omitempty"`
    
  
    /*
Not matched rules
    (optional)
    */
    
    Notmatched *[]interface{} `json:"notmatched,omitempty"`
    
  
    /*
Non-existent or invalid rules
    (optional)
    */
    
    Error *[]interface{} `json:"error,omitempty"`
    
  
    /*
Result of simulation
    (required)
    */
    
    Value bool `json:"value,omitempty"`
    
  }

func (t *HbactestResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HbactestResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HbactestResult%v", string(b))
}

/*
Add a new host.
*/
func (c *Client) HostAdd(
  reqArgs *HostAddArgs,
  optArgs *HostAddOptionalArgs, // can be nil
) (*HostAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAddKwParams{
    HostAddArgs: reqArgs,
    HostAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAddArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostAddOptionalArgs struct {
  
    /*
Description
A description of this host
    */
    Description *string `json:"description,omitempty"`
  
    /*
Locality
Host locality (e.g. "Baltimore, MD")
    */
    L *string `json:"l,omitempty"`
  
    /*
Location
Host location (e.g. "Lab 2")
    */
    Nshostlocation *string `json:"nshostlocation,omitempty"`
  
    /*
Platform
Host hardware platform (e.g. "Lenovo T61")
    */
    Nshardwareplatform *string `json:"nshardwareplatform,omitempty"`
  
    /*
Operating system
Host operating system and version (e.g. "Fedora 9")
    */
    Nsosversion *string `json:"nsosversion,omitempty"`
  
    /*
User password
Password used in bulk enrollment
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random password to be used in bulk enrollment
    */
    Random *bool `json:"random,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
MAC address
Hardware MAC address(es) on this host
    */
    Macaddress *[]string `json:"macaddress,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
Class
Host category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
Assigned ID View

    */
    Ipaassignedidview *string `json:"ipaassignedidview,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *bool `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *bool `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *bool `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Force
force host name even if not in DNS
    */
    Force *bool `json:"force,omitempty"`
  
    /*

skip reverse DNS detection
    */
    NoReverse *bool `json:"no_reverse,omitempty"`
  
    /*
IP Address
Add the host to DNS with this IP address
    */
    IPAddress *string `json:"ip_address,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostAddKwParams struct {
  *HostAddArgs
  *HostAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAddResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAddResult `json:"result"`
}
type HostAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Host `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HostAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAddResult%v", string(b))
}

/*
Add certificates to host entry
*/
func (c *Client) HostAddCert(
  reqArgs *HostAddCertArgs,
  optArgs *HostAddCertOptionalArgs, // can be nil
) (*HostAddCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAddCertKwParams{
    HostAddCertArgs: reqArgs,
    HostAddCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_add_cert",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAddCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAddCertArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type HostAddCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostAddCertKwParams struct {
  *HostAddCertArgs
  *HostAddCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAddCertResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAddCertResult `json:"result"`
}
type HostAddCertResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HostAddCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAddCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAddCertResult%v", string(b))
}

/*
Add hosts that can manage this host.
*/
func (c *Client) HostAddManagedby(
  reqArgs *HostAddManagedbyArgs,
  optArgs *HostAddManagedbyOptionalArgs, // can be nil
) (*HostAddManagedbyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAddManagedbyKwParams{
    HostAddManagedbyArgs: reqArgs,
    HostAddManagedbyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_add_managedby",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAddManagedbyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAddManagedbyArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostAddManagedbyOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  }

type hostAddManagedbyKwParams struct {
  *HostAddManagedbyArgs
  *HostAddManagedbyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAddManagedbyResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAddManagedbyResult `json:"result"`
}
type HostAddManagedbyResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HostAddManagedbyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAddManagedbyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAddManagedbyResult%v", string(b))
}

/*
Add new principal alias to host entry
*/
func (c *Client) HostAddPrincipal(
  reqArgs *HostAddPrincipalArgs,
  optArgs *HostAddPrincipalOptionalArgs, // can be nil
) (*HostAddPrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAddPrincipalKwParams{
    HostAddPrincipalArgs: reqArgs,
    HostAddPrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_add_principal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAddPrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAddPrincipalArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type HostAddPrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostAddPrincipalKwParams struct {
  *HostAddPrincipalArgs
  *HostAddPrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAddPrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAddPrincipalResult `json:"result"`
}
type HostAddPrincipalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HostAddPrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAddPrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAddPrincipalResult%v", string(b))
}

/*
Allow users, groups, hosts or host groups to create a keytab of this host.
*/
func (c *Client) HostAllowCreateKeytab(
  reqArgs *HostAllowCreateKeytabArgs,
  optArgs *HostAllowCreateKeytabOptionalArgs, // can be nil
) (*HostAllowCreateKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAllowCreateKeytabKwParams{
    HostAllowCreateKeytabArgs: reqArgs,
    HostAllowCreateKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_allow_create_keytab",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAllowCreateKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAllowCreateKeytabArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostAllowCreateKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostAllowCreateKeytabKwParams struct {
  *HostAllowCreateKeytabArgs
  *HostAllowCreateKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAllowCreateKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAllowCreateKeytabResult `json:"result"`
}
type HostAllowCreateKeytabResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HostAllowCreateKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAllowCreateKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAllowCreateKeytabResult%v", string(b))
}

/*
Allow users, groups, hosts or host groups to retrieve a keytab of this host.
*/
func (c *Client) HostAllowRetrieveKeytab(
  reqArgs *HostAllowRetrieveKeytabArgs,
  optArgs *HostAllowRetrieveKeytabOptionalArgs, // can be nil
) (*HostAllowRetrieveKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostAllowRetrieveKeytabKwParams{
    HostAllowRetrieveKeytabArgs: reqArgs,
    HostAllowRetrieveKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_allow_retrieve_keytab",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostAllowRetrieveKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostAllowRetrieveKeytabArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostAllowRetrieveKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostAllowRetrieveKeytabKwParams struct {
  *HostAllowRetrieveKeytabArgs
  *HostAllowRetrieveKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostAllowRetrieveKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *HostAllowRetrieveKeytabResult `json:"result"`
}
type HostAllowRetrieveKeytabResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HostAllowRetrieveKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostAllowRetrieveKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostAllowRetrieveKeytabResult%v", string(b))
}

/*
Delete a host.
*/
func (c *Client) HostDel(
  reqArgs *HostDelArgs,
  optArgs *HostDelOptionalArgs, // can be nil
) (*HostDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostDelKwParams{
    HostDelArgs: reqArgs,
    HostDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostDelArgs struct {
  
    /*
Host name

    */
    Fqdn []string `json:"fqdn,omitempty"`
  }

type HostDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*

Remove A, AAAA, SSHFP and PTR records of the host(s) managed by IPA DNS
    */
    Updatedns *bool `json:"updatedns,omitempty"`
  }

type hostDelKwParams struct {
  *HostDelArgs
  *HostDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostDelResponse struct {
	Error  *Error      `json:"error"`
	Result *HostDelResult `json:"result"`
}
type HostDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *HostDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostDelResult%v", string(b))
}

/*
Disable the Kerberos key, SSL certificate and all services of a host.
*/
func (c *Client) HostDisable(
  reqArgs *HostDisableArgs,
  optArgs *HostDisableOptionalArgs, // can be nil
) (*HostDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostDisableKwParams{
    HostDisableArgs: reqArgs,
    HostDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostDisableArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostDisableOptionalArgs struct {
  }

type hostDisableKwParams struct {
  *HostDisableArgs
  *HostDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *HostDisableResult `json:"result"`
}
type HostDisableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HostDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostDisableResult%v", string(b))
}

/*
Disallow users, groups, hosts or host groups to create a keytab of this host.
*/
func (c *Client) HostDisallowCreateKeytab(
  reqArgs *HostDisallowCreateKeytabArgs,
  optArgs *HostDisallowCreateKeytabOptionalArgs, // can be nil
) (*HostDisallowCreateKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostDisallowCreateKeytabKwParams{
    HostDisallowCreateKeytabArgs: reqArgs,
    HostDisallowCreateKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_disallow_create_keytab",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostDisallowCreateKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostDisallowCreateKeytabArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostDisallowCreateKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostDisallowCreateKeytabKwParams struct {
  *HostDisallowCreateKeytabArgs
  *HostDisallowCreateKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostDisallowCreateKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *HostDisallowCreateKeytabResult `json:"result"`
}
type HostDisallowCreateKeytabResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HostDisallowCreateKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostDisallowCreateKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostDisallowCreateKeytabResult%v", string(b))
}

/*
Disallow users, groups, hosts or host groups to retrieve a keytab of this host.
*/
func (c *Client) HostDisallowRetrieveKeytab(
  reqArgs *HostDisallowRetrieveKeytabArgs,
  optArgs *HostDisallowRetrieveKeytabOptionalArgs, // can be nil
) (*HostDisallowRetrieveKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostDisallowRetrieveKeytabKwParams{
    HostDisallowRetrieveKeytabArgs: reqArgs,
    HostDisallowRetrieveKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_disallow_retrieve_keytab",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostDisallowRetrieveKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostDisallowRetrieveKeytabArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostDisallowRetrieveKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostDisallowRetrieveKeytabKwParams struct {
  *HostDisallowRetrieveKeytabArgs
  *HostDisallowRetrieveKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostDisallowRetrieveKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *HostDisallowRetrieveKeytabResult `json:"result"`
}
type HostDisallowRetrieveKeytabResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HostDisallowRetrieveKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostDisallowRetrieveKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostDisallowRetrieveKeytabResult%v", string(b))
}

/*
Search for hosts.
*/
func (c *Client) HostFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *HostFindArgs,
  optArgs *HostFindOptionalArgs, // can be nil
) (*HostFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostFindKwParams{
    HostFindArgs: reqArgs,
    HostFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostFindArgs struct {
  }

type HostFindOptionalArgs struct {
  
    /*
Host name

    */
    Fqdn *string `json:"fqdn,omitempty"`
  
    /*
Description
A description of this host
    */
    Description *string `json:"description,omitempty"`
  
    /*
Locality
Host locality (e.g. "Baltimore, MD")
    */
    L *string `json:"l,omitempty"`
  
    /*
Location
Host location (e.g. "Lab 2")
    */
    Nshostlocation *string `json:"nshostlocation,omitempty"`
  
    /*
Platform
Host hardware platform (e.g. "Lenovo T61")
    */
    Nshardwareplatform *string `json:"nshardwareplatform,omitempty"`
  
    /*
Operating system
Host operating system and version (e.g. "Fedora 9")
    */
    Nsosversion *string `json:"nsosversion,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
MAC address
Hardware MAC address(es) on this host
    */
    Macaddress *[]string `json:"macaddress,omitempty"`
  
    /*
Class
Host category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
Assigned ID View

    */
    Ipaassignedidview *string `json:"ipaassignedidview,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("hostname")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
host group
Search for hosts with these member of host groups.
    */
    InHostgroup *[]string `json:"in_hostgroup,omitempty"`
  
    /*
host group
Search for hosts without these member of host groups.
    */
    NotInHostgroup *[]string `json:"not_in_hostgroup,omitempty"`
  
    /*
netgroup
Search for hosts with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for hosts without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  
    /*
role
Search for hosts with these member of roles.
    */
    InRole *[]string `json:"in_role,omitempty"`
  
    /*
role
Search for hosts without these member of roles.
    */
    NotInRole *[]string `json:"not_in_role,omitempty"`
  
    /*
HBAC rule
Search for hosts with these member of HBAC rules.
    */
    InHbacrule *[]string `json:"in_hbacrule,omitempty"`
  
    /*
HBAC rule
Search for hosts without these member of HBAC rules.
    */
    NotInHbacrule *[]string `json:"not_in_hbacrule,omitempty"`
  
    /*
sudo rule
Search for hosts with these member of sudo rules.
    */
    InSudorule *[]string `json:"in_sudorule,omitempty"`
  
    /*
sudo rule
Search for hosts without these member of sudo rules.
    */
    NotInSudorule *[]string `json:"not_in_sudorule,omitempty"`
  
    /*
user
Search for hosts with these enrolled by users.
    */
    EnrollByUser *[]string `json:"enroll_by_user,omitempty"`
  
    /*
user
Search for hosts without these enrolled by users.
    */
    NotEnrollByUser *[]string `json:"not_enroll_by_user,omitempty"`
  
    /*
host
Search for hosts with these managed by hosts.
    */
    ManByHost *[]string `json:"man_by_host,omitempty"`
  
    /*
host
Search for hosts without these managed by hosts.
    */
    NotManByHost *[]string `json:"not_man_by_host,omitempty"`
  
    /*
host
Search for hosts with these managing hosts.
    */
    ManHost *[]string `json:"man_host,omitempty"`
  
    /*
host
Search for hosts without these managing hosts.
    */
    NotManHost *[]string `json:"not_man_host,omitempty"`
  }

type hostFindKwParams struct {
  *HostFindArgs
  *HostFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostFindResponse struct {
	Error  *Error      `json:"error"`
	Result *HostFindResult `json:"result"`
}
type HostFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Host `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *HostFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostFindResult%v", string(b))
}

/*
Modify information about a host.
*/
func (c *Client) HostMod(
  reqArgs *HostModArgs,
  optArgs *HostModOptionalArgs, // can be nil
) (*HostModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostModKwParams{
    HostModArgs: reqArgs,
    HostModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostModArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostModOptionalArgs struct {
  
    /*
Description
A description of this host
    */
    Description *string `json:"description,omitempty"`
  
    /*
Locality
Host locality (e.g. "Baltimore, MD")
    */
    L *string `json:"l,omitempty"`
  
    /*
Location
Host location (e.g. "Lab 2")
    */
    Nshostlocation *string `json:"nshostlocation,omitempty"`
  
    /*
Platform
Host hardware platform (e.g. "Lenovo T61")
    */
    Nshardwareplatform *string `json:"nshardwareplatform,omitempty"`
  
    /*
Operating system
Host operating system and version (e.g. "Fedora 9")
    */
    Nsosversion *string `json:"nsosversion,omitempty"`
  
    /*
User password
Password used in bulk enrollment
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random password to be used in bulk enrollment
    */
    Random *bool `json:"random,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
MAC address
Hardware MAC address(es) on this host
    */
    Macaddress *[]string `json:"macaddress,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
Class
Host category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
Assigned ID View

    */
    Ipaassignedidview *string `json:"ipaassignedidview,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *bool `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *bool `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *bool `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Update DNS entries
    */
    Updatedns *bool `json:"updatedns,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostModKwParams struct {
  *HostModArgs
  *HostModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostModResponse struct {
	Error  *Error      `json:"error"`
	Result *HostModResult `json:"result"`
}
type HostModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Host `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HostModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostModResult%v", string(b))
}

/*
Remove certificates from host entry
*/
func (c *Client) HostRemoveCert(
  reqArgs *HostRemoveCertArgs,
  optArgs *HostRemoveCertOptionalArgs, // can be nil
) (*HostRemoveCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostRemoveCertKwParams{
    HostRemoveCertArgs: reqArgs,
    HostRemoveCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_remove_cert",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostRemoveCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostRemoveCertArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type HostRemoveCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostRemoveCertKwParams struct {
  *HostRemoveCertArgs
  *HostRemoveCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostRemoveCertResponse struct {
	Error  *Error      `json:"error"`
	Result *HostRemoveCertResult `json:"result"`
}
type HostRemoveCertResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HostRemoveCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostRemoveCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostRemoveCertResult%v", string(b))
}

/*
Remove hosts that can manage this host.
*/
func (c *Client) HostRemoveManagedby(
  reqArgs *HostRemoveManagedbyArgs,
  optArgs *HostRemoveManagedbyOptionalArgs, // can be nil
) (*HostRemoveManagedbyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostRemoveManagedbyKwParams{
    HostRemoveManagedbyArgs: reqArgs,
    HostRemoveManagedbyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_remove_managedby",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostRemoveManagedbyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostRemoveManagedbyArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostRemoveManagedbyOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  }

type hostRemoveManagedbyKwParams struct {
  *HostRemoveManagedbyArgs
  *HostRemoveManagedbyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostRemoveManagedbyResponse struct {
	Error  *Error      `json:"error"`
	Result *HostRemoveManagedbyResult `json:"result"`
}
type HostRemoveManagedbyResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HostRemoveManagedbyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostRemoveManagedbyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostRemoveManagedbyResult%v", string(b))
}

/*
Remove principal alias from a host entry
*/
func (c *Client) HostRemovePrincipal(
  reqArgs *HostRemovePrincipalArgs,
  optArgs *HostRemovePrincipalOptionalArgs, // can be nil
) (*HostRemovePrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostRemovePrincipalKwParams{
    HostRemovePrincipalArgs: reqArgs,
    HostRemovePrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_remove_principal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostRemovePrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostRemovePrincipalArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type HostRemovePrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostRemovePrincipalKwParams struct {
  *HostRemovePrincipalArgs
  *HostRemovePrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostRemovePrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *HostRemovePrincipalResult `json:"result"`
}
type HostRemovePrincipalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HostRemovePrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostRemovePrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostRemovePrincipalResult%v", string(b))
}

/*
Display information about a host.
*/
func (c *Client) HostShow(
  reqArgs *HostShowArgs,
  optArgs *HostShowOptionalArgs, // can be nil
) (*HostShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostShowKwParams{
    HostShowArgs: reqArgs,
    HostShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "host_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostShowArgs struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  }

type HostShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

file to store certificate in
    */
    Out *string `json:"out,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostShowKwParams struct {
  *HostShowArgs
  *HostShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostShowResponse struct {
	Error  *Error      `json:"error"`
	Result *HostShowResult `json:"result"`
}
type HostShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Host `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HostShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostShowResult%v", string(b))
}

/*
Add a new hostgroup.
*/
func (c *Client) HostgroupAdd(
  reqArgs *HostgroupAddArgs,
  optArgs *HostgroupAddOptionalArgs, // can be nil
) (*HostgroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupAddKwParams{
    HostgroupAddArgs: reqArgs,
    HostgroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupAddArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn string `json:"cn,omitempty"`
  }

type HostgroupAddOptionalArgs struct {
  
    /*
Description
A description of this host-group
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostgroupAddKwParams struct {
  *HostgroupAddArgs
  *HostgroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupAddResult `json:"result"`
}
type HostgroupAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hostgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HostgroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupAddResult%v", string(b))
}

/*
Add members to a hostgroup.
*/
func (c *Client) HostgroupAddMember(
  reqArgs *HostgroupAddMemberArgs,
  optArgs *HostgroupAddMemberOptionalArgs, // can be nil
) (*HostgroupAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupAddMemberKwParams{
    HostgroupAddMemberArgs: reqArgs,
    HostgroupAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_add_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupAddMemberArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn string `json:"cn,omitempty"`
  }

type HostgroupAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostgroupAddMemberKwParams struct {
  *HostgroupAddMemberArgs
  *HostgroupAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupAddMemberResult `json:"result"`
}
type HostgroupAddMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HostgroupAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupAddMemberResult%v", string(b))
}

/*
Delete a hostgroup.
*/
func (c *Client) HostgroupDel(
  reqArgs *HostgroupDelArgs,
  optArgs *HostgroupDelOptionalArgs, // can be nil
) (*HostgroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupDelKwParams{
    HostgroupDelArgs: reqArgs,
    HostgroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupDelArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn []string `json:"cn,omitempty"`
  }

type HostgroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type hostgroupDelKwParams struct {
  *HostgroupDelArgs
  *HostgroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupDelResult `json:"result"`
}
type HostgroupDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *HostgroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupDelResult%v", string(b))
}

/*
Search for hostgroups.
*/
func (c *Client) HostgroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *HostgroupFindArgs,
  optArgs *HostgroupFindOptionalArgs, // can be nil
) (*HostgroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupFindKwParams{
    HostgroupFindArgs: reqArgs,
    HostgroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupFindArgs struct {
  }

type HostgroupFindOptionalArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
A description of this host-group
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("hostgroup-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
host
Search for host groups with these member hosts.
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
host
Search for host groups without these member hosts.
    */
    NoHost *[]string `json:"no_host,omitempty"`
  
    /*
host group
Search for host groups with these member host groups.
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
host group
Search for host groups without these member host groups.
    */
    NoHostgroup *[]string `json:"no_hostgroup,omitempty"`
  
    /*
host group
Search for host groups with these member of host groups.
    */
    InHostgroup *[]string `json:"in_hostgroup,omitempty"`
  
    /*
host group
Search for host groups without these member of host groups.
    */
    NotInHostgroup *[]string `json:"not_in_hostgroup,omitempty"`
  
    /*
netgroup
Search for host groups with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for host groups without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  
    /*
HBAC rule
Search for host groups with these member of HBAC rules.
    */
    InHbacrule *[]string `json:"in_hbacrule,omitempty"`
  
    /*
HBAC rule
Search for host groups without these member of HBAC rules.
    */
    NotInHbacrule *[]string `json:"not_in_hbacrule,omitempty"`
  
    /*
sudo rule
Search for host groups with these member of sudo rules.
    */
    InSudorule *[]string `json:"in_sudorule,omitempty"`
  
    /*
sudo rule
Search for host groups without these member of sudo rules.
    */
    NotInSudorule *[]string `json:"not_in_sudorule,omitempty"`
  }

type hostgroupFindKwParams struct {
  *HostgroupFindArgs
  *HostgroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupFindResult `json:"result"`
}
type HostgroupFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Hostgroup `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *HostgroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupFindResult%v", string(b))
}

/*
Modify a hostgroup.
*/
func (c *Client) HostgroupMod(
  reqArgs *HostgroupModArgs,
  optArgs *HostgroupModOptionalArgs, // can be nil
) (*HostgroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupModKwParams{
    HostgroupModArgs: reqArgs,
    HostgroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupModArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn string `json:"cn,omitempty"`
  }

type HostgroupModOptionalArgs struct {
  
    /*
Description
A description of this host-group
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the host group object
    */
    Rename *string `json:"rename,omitempty"`
  }

type hostgroupModKwParams struct {
  *HostgroupModArgs
  *HostgroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupModResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupModResult `json:"result"`
}
type HostgroupModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hostgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HostgroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupModResult%v", string(b))
}

/*
Remove members from a hostgroup.
*/
func (c *Client) HostgroupRemoveMember(
  reqArgs *HostgroupRemoveMemberArgs,
  optArgs *HostgroupRemoveMemberOptionalArgs, // can be nil
) (*HostgroupRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupRemoveMemberKwParams{
    HostgroupRemoveMemberArgs: reqArgs,
    HostgroupRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_remove_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupRemoveMemberArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn string `json:"cn,omitempty"`
  }

type HostgroupRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type hostgroupRemoveMemberKwParams struct {
  *HostgroupRemoveMemberArgs
  *HostgroupRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupRemoveMemberResult `json:"result"`
}
type HostgroupRemoveMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *HostgroupRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupRemoveMemberResult%v", string(b))
}

/*
Display information about a hostgroup.
*/
func (c *Client) HostgroupShow(
  reqArgs *HostgroupShowArgs,
  optArgs *HostgroupShowOptionalArgs, // can be nil
) (*HostgroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := hostgroupShowKwParams{
    HostgroupShowArgs: reqArgs,
    HostgroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "hostgroup_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res hostgroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type HostgroupShowArgs struct {
  
    /*
Host-group
Name of host-group
    */
    Cn string `json:"cn,omitempty"`
  }

type HostgroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type hostgroupShowKwParams struct {
  *HostgroupShowArgs
  *HostgroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type hostgroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *HostgroupShowResult `json:"result"`
}
type HostgroupShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Hostgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *HostgroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("HostgroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("HostgroupShowResult%v", string(b))
}

/*

*/
func (c *Client) I18nMessages(
  reqArgs *I18nMessagesArgs,
  optArgs *I18nMessagesOptionalArgs, // can be nil
) (*I18nMessagesResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := i18nMessagesKwParams{
    I18nMessagesArgs: reqArgs,
    I18nMessagesOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "i18n_messages",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res i18nMessagesResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type I18nMessagesArgs struct {
  }

type I18nMessagesOptionalArgs struct {
  }

type i18nMessagesKwParams struct {
  *I18nMessagesArgs
  *I18nMessagesOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type i18nMessagesResponse struct {
	Error  *Error      `json:"error"`
	Result *I18nMessagesResult `json:"result"`
}
type I18nMessagesResult struct {
  
  
  
    /*
Dict of I18N messages
    (required)
    */
    
    Texts interface{} `json:"texts,omitempty"`
    
  }

func (t *I18nMessagesResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("I18nMessagesResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("I18nMessagesResult%v", string(b))
}

/*
Add a new Group ID override.
*/
func (c *Client) IdoverridegroupAdd(
  reqArgs *IdoverridegroupAddArgs,
  optArgs *IdoverridegroupAddOptionalArgs, // can be nil
) (*IdoverridegroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverridegroupAddKwParams{
    IdoverridegroupAddArgs: reqArgs,
    IdoverridegroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverridegroup_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverridegroupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverridegroupAddArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverridegroupAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Group name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverridegroupAddKwParams struct {
  *IdoverridegroupAddArgs
  *IdoverridegroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverridegroupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverridegroupAddResult `json:"result"`
}
type IdoverridegroupAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idoverridegroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdoverridegroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverridegroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverridegroupAddResult%v", string(b))
}

/*
Delete an Group ID override.
*/
func (c *Client) IdoverridegroupDel(
  reqArgs *IdoverridegroupDelArgs,
  optArgs *IdoverridegroupDelOptionalArgs, // can be nil
) (*IdoverridegroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverridegroupDelKwParams{
    IdoverridegroupDelArgs: reqArgs,
    IdoverridegroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverridegroup_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverridegroupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverridegroupDelArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid []string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverridegroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  }

type idoverridegroupDelKwParams struct {
  *IdoverridegroupDelArgs
  *IdoverridegroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverridegroupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverridegroupDelResult `json:"result"`
}
type IdoverridegroupDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *IdoverridegroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverridegroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverridegroupDelResult%v", string(b))
}

/*
Search for an Group ID override.
*/
func (c *Client) IdoverridegroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *IdoverridegroupFindArgs,
  optArgs *IdoverridegroupFindOptionalArgs, // can be nil
) (*IdoverridegroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverridegroupFindKwParams{
    IdoverridegroupFindArgs: reqArgs,
    IdoverridegroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverridegroup_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverridegroupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverridegroupFindArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  }

type IdoverridegroupFindOptionalArgs struct {
  
    /*
Anchor to override

    */
    Ipaanchoruuid *string `json:"ipaanchoruuid,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Group name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("anchor")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type idoverridegroupFindKwParams struct {
  *IdoverridegroupFindArgs
  *IdoverridegroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverridegroupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverridegroupFindResult `json:"result"`
}
type IdoverridegroupFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Idoverridegroup `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *IdoverridegroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverridegroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverridegroupFindResult%v", string(b))
}

/*
Modify an Group ID override.
*/
func (c *Client) IdoverridegroupMod(
  reqArgs *IdoverridegroupModArgs,
  optArgs *IdoverridegroupModOptionalArgs, // can be nil
) (*IdoverridegroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverridegroupModKwParams{
    IdoverridegroupModArgs: reqArgs,
    IdoverridegroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverridegroup_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverridegroupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverridegroupModArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverridegroupModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Group name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the Group ID override object
    */
    Rename *string `json:"rename,omitempty"`
  }

type idoverridegroupModKwParams struct {
  *IdoverridegroupModArgs
  *IdoverridegroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverridegroupModResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverridegroupModResult `json:"result"`
}
type IdoverridegroupModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idoverridegroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdoverridegroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverridegroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverridegroupModResult%v", string(b))
}

/*
Display information about an Group ID override.
*/
func (c *Client) IdoverridegroupShow(
  reqArgs *IdoverridegroupShowArgs,
  optArgs *IdoverridegroupShowOptionalArgs, // can be nil
) (*IdoverridegroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverridegroupShowKwParams{
    IdoverridegroupShowArgs: reqArgs,
    IdoverridegroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverridegroup_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverridegroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverridegroupShowArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverridegroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverridegroupShowKwParams struct {
  *IdoverridegroupShowArgs
  *IdoverridegroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverridegroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverridegroupShowResult `json:"result"`
}
type IdoverridegroupShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idoverridegroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdoverridegroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverridegroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverridegroupShowResult%v", string(b))
}

/*
Add a new User ID override.
*/
func (c *Client) IdoverrideuserAdd(
  reqArgs *IdoverrideuserAddArgs,
  optArgs *IdoverrideuserAddOptionalArgs, // can be nil
) (*IdoverrideuserAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserAddKwParams{
    IdoverrideuserAddArgs: reqArgs,
    IdoverrideuserAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserAddArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverrideuserAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
UID
User ID Number
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*


    */
    Ipaoriginaluid *string `json:"ipaoriginaluid,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverrideuserAddKwParams struct {
  *IdoverrideuserAddArgs
  *IdoverrideuserAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserAddResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserAddResult `json:"result"`
}
type IdoverrideuserAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idoverrideuser `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdoverrideuserAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserAddResult%v", string(b))
}

/*
Add one or more certificates to the idoverrideuser entry
*/
func (c *Client) IdoverrideuserAddCert(
  reqArgs *IdoverrideuserAddCertArgs,
  optArgs *IdoverrideuserAddCertOptionalArgs, // can be nil
) (*IdoverrideuserAddCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserAddCertKwParams{
    IdoverrideuserAddCertArgs: reqArgs,
    IdoverrideuserAddCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_add_cert",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserAddCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserAddCertArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type IdoverrideuserAddCertOptionalArgs struct {
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverrideuserAddCertKwParams struct {
  *IdoverrideuserAddCertArgs
  *IdoverrideuserAddCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserAddCertResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserAddCertResult `json:"result"`
}
type IdoverrideuserAddCertResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdoverrideuserAddCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserAddCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserAddCertResult%v", string(b))
}

/*
Delete an User ID override.
*/
func (c *Client) IdoverrideuserDel(
  reqArgs *IdoverrideuserDelArgs,
  optArgs *IdoverrideuserDelOptionalArgs, // can be nil
) (*IdoverrideuserDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserDelKwParams{
    IdoverrideuserDelArgs: reqArgs,
    IdoverrideuserDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserDelArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid []string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverrideuserDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  }

type idoverrideuserDelKwParams struct {
  *IdoverrideuserDelArgs
  *IdoverrideuserDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserDelResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserDelResult `json:"result"`
}
type IdoverrideuserDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *IdoverrideuserDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserDelResult%v", string(b))
}

/*
Search for an User ID override.
*/
func (c *Client) IdoverrideuserFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *IdoverrideuserFindArgs,
  optArgs *IdoverrideuserFindOptionalArgs, // can be nil
) (*IdoverrideuserFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserFindKwParams{
    IdoverrideuserFindArgs: reqArgs,
    IdoverrideuserFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserFindArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  }

type IdoverrideuserFindOptionalArgs struct {
  
    /*
Anchor to override

    */
    Ipaanchoruuid *string `json:"ipaanchoruuid,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
UID
User ID Number
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*


    */
    Ipaoriginaluid *string `json:"ipaoriginaluid,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("anchor")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type idoverrideuserFindKwParams struct {
  *IdoverrideuserFindArgs
  *IdoverrideuserFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserFindResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserFindResult `json:"result"`
}
type IdoverrideuserFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Idoverrideuser `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *IdoverrideuserFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserFindResult%v", string(b))
}

/*
Modify an User ID override.
*/
func (c *Client) IdoverrideuserMod(
  reqArgs *IdoverrideuserModArgs,
  optArgs *IdoverrideuserModOptionalArgs, // can be nil
) (*IdoverrideuserModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserModKwParams{
    IdoverrideuserModArgs: reqArgs,
    IdoverrideuserModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserModArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverrideuserModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
UID
User ID Number
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*


    */
    Ipaoriginaluid *string `json:"ipaoriginaluid,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the User ID override object
    */
    Rename *string `json:"rename,omitempty"`
  }

type idoverrideuserModKwParams struct {
  *IdoverrideuserModArgs
  *IdoverrideuserModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserModResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserModResult `json:"result"`
}
type IdoverrideuserModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idoverrideuser `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdoverrideuserModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserModResult%v", string(b))
}

/*
Remove one or more certificates to the idoverrideuser entry
*/
func (c *Client) IdoverrideuserRemoveCert(
  reqArgs *IdoverrideuserRemoveCertArgs,
  optArgs *IdoverrideuserRemoveCertOptionalArgs, // can be nil
) (*IdoverrideuserRemoveCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserRemoveCertKwParams{
    IdoverrideuserRemoveCertArgs: reqArgs,
    IdoverrideuserRemoveCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_remove_cert",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserRemoveCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserRemoveCertArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type IdoverrideuserRemoveCertOptionalArgs struct {
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverrideuserRemoveCertKwParams struct {
  *IdoverrideuserRemoveCertArgs
  *IdoverrideuserRemoveCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserRemoveCertResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserRemoveCertResult `json:"result"`
}
type IdoverrideuserRemoveCertResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdoverrideuserRemoveCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserRemoveCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserRemoveCertResult%v", string(b))
}

/*
Display information about an User ID override.
*/
func (c *Client) IdoverrideuserShow(
  reqArgs *IdoverrideuserShowArgs,
  optArgs *IdoverrideuserShowOptionalArgs, // can be nil
) (*IdoverrideuserShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idoverrideuserShowKwParams{
    IdoverrideuserShowArgs: reqArgs,
    IdoverrideuserShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idoverrideuser_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idoverrideuserShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdoverrideuserShowArgs struct {
  
    /*
ID View Name

    */
    Idviewcn string `json:"idviewcn,omitempty"`
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  }

type IdoverrideuserShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Fallback to AD DC LDAP
Allow falling back to AD DC LDAP when resolving AD trusted objects. For two-way trusts only.
    */
    FallbackToLdap *bool `json:"fallback_to_ldap,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idoverrideuserShowKwParams struct {
  *IdoverrideuserShowArgs
  *IdoverrideuserShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idoverrideuserShowResponse struct {
	Error  *Error      `json:"error"`
	Result *IdoverrideuserShowResult `json:"result"`
}
type IdoverrideuserShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idoverrideuser `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdoverrideuserShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdoverrideuserShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdoverrideuserShowResult%v", string(b))
}

/*
Add new ID range.

    To add a new ID range you always have to specify

        --base-id
        --range-size

    Additionally

        --rid-base
        --secondary-rid-base

    may be given for a new ID range for the local domain while

        --rid-base
        --dom-sid

    must be given to add a new range for a trusted AD domain.

=======
WARNING:

DNA plugin in 389-ds will allocate IDs based on the ranges configured for the
local domain. Currently the DNA plugin *cannot* be reconfigured itself based
on the local ranges set via this family of commands.

Manual configuration change has to be done in the DNA plugin configuration for
the new local range. Specifically, The dnaNextRange attribute of 'cn=Posix
IDs,cn=Distributed Numeric Assignment Plugin,cn=plugins,cn=config' has to be
modified to match the new range.
=======
*/
func (c *Client) IdrangeAdd(
  reqArgs *IdrangeAddArgs,
  optArgs *IdrangeAddOptionalArgs, // can be nil
) (*IdrangeAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idrangeAddKwParams{
    IdrangeAddArgs: reqArgs,
    IdrangeAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idrange_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idrangeAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdrangeAddArgs struct {
  
    /*
Range name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
First Posix ID of the range

    */
    Ipabaseid int `json:"ipabaseid,omitempty"`
  
    /*
Number of IDs in the range

    */
    Ipaidrangesize int `json:"ipaidrangesize,omitempty"`
  }

type IdrangeAddOptionalArgs struct {
  
    /*
First RID of the corresponding RID range

    */
    Ipabaserid *int `json:"ipabaserid,omitempty"`
  
    /*
First RID of the secondary RID range

    */
    Ipasecondarybaserid *int `json:"ipasecondarybaserid,omitempty"`
  
    /*
Domain SID of the trusted domain

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Name of the trusted domain

    */
    Ipanttrusteddomainname *string `json:"ipanttrusteddomainname,omitempty"`
  
    /*
Range type
ID range type, one of ipa-ad-trust, ipa-ad-trust-posix, ipa-local
    */
    Iparangetype *string `json:"iparangetype,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idrangeAddKwParams struct {
  *IdrangeAddArgs
  *IdrangeAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idrangeAddResponse struct {
	Error  *Error      `json:"error"`
	Result *IdrangeAddResult `json:"result"`
}
type IdrangeAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idrange `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdrangeAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdrangeAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdrangeAddResult%v", string(b))
}

/*
Delete an ID range.
*/
func (c *Client) IdrangeDel(
  reqArgs *IdrangeDelArgs,
  optArgs *IdrangeDelOptionalArgs, // can be nil
) (*IdrangeDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idrangeDelKwParams{
    IdrangeDelArgs: reqArgs,
    IdrangeDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idrange_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idrangeDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdrangeDelArgs struct {
  
    /*
Range name

    */
    Cn []string `json:"cn,omitempty"`
  }

type IdrangeDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type idrangeDelKwParams struct {
  *IdrangeDelArgs
  *IdrangeDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idrangeDelResponse struct {
	Error  *Error      `json:"error"`
	Result *IdrangeDelResult `json:"result"`
}
type IdrangeDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *IdrangeDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdrangeDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdrangeDelResult%v", string(b))
}

/*
Search for ranges.
*/
func (c *Client) IdrangeFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *IdrangeFindArgs,
  optArgs *IdrangeFindOptionalArgs, // can be nil
) (*IdrangeFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idrangeFindKwParams{
    IdrangeFindArgs: reqArgs,
    IdrangeFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idrange_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idrangeFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdrangeFindArgs struct {
  }

type IdrangeFindOptionalArgs struct {
  
    /*
Range name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
First Posix ID of the range

    */
    Ipabaseid *int `json:"ipabaseid,omitempty"`
  
    /*
Number of IDs in the range

    */
    Ipaidrangesize *int `json:"ipaidrangesize,omitempty"`
  
    /*
First RID of the corresponding RID range

    */
    Ipabaserid *int `json:"ipabaserid,omitempty"`
  
    /*
First RID of the secondary RID range

    */
    Ipasecondarybaserid *int `json:"ipasecondarybaserid,omitempty"`
  
    /*
Domain SID of the trusted domain

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Range type
ID range type, one of ipa-ad-trust, ipa-ad-trust-posix, ipa-local
    */
    Iparangetype *string `json:"iparangetype,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type idrangeFindKwParams struct {
  *IdrangeFindArgs
  *IdrangeFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idrangeFindResponse struct {
	Error  *Error      `json:"error"`
	Result *IdrangeFindResult `json:"result"`
}
type IdrangeFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Idrange `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *IdrangeFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdrangeFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdrangeFindResult%v", string(b))
}

/*
Modify ID range.

=======
WARNING:

DNA plugin in 389-ds will allocate IDs based on the ranges configured for the
local domain. Currently the DNA plugin *cannot* be reconfigured itself based
on the local ranges set via this family of commands.

Manual configuration change has to be done in the DNA plugin configuration for
the new local range. Specifically, The dnaNextRange attribute of 'cn=Posix
IDs,cn=Distributed Numeric Assignment Plugin,cn=plugins,cn=config' has to be
modified to match the new range.
=======
*/
func (c *Client) IdrangeMod(
  reqArgs *IdrangeModArgs,
  optArgs *IdrangeModOptionalArgs, // can be nil
) (*IdrangeModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idrangeModKwParams{
    IdrangeModArgs: reqArgs,
    IdrangeModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idrange_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idrangeModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdrangeModArgs struct {
  
    /*
Range name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdrangeModOptionalArgs struct {
  
    /*
First Posix ID of the range

    */
    Ipabaseid *int `json:"ipabaseid,omitempty"`
  
    /*
Number of IDs in the range

    */
    Ipaidrangesize *int `json:"ipaidrangesize,omitempty"`
  
    /*
First RID of the corresponding RID range

    */
    Ipabaserid *int `json:"ipabaserid,omitempty"`
  
    /*
First RID of the secondary RID range

    */
    Ipasecondarybaserid *int `json:"ipasecondarybaserid,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Domain SID of the trusted domain

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Name of the trusted domain

    */
    Ipanttrusteddomainname *string `json:"ipanttrusteddomainname,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idrangeModKwParams struct {
  *IdrangeModArgs
  *IdrangeModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idrangeModResponse struct {
	Error  *Error      `json:"error"`
	Result *IdrangeModResult `json:"result"`
}
type IdrangeModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idrange `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdrangeModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdrangeModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdrangeModResult%v", string(b))
}

/*
Display information about a range.
*/
func (c *Client) IdrangeShow(
  reqArgs *IdrangeShowArgs,
  optArgs *IdrangeShowOptionalArgs, // can be nil
) (*IdrangeShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idrangeShowKwParams{
    IdrangeShowArgs: reqArgs,
    IdrangeShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idrange_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idrangeShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdrangeShowArgs struct {
  
    /*
Range name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdrangeShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idrangeShowKwParams struct {
  *IdrangeShowArgs
  *IdrangeShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idrangeShowResponse struct {
	Error  *Error      `json:"error"`
	Result *IdrangeShowResult `json:"result"`
}
type IdrangeShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idrange `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdrangeShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdrangeShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdrangeShowResult%v", string(b))
}

/*
Add a new ID View.
*/
func (c *Client) IdviewAdd(
  reqArgs *IdviewAddArgs,
  optArgs *IdviewAddOptionalArgs, // can be nil
) (*IdviewAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewAddKwParams{
    IdviewAddArgs: reqArgs,
    IdviewAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewAddArgs struct {
  
    /*
ID View Name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdviewAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Domain resolution order
colon-separated list of domains used for short name qualification
    */
    Ipadomainresolutionorder *string `json:"ipadomainresolutionorder,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idviewAddKwParams struct {
  *IdviewAddArgs
  *IdviewAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewAddResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewAddResult `json:"result"`
}
type IdviewAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idview `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdviewAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewAddResult%v", string(b))
}

/*
Applies ID View to specified hosts or current members of specified hostgroups. If any other ID View is applied to the host, it is overridden.
*/
func (c *Client) IdviewApply(
  reqArgs *IdviewApplyArgs,
  optArgs *IdviewApplyOptionalArgs, // can be nil
) (*IdviewApplyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewApplyKwParams{
    IdviewApplyArgs: reqArgs,
    IdviewApplyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_apply",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewApplyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewApplyArgs struct {
  
    /*
ID View Name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdviewApplyOptionalArgs struct {
  
    /*
hosts
Hosts to apply the ID View to
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
hostgroups
Hostgroups to whose hosts apply the ID View to. Please note that view is not applied automatically to any hosts added to the hostgroup after running the idview-apply command.
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type idviewApplyKwParams struct {
  *IdviewApplyArgs
  *IdviewApplyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewApplyResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewApplyResult `json:"result"`
}
type IdviewApplyResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
Hosts that this ID View was applied to.
    (required)
    */
    
    Succeeded interface{} `json:"succeeded,omitempty"`
    
  
    /*
Hosts or hostgroups that this ID View could not be applied to.
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of hosts the ID View was applied to:
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *IdviewApplyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewApplyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewApplyResult%v", string(b))
}

/*
Delete an ID View.
*/
func (c *Client) IdviewDel(
  reqArgs *IdviewDelArgs,
  optArgs *IdviewDelOptionalArgs, // can be nil
) (*IdviewDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewDelKwParams{
    IdviewDelArgs: reqArgs,
    IdviewDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewDelArgs struct {
  
    /*
ID View Name

    */
    Cn []string `json:"cn,omitempty"`
  }

type IdviewDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type idviewDelKwParams struct {
  *IdviewDelArgs
  *IdviewDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewDelResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewDelResult `json:"result"`
}
type IdviewDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *IdviewDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewDelResult%v", string(b))
}

/*
Search for an ID View.
*/
func (c *Client) IdviewFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *IdviewFindArgs,
  optArgs *IdviewFindOptionalArgs, // can be nil
) (*IdviewFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewFindKwParams{
    IdviewFindArgs: reqArgs,
    IdviewFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewFindArgs struct {
  }

type IdviewFindOptionalArgs struct {
  
    /*
ID View Name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type idviewFindKwParams struct {
  *IdviewFindArgs
  *IdviewFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewFindResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewFindResult `json:"result"`
}
type IdviewFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Idview `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *IdviewFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewFindResult%v", string(b))
}

/*
Modify an ID View.
*/
func (c *Client) IdviewMod(
  reqArgs *IdviewModArgs,
  optArgs *IdviewModOptionalArgs, // can be nil
) (*IdviewModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewModKwParams{
    IdviewModArgs: reqArgs,
    IdviewModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewModArgs struct {
  
    /*
ID View Name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdviewModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Domain resolution order
colon-separated list of domains used for short name qualification
    */
    Ipadomainresolutionorder *string `json:"ipadomainresolutionorder,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the ID View object
    */
    Rename *string `json:"rename,omitempty"`
  }

type idviewModKwParams struct {
  *IdviewModArgs
  *IdviewModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewModResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewModResult `json:"result"`
}
type IdviewModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idview `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdviewModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewModResult%v", string(b))
}

/*
Display information about an ID View.
*/
func (c *Client) IdviewShow(
  reqArgs *IdviewShowArgs,
  optArgs *IdviewShowOptionalArgs, // can be nil
) (*IdviewShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewShowKwParams{
    IdviewShowArgs: reqArgs,
    IdviewShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewShowArgs struct {
  
    /*
ID View Name

    */
    Cn string `json:"cn,omitempty"`
  }

type IdviewShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Enumerate all the hosts the view applies to.
    */
    ShowHosts *bool `json:"show_hosts,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type idviewShowKwParams struct {
  *IdviewShowArgs
  *IdviewShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewShowResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewShowResult `json:"result"`
}
type IdviewShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Idview `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *IdviewShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewShowResult%v", string(b))
}

/*
Clears ID View from specified hosts or current members of specified hostgroups.
*/
func (c *Client) IdviewUnapply(
  reqArgs *IdviewUnapplyArgs,
  optArgs *IdviewUnapplyOptionalArgs, // can be nil
) (*IdviewUnapplyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := idviewUnapplyKwParams{
    IdviewUnapplyArgs: reqArgs,
    IdviewUnapplyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "idview_unapply",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res idviewUnapplyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type IdviewUnapplyArgs struct {
  }

type IdviewUnapplyOptionalArgs struct {
  
    /*
hosts
Hosts to clear (any) ID View from.
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
hostgroups
Hostgroups whose hosts should have ID Views cleared. Note that view is not cleared automatically from any host added to the hostgroup after running idview-unapply command.
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type idviewUnapplyKwParams struct {
  *IdviewUnapplyArgs
  *IdviewUnapplyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type idviewUnapplyResponse struct {
	Error  *Error      `json:"error"`
	Result *IdviewUnapplyResult `json:"result"`
}
type IdviewUnapplyResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
Hosts that ID View was cleared from.
    (required)
    */
    
    Succeeded interface{} `json:"succeeded,omitempty"`
    
  
    /*
Hosts or hostgroups that ID View could not be cleared from.
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of hosts that had a ID View was unset:
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *IdviewUnapplyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("IdviewUnapplyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("IdviewUnapplyResult%v", string(b))
}

/*
Join an IPA domain
*/
func (c *Client) Join(
  reqArgs *JoinArgs,
  optArgs *JoinOptionalArgs, // can be nil
) (*JoinResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := joinKwParams{
    JoinArgs: reqArgs,
    JoinOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "join",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res joinResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type JoinArgs struct {
  
    /*

The hostname to register as
    */
    Cn string `json:"cn,omitempty"`
  
    /*

The IPA realm
    */
    Realm string `json:"realm,omitempty"`
  }

type JoinOptionalArgs struct {
  
    /*

Hardware platform of the host (e.g. Lenovo T61)
    */
    Nshardwareplatform *string `json:"nshardwareplatform,omitempty"`
  
    /*

Operating System and version of the host (e.g. Fedora 9)
    */
    Nsosversion *string `json:"nsosversion,omitempty"`
  }

type joinKwParams struct {
  *JoinArgs
  *JoinOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type joinResponse struct {
	Error  *Error      `json:"error"`
	Result *JoinResult `json:"result"`
}
type JoinResult struct {
  
  
  }

func (t *JoinResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("JoinResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("JoinResult%v", string(b))
}

/*
Export plugin meta-data for the webUI.
*/
func (c *Client) JSONMetadata(
  objname string, // Name of object to export
  methodname string, // Name of method to export
  reqArgs *JSONMetadataArgs,
  optArgs *JSONMetadataOptionalArgs, // can be nil
) (*JSONMetadataResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := jsonMetadataKwParams{
    JSONMetadataArgs: reqArgs,
    JSONMetadataOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "json_metadata",
    Params: []interface{}{
      []interface{}{objname, methodname, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res jsonMetadataResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type JSONMetadataArgs struct {
  }

type JSONMetadataOptionalArgs struct {
  
    /*

Name of object to export
    */
    Object *string `json:"object,omitempty"`
  
    /*

Name of method to export
    */
    Method *string `json:"method,omitempty"`
  
    /*

Name of command to export
    */
    Command *string `json:"command,omitempty"`
  }

type jsonMetadataKwParams struct {
  *JSONMetadataArgs
  *JSONMetadataOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type jsonMetadataResponse struct {
	Error  *Error      `json:"error"`
	Result *JSONMetadataResult `json:"result"`
}
type JSONMetadataResult struct {
  
  
  
    /*
Dict of JSON encoded IPA Objects
    (required)
    */
    
    Objects interface{} `json:"objects,omitempty"`
    
  
    /*
Dict of JSON encoded IPA Methods
    (required)
    */
    
    Methods interface{} `json:"methods,omitempty"`
    
  
    /*
Dict of JSON encoded IPA Commands
    (required)
    */
    
    Commands interface{} `json:"commands,omitempty"`
    
  }

func (t *JSONMetadataResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("JSONMetadataResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("JSONMetadataResult%v", string(b))
}

/*

*/
func (c *Client) KraIsEnabled(
  reqArgs *KraIsEnabledArgs,
  optArgs *KraIsEnabledOptionalArgs, // can be nil
) (*KraIsEnabledResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := kraIsEnabledKwParams{
    KraIsEnabledArgs: reqArgs,
    KraIsEnabledOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "kra_is_enabled",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res kraIsEnabledResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type KraIsEnabledArgs struct {
  }

type KraIsEnabledOptionalArgs struct {
  }

type kraIsEnabledKwParams struct {
  *KraIsEnabledArgs
  *KraIsEnabledOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type kraIsEnabledResponse struct {
	Error  *Error      `json:"error"`
	Result *KraIsEnabledResult `json:"result"`
}
type KraIsEnabledResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *KraIsEnabledResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("KraIsEnabledResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("KraIsEnabledResult%v", string(b))
}

/*
Modify Kerberos ticket policy.
*/
func (c *Client) KrbtpolicyMod(
  uid string, // Manage ticket policy for specific user
  reqArgs *KrbtpolicyModArgs,
  optArgs *KrbtpolicyModOptionalArgs, // can be nil
) (*KrbtpolicyModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := krbtpolicyModKwParams{
    KrbtpolicyModArgs: reqArgs,
    KrbtpolicyModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "krbtpolicy_mod",
    Params: []interface{}{
      []interface{}{uid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res krbtpolicyModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type KrbtpolicyModArgs struct {
  }

type KrbtpolicyModOptionalArgs struct {
  
    /*
Max life
Maximum ticket life (seconds)
    */
    Krbmaxticketlife *int `json:"krbmaxticketlife,omitempty"`
  
    /*
Max renew
Maximum renewable age (seconds)
    */
    Krbmaxrenewableage *int `json:"krbmaxrenewableage,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type krbtpolicyModKwParams struct {
  *KrbtpolicyModArgs
  *KrbtpolicyModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type krbtpolicyModResponse struct {
	Error  *Error      `json:"error"`
	Result *KrbtpolicyModResult `json:"result"`
}
type KrbtpolicyModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Krbtpolicy `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *KrbtpolicyModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("KrbtpolicyModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("KrbtpolicyModResult%v", string(b))
}

/*
Reset Kerberos ticket policy to the default values.
*/
func (c *Client) KrbtpolicyReset(
  uid string, // Manage ticket policy for specific user
  reqArgs *KrbtpolicyResetArgs,
  optArgs *KrbtpolicyResetOptionalArgs, // can be nil
) (*KrbtpolicyResetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := krbtpolicyResetKwParams{
    KrbtpolicyResetArgs: reqArgs,
    KrbtpolicyResetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "krbtpolicy_reset",
    Params: []interface{}{
      []interface{}{uid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res krbtpolicyResetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type KrbtpolicyResetArgs struct {
  }

type KrbtpolicyResetOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type krbtpolicyResetKwParams struct {
  *KrbtpolicyResetArgs
  *KrbtpolicyResetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type krbtpolicyResetResponse struct {
	Error  *Error      `json:"error"`
	Result *KrbtpolicyResetResult `json:"result"`
}
type KrbtpolicyResetResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *KrbtpolicyResetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("KrbtpolicyResetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("KrbtpolicyResetResult%v", string(b))
}

/*
Display the current Kerberos ticket policy.
*/
func (c *Client) KrbtpolicyShow(
  uid string, // Manage ticket policy for specific user
  reqArgs *KrbtpolicyShowArgs,
  optArgs *KrbtpolicyShowOptionalArgs, // can be nil
) (*KrbtpolicyShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := krbtpolicyShowKwParams{
    KrbtpolicyShowArgs: reqArgs,
    KrbtpolicyShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "krbtpolicy_show",
    Params: []interface{}{
      []interface{}{uid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res krbtpolicyShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type KrbtpolicyShowArgs struct {
  }

type KrbtpolicyShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type krbtpolicyShowKwParams struct {
  *KrbtpolicyShowArgs
  *KrbtpolicyShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type krbtpolicyShowResponse struct {
	Error  *Error      `json:"error"`
	Result *KrbtpolicyShowResult `json:"result"`
}
type KrbtpolicyShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Krbtpolicy `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *KrbtpolicyShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("KrbtpolicyShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("KrbtpolicyShowResult%v", string(b))
}

/*
Add a new IPA location.
*/
func (c *Client) LocationAdd(
  reqArgs *LocationAddArgs,
  optArgs *LocationAddOptionalArgs, // can be nil
) (*LocationAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := locationAddKwParams{
    LocationAddArgs: reqArgs,
    LocationAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "location_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res locationAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type LocationAddArgs struct {
  
    /*
Location name
IPA location name
    */
    Idnsname interface{} `json:"idnsname,omitempty"`
  }

type LocationAddOptionalArgs struct {
  
    /*
Description
IPA Location description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type locationAddKwParams struct {
  *LocationAddArgs
  *LocationAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type locationAddResponse struct {
	Error  *Error      `json:"error"`
	Result *LocationAddResult `json:"result"`
}
type LocationAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Location `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *LocationAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("LocationAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("LocationAddResult%v", string(b))
}

/*
Delete an IPA location.
*/
func (c *Client) LocationDel(
  reqArgs *LocationDelArgs,
  optArgs *LocationDelOptionalArgs, // can be nil
) (*LocationDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := locationDelKwParams{
    LocationDelArgs: reqArgs,
    LocationDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "location_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res locationDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type LocationDelArgs struct {
  
    /*
Location name
IPA location name
    */
    Idnsname []interface{} `json:"idnsname,omitempty"`
  }

type LocationDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type locationDelKwParams struct {
  *LocationDelArgs
  *LocationDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type locationDelResponse struct {
	Error  *Error      `json:"error"`
	Result *LocationDelResult `json:"result"`
}
type LocationDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []interface{} `json:"value,omitempty"`
    
  }

func (t *LocationDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("LocationDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("LocationDelResult%v", string(b))
}

/*
Search for IPA locations.
*/
func (c *Client) LocationFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *LocationFindArgs,
  optArgs *LocationFindOptionalArgs, // can be nil
) (*LocationFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := locationFindKwParams{
    LocationFindArgs: reqArgs,
    LocationFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "location_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res locationFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type LocationFindArgs struct {
  }

type LocationFindOptionalArgs struct {
  
    /*
Location name
IPA location name
    */
    Idnsname *interface{} `json:"idnsname,omitempty"`
  
    /*
Description
IPA Location description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type locationFindKwParams struct {
  *LocationFindArgs
  *LocationFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type locationFindResponse struct {
	Error  *Error      `json:"error"`
	Result *LocationFindResult `json:"result"`
}
type LocationFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Location `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *LocationFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("LocationFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("LocationFindResult%v", string(b))
}

/*
Modify information about an IPA location.
*/
func (c *Client) LocationMod(
  reqArgs *LocationModArgs,
  optArgs *LocationModOptionalArgs, // can be nil
) (*LocationModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := locationModKwParams{
    LocationModArgs: reqArgs,
    LocationModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "location_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res locationModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type LocationModArgs struct {
  
    /*
Location name
IPA location name
    */
    Idnsname interface{} `json:"idnsname,omitempty"`
  }

type LocationModOptionalArgs struct {
  
    /*
Description
IPA Location description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type locationModKwParams struct {
  *LocationModArgs
  *LocationModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type locationModResponse struct {
	Error  *Error      `json:"error"`
	Result *LocationModResult `json:"result"`
}
type LocationModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Location `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *LocationModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("LocationModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("LocationModResult%v", string(b))
}

/*
Display information about an IPA location.
*/
func (c *Client) LocationShow(
  reqArgs *LocationShowArgs,
  optArgs *LocationShowOptionalArgs, // can be nil
) (*LocationShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := locationShowKwParams{
    LocationShowArgs: reqArgs,
    LocationShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "location_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res locationShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type LocationShowArgs struct {
  
    /*
Location name
IPA location name
    */
    Idnsname interface{} `json:"idnsname,omitempty"`
  }

type LocationShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type locationShowKwParams struct {
  *LocationShowArgs
  *LocationShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type locationShowResponse struct {
	Error  *Error      `json:"error"`
	Result *LocationShowResult `json:"result"`
}
type LocationShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Location `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  
    /*
Servers in location
    (required)
    */
    
    Servers interface{} `json:"servers,omitempty"`
    
  }

func (t *LocationShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("LocationShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("LocationShowResult%v", string(b))
}

/*
Migrate users and groups from DS to IPA.
*/
func (c *Client) MigrateDs(
  reqArgs *MigrateDsArgs,
  optArgs *MigrateDsOptionalArgs, // can be nil
) (*MigrateDsResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := migrateDsKwParams{
    MigrateDsArgs: reqArgs,
    MigrateDsOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "migrate_ds",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res migrateDsResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type MigrateDsArgs struct {
  
    /*
LDAP URI
LDAP URI of DS server to migrate from
    */
    Ldapuri string `json:"ldapuri,omitempty"`
  
    /*
Password
bind password
    */
    Bindpw string `json:"bindpw,omitempty"`
  }

type MigrateDsOptionalArgs struct {
  
    /*
Bind DN

    */
    Binddn *string `json:"binddn,omitempty"`
  
    /*
User container
DN of container for users in DS relative to base DN
    */
    Usercontainer *string `json:"usercontainer,omitempty"`
  
    /*
Group container
DN of container for groups in DS relative to base DN
    */
    Groupcontainer *string `json:"groupcontainer,omitempty"`
  
    /*
User object class
Objectclasses used to search for user entries in DS
    */
    Userobjectclass *[]string `json:"userobjectclass,omitempty"`
  
    /*
Group object class
Objectclasses used to search for group entries in DS
    */
    Groupobjectclass *[]string `json:"groupobjectclass,omitempty"`
  
    /*
Ignore user object class
Objectclasses to be ignored for user entries in DS
    */
    Userignoreobjectclass *[]string `json:"userignoreobjectclass,omitempty"`
  
    /*
Ignore user attribute
Attributes to be ignored for user entries in DS
    */
    Userignoreattribute *[]string `json:"userignoreattribute,omitempty"`
  
    /*
Ignore group object class
Objectclasses to be ignored for group entries in DS
    */
    Groupignoreobjectclass *[]string `json:"groupignoreobjectclass,omitempty"`
  
    /*
Ignore group attribute
Attributes to be ignored for group entries in DS
    */
    Groupignoreattribute *[]string `json:"groupignoreattribute,omitempty"`
  
    /*
Overwrite GID
When migrating a group already existing in IPA domain overwrite the group GID and report as success
    */
    Groupoverwritegid *bool `json:"groupoverwritegid,omitempty"`
  
    /*
LDAP schema
The schema used on the LDAP server. Supported values are RFC2307 and RFC2307bis. The default is RFC2307bis
    */
    Schema *string `json:"schema,omitempty"`
  
    /*
Continue
Continuous operation mode. Errors are reported but the process continues
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Base DN
Base DN on remote LDAP server
    */
    Basedn *string `json:"basedn,omitempty"`
  
    /*
Ignore compat plugin
Allows migration despite the usage of compat plugin
    */
    Compat *bool `json:"compat,omitempty"`
  
    /*
CA certificate
Load CA certificate of LDAP server from FILE
    */
    Cacertfile *string `json:"cacertfile,omitempty"`
  
    /*
Add to default group
Add migrated users without a group to a default group (default: true)
    */
    UseDefGroup *bool `json:"use_def_group,omitempty"`
  
    /*
Search scope
LDAP search scope for users and groups: base, onelevel, or subtree. Defaults to onelevel
    */
    Scope *string `json:"scope,omitempty"`
  
    /*

groups to exclude from migration
    */
    ExcludeGroups *[]string `json:"exclude_groups,omitempty"`
  
    /*

users to exclude from migration
    */
    ExcludeUsers *[]string `json:"exclude_users,omitempty"`
  }

type migrateDsKwParams struct {
  *MigrateDsArgs
  *MigrateDsOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type migrateDsResponse struct {
	Error  *Error      `json:"error"`
	Result *MigrateDsResult `json:"result"`
}
type MigrateDsResult struct {
  
  
  
    /*
Lists of objects migrated; categorized by type.
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Lists of objects that could not be migrated; categorized by type.
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
False if migration mode was disabled.
    (required)
    */
    
    Enabled bool `json:"enabled,omitempty"`
    
  
    /*
False if migration fails because the compatibility plug-in is enabled.
    (required)
    */
    
    Compat bool `json:"compat,omitempty"`
    
  }

func (t *MigrateDsResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("MigrateDsResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("MigrateDsResult%v", string(b))
}

/*
Add a new netgroup.
*/
func (c *Client) NetgroupAdd(
  reqArgs *NetgroupAddArgs,
  optArgs *NetgroupAddOptionalArgs, // can be nil
) (*NetgroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupAddKwParams{
    NetgroupAddArgs: reqArgs,
    NetgroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupAddArgs struct {
  
    /*
Netgroup name

    */
    Cn string `json:"cn,omitempty"`
  }

type NetgroupAddOptionalArgs struct {
  
    /*
Description
Netgroup description
    */
    Description *string `json:"description,omitempty"`
  
    /*
NIS domain name

    */
    Nisdomainname *string `json:"nisdomainname,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type netgroupAddKwParams struct {
  *NetgroupAddArgs
  *NetgroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupAddResult `json:"result"`
}
type NetgroupAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Netgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *NetgroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupAddResult%v", string(b))
}

/*
Add members to a netgroup.
*/
func (c *Client) NetgroupAddMember(
  reqArgs *NetgroupAddMemberArgs,
  optArgs *NetgroupAddMemberOptionalArgs, // can be nil
) (*NetgroupAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupAddMemberKwParams{
    NetgroupAddMemberArgs: reqArgs,
    NetgroupAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_add_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupAddMemberArgs struct {
  
    /*
Netgroup name

    */
    Cn string `json:"cn,omitempty"`
  }

type NetgroupAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
member netgroup
netgroups to add
    */
    Netgroup *[]string `json:"netgroup,omitempty"`
  }

type netgroupAddMemberKwParams struct {
  *NetgroupAddMemberArgs
  *NetgroupAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupAddMemberResult `json:"result"`
}
type NetgroupAddMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *NetgroupAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupAddMemberResult%v", string(b))
}

/*
Delete a netgroup.
*/
func (c *Client) NetgroupDel(
  reqArgs *NetgroupDelArgs,
  optArgs *NetgroupDelOptionalArgs, // can be nil
) (*NetgroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupDelKwParams{
    NetgroupDelArgs: reqArgs,
    NetgroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupDelArgs struct {
  
    /*
Netgroup name

    */
    Cn []string `json:"cn,omitempty"`
  }

type NetgroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type netgroupDelKwParams struct {
  *NetgroupDelArgs
  *NetgroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupDelResult `json:"result"`
}
type NetgroupDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *NetgroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupDelResult%v", string(b))
}

/*
Search for a netgroup.
*/
func (c *Client) NetgroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *NetgroupFindArgs,
  optArgs *NetgroupFindOptionalArgs, // can be nil
) (*NetgroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupFindKwParams{
    NetgroupFindArgs: reqArgs,
    NetgroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupFindArgs struct {
  }

type NetgroupFindOptionalArgs struct {
  
    /*
Netgroup name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Netgroup description
    */
    Description *string `json:"description,omitempty"`
  
    /*
NIS domain name

    */
    Nisdomainname *string `json:"nisdomainname,omitempty"`
  
    /*
IPA unique ID
IPA unique ID
    */
    Ipauniqueid *string `json:"ipauniqueid,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*


    */
    Private *bool `json:"private,omitempty"`
  
    /*

search for managed groups
    */
    Managed *bool `json:"managed,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
netgroup
Search for netgroups with these member netgroups.
    */
    Netgroup *[]string `json:"netgroup,omitempty"`
  
    /*
netgroup
Search for netgroups without these member netgroups.
    */
    NoNetgroup *[]string `json:"no_netgroup,omitempty"`
  
    /*
user
Search for netgroups with these member users.
    */
    User *[]string `json:"user,omitempty"`
  
    /*
user
Search for netgroups without these member users.
    */
    NoUser *[]string `json:"no_user,omitempty"`
  
    /*
group
Search for netgroups with these member groups.
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
group
Search for netgroups without these member groups.
    */
    NoGroup *[]string `json:"no_group,omitempty"`
  
    /*
host
Search for netgroups with these member hosts.
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
host
Search for netgroups without these member hosts.
    */
    NoHost *[]string `json:"no_host,omitempty"`
  
    /*
host group
Search for netgroups with these member host groups.
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
host group
Search for netgroups without these member host groups.
    */
    NoHostgroup *[]string `json:"no_hostgroup,omitempty"`
  
    /*
netgroup
Search for netgroups with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for netgroups without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  }

type netgroupFindKwParams struct {
  *NetgroupFindArgs
  *NetgroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupFindResult `json:"result"`
}
type NetgroupFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Netgroup `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *NetgroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupFindResult%v", string(b))
}

/*
Modify a netgroup.
*/
func (c *Client) NetgroupMod(
  reqArgs *NetgroupModArgs,
  optArgs *NetgroupModOptionalArgs, // can be nil
) (*NetgroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupModKwParams{
    NetgroupModArgs: reqArgs,
    NetgroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupModArgs struct {
  
    /*
Netgroup name

    */
    Cn string `json:"cn,omitempty"`
  }

type NetgroupModOptionalArgs struct {
  
    /*
Description
Netgroup description
    */
    Description *string `json:"description,omitempty"`
  
    /*
NIS domain name

    */
    Nisdomainname *string `json:"nisdomainname,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type netgroupModKwParams struct {
  *NetgroupModArgs
  *NetgroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupModResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupModResult `json:"result"`
}
type NetgroupModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Netgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *NetgroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupModResult%v", string(b))
}

/*
Remove members from a netgroup.
*/
func (c *Client) NetgroupRemoveMember(
  reqArgs *NetgroupRemoveMemberArgs,
  optArgs *NetgroupRemoveMemberOptionalArgs, // can be nil
) (*NetgroupRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupRemoveMemberKwParams{
    NetgroupRemoveMemberArgs: reqArgs,
    NetgroupRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_remove_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupRemoveMemberArgs struct {
  
    /*
Netgroup name

    */
    Cn string `json:"cn,omitempty"`
  }

type NetgroupRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
member netgroup
netgroups to remove
    */
    Netgroup *[]string `json:"netgroup,omitempty"`
  }

type netgroupRemoveMemberKwParams struct {
  *NetgroupRemoveMemberArgs
  *NetgroupRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupRemoveMemberResult `json:"result"`
}
type NetgroupRemoveMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *NetgroupRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupRemoveMemberResult%v", string(b))
}

/*
Display information about a netgroup.
*/
func (c *Client) NetgroupShow(
  reqArgs *NetgroupShowArgs,
  optArgs *NetgroupShowOptionalArgs, // can be nil
) (*NetgroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := netgroupShowKwParams{
    NetgroupShowArgs: reqArgs,
    NetgroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "netgroup_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res netgroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type NetgroupShowArgs struct {
  
    /*
Netgroup name

    */
    Cn string `json:"cn,omitempty"`
  }

type NetgroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type netgroupShowKwParams struct {
  *NetgroupShowArgs
  *NetgroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type netgroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *NetgroupShowResult `json:"result"`
}
type NetgroupShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Netgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *NetgroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("NetgroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("NetgroupShowResult%v", string(b))
}

/*
Modify OTP configuration options.
*/
func (c *Client) OtpconfigMod(
  reqArgs *OtpconfigModArgs,
  optArgs *OtpconfigModOptionalArgs, // can be nil
) (*OtpconfigModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otpconfigModKwParams{
    OtpconfigModArgs: reqArgs,
    OtpconfigModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otpconfig_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otpconfigModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtpconfigModArgs struct {
  }

type OtpconfigModOptionalArgs struct {
  
    /*
TOTP authentication Window
TOTP authentication time variance (seconds)
    */
    Ipatokentotpauthwindow *int `json:"ipatokentotpauthwindow,omitempty"`
  
    /*
TOTP Synchronization Window
TOTP synchronization time variance (seconds)
    */
    Ipatokentotpsyncwindow *int `json:"ipatokentotpsyncwindow,omitempty"`
  
    /*
HOTP Authentication Window
HOTP authentication skip-ahead
    */
    Ipatokenhotpauthwindow *int `json:"ipatokenhotpauthwindow,omitempty"`
  
    /*
HOTP Synchronization Window
HOTP synchronization skip-ahead
    */
    Ipatokenhotpsyncwindow *int `json:"ipatokenhotpsyncwindow,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type otpconfigModKwParams struct {
  *OtpconfigModArgs
  *OtpconfigModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otpconfigModResponse struct {
	Error  *Error      `json:"error"`
	Result *OtpconfigModResult `json:"result"`
}
type OtpconfigModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Otpconfig `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *OtpconfigModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtpconfigModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtpconfigModResult%v", string(b))
}

/*
Show the current OTP configuration.
*/
func (c *Client) OtpconfigShow(
  reqArgs *OtpconfigShowArgs,
  optArgs *OtpconfigShowOptionalArgs, // can be nil
) (*OtpconfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otpconfigShowKwParams{
    OtpconfigShowArgs: reqArgs,
    OtpconfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otpconfig_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otpconfigShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtpconfigShowArgs struct {
  }

type OtpconfigShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type otpconfigShowKwParams struct {
  *OtpconfigShowArgs
  *OtpconfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otpconfigShowResponse struct {
	Error  *Error      `json:"error"`
	Result *OtpconfigShowResult `json:"result"`
}
type OtpconfigShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Otpconfig `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *OtpconfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtpconfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtpconfigShowResult%v", string(b))
}

/*
Add a new OTP token.
*/
func (c *Client) OtptokenAdd(
  ipatokenuniqueid string, // 
  reqArgs *OtptokenAddArgs,
  optArgs *OtptokenAddOptionalArgs, // can be nil
) (*OtptokenAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenAddKwParams{
    OtptokenAddArgs: reqArgs,
    OtptokenAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_add",
    Params: []interface{}{
      []interface{}{ipatokenuniqueid, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenAddArgs struct {
  }

type OtptokenAddOptionalArgs struct {
  
    /*
Type
Type of the token
    */
    Type *string `json:"type,omitempty"`
  
    /*
Description
Token description (informational only)
    */
    Description *string `json:"description,omitempty"`
  
    /*
Owner
Assigned user of the token (default: self)
    */
    Ipatokenowner *string `json:"ipatokenowner,omitempty"`
  
    /*
Disabled
Mark the token as disabled (default: false)
    */
    Ipatokendisabled *bool `json:"ipatokendisabled,omitempty"`
  
    /*
Validity start
First date/time the token can be used
    */
    Ipatokennotbefore *time.Time `json:"ipatokennotbefore,omitempty"`
  
    /*
Validity end
Last date/time the token can be used
    */
    Ipatokennotafter *time.Time `json:"ipatokennotafter,omitempty"`
  
    /*
Vendor
Token vendor name (informational only)
    */
    Ipatokenvendor *string `json:"ipatokenvendor,omitempty"`
  
    /*
Model
Token model (informational only)
    */
    Ipatokenmodel *string `json:"ipatokenmodel,omitempty"`
  
    /*
Serial
Token serial (informational only)
    */
    Ipatokenserial *string `json:"ipatokenserial,omitempty"`
  
    /*
Key
Token secret (Base32; default: random)
    */
    Ipatokenotpkey *string `json:"ipatokenotpkey,omitempty"`
  
    /*
Algorithm
Token hash algorithm
    */
    Ipatokenotpalgorithm *string `json:"ipatokenotpalgorithm,omitempty"`
  
    /*
Digits
Number of digits each token code will have
    */
    Ipatokenotpdigits *int `json:"ipatokenotpdigits,omitempty"`
  
    /*
Clock offset
TOTP token / FreeIPA server time difference
    */
    Ipatokentotpclockoffset *int `json:"ipatokentotpclockoffset,omitempty"`
  
    /*
Clock interval
Length of TOTP token code validity
    */
    Ipatokentotptimestep *int `json:"ipatokentotptimestep,omitempty"`
  
    /*
Counter
Initial counter for the HOTP token
    */
    Ipatokenhotpcounter *int `json:"ipatokenhotpcounter,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
(deprecated)

    */
    Qrcode *bool `json:"qrcode,omitempty"`
  
    /*
Do not display QR code

    */
    NoQrcode *bool `json:"no_qrcode,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type otptokenAddKwParams struct {
  *OtptokenAddArgs
  *OtptokenAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenAddResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenAddResult `json:"result"`
}
type OtptokenAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Otptoken `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *OtptokenAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenAddResult%v", string(b))
}

/*
Add users that can manage this token.
*/
func (c *Client) OtptokenAddManagedby(
  reqArgs *OtptokenAddManagedbyArgs,
  optArgs *OtptokenAddManagedbyOptionalArgs, // can be nil
) (*OtptokenAddManagedbyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenAddManagedbyKwParams{
    OtptokenAddManagedbyArgs: reqArgs,
    OtptokenAddManagedbyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_add_managedby",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenAddManagedbyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenAddManagedbyArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid string `json:"ipatokenuniqueid,omitempty"`
  }

type OtptokenAddManagedbyOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  }

type otptokenAddManagedbyKwParams struct {
  *OtptokenAddManagedbyArgs
  *OtptokenAddManagedbyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenAddManagedbyResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenAddManagedbyResult `json:"result"`
}
type OtptokenAddManagedbyResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *OtptokenAddManagedbyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenAddManagedbyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenAddManagedbyResult%v", string(b))
}

/*
Delete an OTP token.
*/
func (c *Client) OtptokenDel(
  reqArgs *OtptokenDelArgs,
  optArgs *OtptokenDelOptionalArgs, // can be nil
) (*OtptokenDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenDelKwParams{
    OtptokenDelArgs: reqArgs,
    OtptokenDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenDelArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid []string `json:"ipatokenuniqueid,omitempty"`
  }

type OtptokenDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type otptokenDelKwParams struct {
  *OtptokenDelArgs
  *OtptokenDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenDelResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenDelResult `json:"result"`
}
type OtptokenDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *OtptokenDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenDelResult%v", string(b))
}

/*
Search for OTP token.
*/
func (c *Client) OtptokenFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *OtptokenFindArgs,
  optArgs *OtptokenFindOptionalArgs, // can be nil
) (*OtptokenFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenFindKwParams{
    OtptokenFindArgs: reqArgs,
    OtptokenFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenFindArgs struct {
  }

type OtptokenFindOptionalArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid *string `json:"ipatokenuniqueid,omitempty"`
  
    /*
Type
Type of the token
    */
    Type *string `json:"type,omitempty"`
  
    /*
Description
Token description (informational only)
    */
    Description *string `json:"description,omitempty"`
  
    /*
Owner
Assigned user of the token (default: self)
    */
    Ipatokenowner *string `json:"ipatokenowner,omitempty"`
  
    /*
Disabled
Mark the token as disabled (default: false)
    */
    Ipatokendisabled *bool `json:"ipatokendisabled,omitempty"`
  
    /*
Validity start
First date/time the token can be used
    */
    Ipatokennotbefore *time.Time `json:"ipatokennotbefore,omitempty"`
  
    /*
Validity end
Last date/time the token can be used
    */
    Ipatokennotafter *time.Time `json:"ipatokennotafter,omitempty"`
  
    /*
Vendor
Token vendor name (informational only)
    */
    Ipatokenvendor *string `json:"ipatokenvendor,omitempty"`
  
    /*
Model
Token model (informational only)
    */
    Ipatokenmodel *string `json:"ipatokenmodel,omitempty"`
  
    /*
Serial
Token serial (informational only)
    */
    Ipatokenserial *string `json:"ipatokenserial,omitempty"`
  
    /*
Algorithm
Token hash algorithm
    */
    Ipatokenotpalgorithm *string `json:"ipatokenotpalgorithm,omitempty"`
  
    /*
Digits
Number of digits each token code will have
    */
    Ipatokenotpdigits *int `json:"ipatokenotpdigits,omitempty"`
  
    /*
Clock offset
TOTP token / FreeIPA server time difference
    */
    Ipatokentotpclockoffset *int `json:"ipatokentotpclockoffset,omitempty"`
  
    /*
Clock interval
Length of TOTP token code validity
    */
    Ipatokentotptimestep *int `json:"ipatokentotptimestep,omitempty"`
  
    /*
Counter
Initial counter for the HOTP token
    */
    Ipatokenhotpcounter *int `json:"ipatokenhotpcounter,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("id")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type otptokenFindKwParams struct {
  *OtptokenFindArgs
  *OtptokenFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenFindResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenFindResult `json:"result"`
}
type OtptokenFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Otptoken `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *OtptokenFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenFindResult%v", string(b))
}

/*
Modify a OTP token.
*/
func (c *Client) OtptokenMod(
  reqArgs *OtptokenModArgs,
  optArgs *OtptokenModOptionalArgs, // can be nil
) (*OtptokenModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenModKwParams{
    OtptokenModArgs: reqArgs,
    OtptokenModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenModArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid string `json:"ipatokenuniqueid,omitempty"`
  }

type OtptokenModOptionalArgs struct {
  
    /*
Description
Token description (informational only)
    */
    Description *string `json:"description,omitempty"`
  
    /*
Owner
Assigned user of the token (default: self)
    */
    Ipatokenowner *string `json:"ipatokenowner,omitempty"`
  
    /*
Disabled
Mark the token as disabled (default: false)
    */
    Ipatokendisabled *bool `json:"ipatokendisabled,omitempty"`
  
    /*
Validity start
First date/time the token can be used
    */
    Ipatokennotbefore *time.Time `json:"ipatokennotbefore,omitempty"`
  
    /*
Validity end
Last date/time the token can be used
    */
    Ipatokennotafter *time.Time `json:"ipatokennotafter,omitempty"`
  
    /*
Vendor
Token vendor name (informational only)
    */
    Ipatokenvendor *string `json:"ipatokenvendor,omitempty"`
  
    /*
Model
Token model (informational only)
    */
    Ipatokenmodel *string `json:"ipatokenmodel,omitempty"`
  
    /*
Serial
Token serial (informational only)
    */
    Ipatokenserial *string `json:"ipatokenserial,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the OTP token object
    */
    Rename *string `json:"rename,omitempty"`
  }

type otptokenModKwParams struct {
  *OtptokenModArgs
  *OtptokenModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenModResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenModResult `json:"result"`
}
type OtptokenModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Otptoken `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *OtptokenModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenModResult%v", string(b))
}

/*
Remove users that can manage this token.
*/
func (c *Client) OtptokenRemoveManagedby(
  reqArgs *OtptokenRemoveManagedbyArgs,
  optArgs *OtptokenRemoveManagedbyOptionalArgs, // can be nil
) (*OtptokenRemoveManagedbyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenRemoveManagedbyKwParams{
    OtptokenRemoveManagedbyArgs: reqArgs,
    OtptokenRemoveManagedbyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_remove_managedby",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenRemoveManagedbyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenRemoveManagedbyArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid string `json:"ipatokenuniqueid,omitempty"`
  }

type OtptokenRemoveManagedbyOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  }

type otptokenRemoveManagedbyKwParams struct {
  *OtptokenRemoveManagedbyArgs
  *OtptokenRemoveManagedbyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenRemoveManagedbyResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenRemoveManagedbyResult `json:"result"`
}
type OtptokenRemoveManagedbyResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *OtptokenRemoveManagedbyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenRemoveManagedbyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenRemoveManagedbyResult%v", string(b))
}

/*
Display information about an OTP token.
*/
func (c *Client) OtptokenShow(
  reqArgs *OtptokenShowArgs,
  optArgs *OtptokenShowOptionalArgs, // can be nil
) (*OtptokenShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := otptokenShowKwParams{
    OtptokenShowArgs: reqArgs,
    OtptokenShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "otptoken_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res otptokenShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OtptokenShowArgs struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid string `json:"ipatokenuniqueid,omitempty"`
  }

type OtptokenShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type otptokenShowKwParams struct {
  *OtptokenShowArgs
  *OtptokenShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type otptokenShowResponse struct {
	Error  *Error      `json:"error"`
	Result *OtptokenShowResult `json:"result"`
}
type OtptokenShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Otptoken `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *OtptokenShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OtptokenShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OtptokenShowResult%v", string(b))
}

/*
Search for command outputs.
*/
func (c *Client) OutputFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *OutputFindArgs,
  optArgs *OutputFindOptionalArgs, // can be nil
) (*OutputFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := outputFindKwParams{
    OutputFindArgs: reqArgs,
    OutputFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "output_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res outputFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OutputFindArgs struct {
  
    /*
Full name

    */
    CommandfullName string `json:"commandfull_name,omitempty"`
  }

type OutputFindOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type outputFindKwParams struct {
  *OutputFindArgs
  *OutputFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type outputFindResponse struct {
	Error  *Error      `json:"error"`
	Result *OutputFindResult `json:"result"`
}
type OutputFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Output `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *OutputFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OutputFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OutputFindResult%v", string(b))
}

/*
Display information about a command output.
*/
func (c *Client) OutputShow(
  reqArgs *OutputShowArgs,
  optArgs *OutputShowOptionalArgs, // can be nil
) (*OutputShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := outputShowKwParams{
    OutputShowArgs: reqArgs,
    OutputShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "output_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res outputShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type OutputShowArgs struct {
  
    /*
Full name

    */
    CommandfullName string `json:"commandfull_name,omitempty"`
  
    /*
Name

    */
    Name string `json:"name,omitempty"`
  }

type OutputShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type outputShowKwParams struct {
  *OutputShowArgs
  *OutputShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type outputShowResponse struct {
	Error  *Error      `json:"error"`
	Result *OutputShowResult `json:"result"`
}
type OutputShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Output `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *OutputShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("OutputShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("OutputShowResult%v", string(b))
}

/*
Search command parameters.
*/
func (c *Client) ParamFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ParamFindArgs,
  optArgs *ParamFindOptionalArgs, // can be nil
) (*ParamFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := paramFindKwParams{
    ParamFindArgs: reqArgs,
    ParamFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "param_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res paramFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ParamFindArgs struct {
  
    /*
Full name

    */
    MetaobjectfullName string `json:"metaobjectfull_name,omitempty"`
  }

type ParamFindOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type paramFindKwParams struct {
  *ParamFindArgs
  *ParamFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type paramFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ParamFindResult `json:"result"`
}
type ParamFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Param `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *ParamFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ParamFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ParamFindResult%v", string(b))
}

/*
Display information about a command parameter.
*/
func (c *Client) ParamShow(
  reqArgs *ParamShowArgs,
  optArgs *ParamShowOptionalArgs, // can be nil
) (*ParamShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := paramShowKwParams{
    ParamShowArgs: reqArgs,
    ParamShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "param_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res paramShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ParamShowArgs struct {
  
    /*
Full name

    */
    MetaobjectfullName string `json:"metaobjectfull_name,omitempty"`
  
    /*
Name

    */
    Name string `json:"name,omitempty"`
  }

type ParamShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type paramShowKwParams struct {
  *ParamShowArgs
  *ParamShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type paramShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ParamShowResult `json:"result"`
}
type ParamShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Param `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ParamShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ParamShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ParamShowResult%v", string(b))
}

/*
Set a user's password.
*/
func (c *Client) Passwd(
  reqArgs *PasswdArgs,
  optArgs *PasswdOptionalArgs, // can be nil
) (*PasswdResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := passwdKwParams{
    PasswdArgs: reqArgs,
    PasswdOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "passwd",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res passwdResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PasswdArgs struct {
  
    /*
User name

    */
    Principal string `json:"principal,omitempty"`
  
    /*
New Password

    */
    Password string `json:"password,omitempty"`
  }

type PasswdOptionalArgs struct {
  
    /*
Current Password

    */
    CurrentPassword *string `json:"current_password,omitempty"`
  
    /*
OTP
One Time Password
    */
    Otp *string `json:"otp,omitempty"`
  }

type passwdKwParams struct {
  *PasswdArgs
  *PasswdOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type passwdResponse struct {
	Error  *Error      `json:"error"`
	Result *PasswdResult `json:"result"`
}
type PasswdResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *PasswdResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PasswdResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PasswdResult%v", string(b))
}

/*
Add a new permission.
*/
func (c *Client) PermissionAdd(
  reqArgs *PermissionAddArgs,
  optArgs *PermissionAddOptionalArgs, // can be nil
) (*PermissionAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionAddKwParams{
    PermissionAddArgs: reqArgs,
    PermissionAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionAddArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  }

type PermissionAddOptionalArgs struct {
  
    /*
Granted rights
Rights to grant (read, search, compare, write, add, delete, all)
    */
    Ipapermright *[]string `json:"ipapermright,omitempty"`
  
    /*
Effective attributes
All attributes to which the permission applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Bind rule type
Bind rule type
    */
    Ipapermbindruletype *string `json:"ipapermbindruletype,omitempty"`
  
    /*
Subtree
Subtree to apply permissions to
    */
    Ipapermlocation *string `json:"ipapermlocation,omitempty"`
  
    /*
Extra target filter
Extra target filter
    */
    Extratargetfilter *[]string `json:"extratargetfilter,omitempty"`
  
    /*
Raw target filter
All target filters, including those implied by type and memberof
    */
    Ipapermtargetfilter *[]string `json:"ipapermtargetfilter,omitempty"`
  
    /*
Target DN
Optional DN to apply the permission to (must be in the subtree, but may not yet exist)
    */
    Ipapermtarget *string `json:"ipapermtarget,omitempty"`
  
    /*
Target DN subtree
Optional DN subtree where an entry can be moved to (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetto *string `json:"ipapermtargetto,omitempty"`
  
    /*
Origin DN subtree
Optional DN subtree from where an entry can be moved (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetfrom *string `json:"ipapermtargetfrom,omitempty"`
  
    /*
Member of group
Target members of a group (sets memberOf targetfilter)
    */
    Memberof *[]string `json:"memberof,omitempty"`
  
    /*
Target group
User group to apply permissions to (sets target)
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Type
Type of IPA object (sets subtree and objectClass targetfilter)
    */
    Type *string `json:"type,omitempty"`
  
    /*

Deprecated; use extratargetfilter
    */
    Filter *[]string `json:"filter,omitempty"`
  
    /*

Deprecated; use ipapermlocation
    */
    Subtree *[]string `json:"subtree,omitempty"`
  
    /*

Deprecated; use ipapermright
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type permissionAddKwParams struct {
  *PermissionAddArgs
  *PermissionAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionAddResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionAddResult `json:"result"`
}
type PermissionAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Permission `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *PermissionAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionAddResult%v", string(b))
}

/*
Add members to a permission.
*/
func (c *Client) PermissionAddMember(
  reqArgs *PermissionAddMemberArgs,
  optArgs *PermissionAddMemberOptionalArgs, // can be nil
) (*PermissionAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionAddMemberKwParams{
    PermissionAddMemberArgs: reqArgs,
    PermissionAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_add_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionAddMemberArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  }

type PermissionAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member privilege
privileges to add
    */
    Privilege *[]string `json:"privilege,omitempty"`
  }

type permissionAddMemberKwParams struct {
  *PermissionAddMemberArgs
  *PermissionAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionAddMemberResult `json:"result"`
}
type PermissionAddMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *PermissionAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionAddMemberResult%v", string(b))
}

/*
Add a system permission without an ACI (internal command)
*/
func (c *Client) PermissionAddNoaci(
  reqArgs *PermissionAddNoaciArgs,
  optArgs *PermissionAddNoaciOptionalArgs, // can be nil
) (*PermissionAddNoaciResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionAddNoaciKwParams{
    PermissionAddNoaciArgs: reqArgs,
    PermissionAddNoaciOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_add_noaci",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionAddNoaciResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionAddNoaciArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Permission flags

    */
    Ipapermissiontype []string `json:"ipapermissiontype,omitempty"`
  }

type PermissionAddNoaciOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type permissionAddNoaciKwParams struct {
  *PermissionAddNoaciArgs
  *PermissionAddNoaciOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionAddNoaciResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionAddNoaciResult `json:"result"`
}
type PermissionAddNoaciResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *PermissionAddNoaciResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionAddNoaciResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionAddNoaciResult%v", string(b))
}

/*
Delete a permission.
*/
func (c *Client) PermissionDel(
  reqArgs *PermissionDelArgs,
  optArgs *PermissionDelOptionalArgs, // can be nil
) (*PermissionDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionDelKwParams{
    PermissionDelArgs: reqArgs,
    PermissionDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionDelArgs struct {
  
    /*
Permission name

    */
    Cn []string `json:"cn,omitempty"`
  }

type PermissionDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Force
force delete of SYSTEM permissions
    */
    Force *bool `json:"force,omitempty"`
  }

type permissionDelKwParams struct {
  *PermissionDelArgs
  *PermissionDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionDelResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionDelResult `json:"result"`
}
type PermissionDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *PermissionDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionDelResult%v", string(b))
}

/*
Search for permissions.
*/
func (c *Client) PermissionFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *PermissionFindArgs,
  optArgs *PermissionFindOptionalArgs, // can be nil
) (*PermissionFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionFindKwParams{
    PermissionFindArgs: reqArgs,
    PermissionFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionFindArgs struct {
  }

type PermissionFindOptionalArgs struct {
  
    /*
Permission name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Granted rights
Rights to grant (read, search, compare, write, add, delete, all)
    */
    Ipapermright *[]string `json:"ipapermright,omitempty"`
  
    /*
Effective attributes
All attributes to which the permission applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Included attributes
User-specified attributes to which the permission applies
    */
    Ipapermincludedattr *[]string `json:"ipapermincludedattr,omitempty"`
  
    /*
Excluded attributes
User-specified attributes to which the permission explicitly does not apply
    */
    Ipapermexcludedattr *[]string `json:"ipapermexcludedattr,omitempty"`
  
    /*
Default attributes
Attributes to which the permission applies by default
    */
    Ipapermdefaultattr *[]string `json:"ipapermdefaultattr,omitempty"`
  
    /*
Bind rule type
Bind rule type
    */
    Ipapermbindruletype *string `json:"ipapermbindruletype,omitempty"`
  
    /*
Subtree
Subtree to apply permissions to
    */
    Ipapermlocation *string `json:"ipapermlocation,omitempty"`
  
    /*
Extra target filter
Extra target filter
    */
    Extratargetfilter *[]string `json:"extratargetfilter,omitempty"`
  
    /*
Raw target filter
All target filters, including those implied by type and memberof
    */
    Ipapermtargetfilter *[]string `json:"ipapermtargetfilter,omitempty"`
  
    /*
Target DN
Optional DN to apply the permission to (must be in the subtree, but may not yet exist)
    */
    Ipapermtarget *string `json:"ipapermtarget,omitempty"`
  
    /*
Target DN subtree
Optional DN subtree where an entry can be moved to (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetto *string `json:"ipapermtargetto,omitempty"`
  
    /*
Origin DN subtree
Optional DN subtree from where an entry can be moved (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetfrom *string `json:"ipapermtargetfrom,omitempty"`
  
    /*
Member of group
Target members of a group (sets memberOf targetfilter)
    */
    Memberof *[]string `json:"memberof,omitempty"`
  
    /*
Target group
User group to apply permissions to (sets target)
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Type
Type of IPA object (sets subtree and objectClass targetfilter)
    */
    Type *string `json:"type,omitempty"`
  
    /*

Deprecated; use extratargetfilter
    */
    Filter *[]string `json:"filter,omitempty"`
  
    /*

Deprecated; use ipapermlocation
    */
    Subtree *[]string `json:"subtree,omitempty"`
  
    /*

Deprecated; use ipapermright
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type permissionFindKwParams struct {
  *PermissionFindArgs
  *PermissionFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionFindResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionFindResult `json:"result"`
}
type PermissionFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Permission `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *PermissionFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionFindResult%v", string(b))
}

/*
Modify a permission.
*/
func (c *Client) PermissionMod(
  reqArgs *PermissionModArgs,
  optArgs *PermissionModOptionalArgs, // can be nil
) (*PermissionModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionModKwParams{
    PermissionModArgs: reqArgs,
    PermissionModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionModArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  }

type PermissionModOptionalArgs struct {
  
    /*
Granted rights
Rights to grant (read, search, compare, write, add, delete, all)
    */
    Ipapermright *[]string `json:"ipapermright,omitempty"`
  
    /*
Effective attributes
All attributes to which the permission applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Included attributes
User-specified attributes to which the permission applies
    */
    Ipapermincludedattr *[]string `json:"ipapermincludedattr,omitempty"`
  
    /*
Excluded attributes
User-specified attributes to which the permission explicitly does not apply
    */
    Ipapermexcludedattr *[]string `json:"ipapermexcludedattr,omitempty"`
  
    /*
Bind rule type
Bind rule type
    */
    Ipapermbindruletype *string `json:"ipapermbindruletype,omitempty"`
  
    /*
Subtree
Subtree to apply permissions to
    */
    Ipapermlocation *string `json:"ipapermlocation,omitempty"`
  
    /*
Extra target filter
Extra target filter
    */
    Extratargetfilter *[]string `json:"extratargetfilter,omitempty"`
  
    /*
Raw target filter
All target filters, including those implied by type and memberof
    */
    Ipapermtargetfilter *[]string `json:"ipapermtargetfilter,omitempty"`
  
    /*
Target DN
Optional DN to apply the permission to (must be in the subtree, but may not yet exist)
    */
    Ipapermtarget *string `json:"ipapermtarget,omitempty"`
  
    /*
Target DN subtree
Optional DN subtree where an entry can be moved to (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetto *string `json:"ipapermtargetto,omitempty"`
  
    /*
Origin DN subtree
Optional DN subtree from where an entry can be moved (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetfrom *string `json:"ipapermtargetfrom,omitempty"`
  
    /*
Member of group
Target members of a group (sets memberOf targetfilter)
    */
    Memberof *[]string `json:"memberof,omitempty"`
  
    /*
Target group
User group to apply permissions to (sets target)
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Type
Type of IPA object (sets subtree and objectClass targetfilter)
    */
    Type *string `json:"type,omitempty"`
  
    /*

Deprecated; use extratargetfilter
    */
    Filter *[]string `json:"filter,omitempty"`
  
    /*

Deprecated; use ipapermlocation
    */
    Subtree *[]string `json:"subtree,omitempty"`
  
    /*

Deprecated; use ipapermright
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the permission object
    */
    Rename *string `json:"rename,omitempty"`
  }

type permissionModKwParams struct {
  *PermissionModArgs
  *PermissionModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionModResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionModResult `json:"result"`
}
type PermissionModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Permission `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *PermissionModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionModResult%v", string(b))
}

/*
Remove members from a permission.
*/
func (c *Client) PermissionRemoveMember(
  reqArgs *PermissionRemoveMemberArgs,
  optArgs *PermissionRemoveMemberOptionalArgs, // can be nil
) (*PermissionRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionRemoveMemberKwParams{
    PermissionRemoveMemberArgs: reqArgs,
    PermissionRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_remove_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionRemoveMemberArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  }

type PermissionRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member privilege
privileges to remove
    */
    Privilege *[]string `json:"privilege,omitempty"`
  }

type permissionRemoveMemberKwParams struct {
  *PermissionRemoveMemberArgs
  *PermissionRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionRemoveMemberResult `json:"result"`
}
type PermissionRemoveMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *PermissionRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionRemoveMemberResult%v", string(b))
}

/*
Display information about a permission.
*/
func (c *Client) PermissionShow(
  reqArgs *PermissionShowArgs,
  optArgs *PermissionShowOptionalArgs, // can be nil
) (*PermissionShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := permissionShowKwParams{
    PermissionShowArgs: reqArgs,
    PermissionShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "permission_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res permissionShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PermissionShowArgs struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  }

type PermissionShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type permissionShowKwParams struct {
  *PermissionShowArgs
  *PermissionShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type permissionShowResponse struct {
	Error  *Error      `json:"error"`
	Result *PermissionShowResult `json:"result"`
}
type PermissionShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Permission `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *PermissionShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PermissionShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PermissionShowResult%v", string(b))
}

/*
Ping a remote server.
*/
func (c *Client) Ping(
  reqArgs *PingArgs,
  optArgs *PingOptionalArgs, // can be nil
) (*PingResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pingKwParams{
    PingArgs: reqArgs,
    PingOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "ping",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pingResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PingArgs struct {
  }

type PingOptionalArgs struct {
  }

type pingKwParams struct {
  *PingArgs
  *PingOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pingResponse struct {
	Error  *Error      `json:"error"`
	Result *PingResult `json:"result"`
}
type PingResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  }

func (t *PingResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PingResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PingResult%v", string(b))
}

/*
Report PKINIT status on the IPA masters
*/
func (c *Client) PkinitStatus(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *PkinitStatusArgs,
  optArgs *PkinitStatusOptionalArgs, // can be nil
) (*PkinitStatusResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pkinitStatusKwParams{
    PkinitStatusArgs: reqArgs,
    PkinitStatusOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pkinit_status",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pkinitStatusResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PkinitStatusArgs struct {
  }

type PkinitStatusOptionalArgs struct {
  
    /*
Server name
IPA server hostname
    */
    ServerServer *string `json:"server_server,omitempty"`
  
    /*
PKINIT status
Whether PKINIT is enabled or disabled
    */
    Status *string `json:"status,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type pkinitStatusKwParams struct {
  *PkinitStatusArgs
  *PkinitStatusOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pkinitStatusResponse struct {
	Error  *Error      `json:"error"`
	Result *PkinitStatusResult `json:"result"`
}
type PkinitStatusResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []interface{} `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *PkinitStatusResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PkinitStatusResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PkinitStatusResult%v", string(b))
}

/*
Show all loaded plugins.
*/
func (c *Client) Plugins(
  reqArgs *PluginsArgs,
  optArgs *PluginsOptionalArgs, // can be nil
) (*PluginsResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pluginsKwParams{
    PluginsArgs: reqArgs,
    PluginsOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "plugins",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pluginsResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PluginsArgs struct {
  }

type PluginsOptionalArgs struct {
  
    /*

Forward to server instead of running locally
    */
    Server *bool `json:"server,omitempty"`
  
    /*

retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  }

type pluginsKwParams struct {
  *PluginsArgs
  *PluginsOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pluginsResponse struct {
	Error  *Error      `json:"error"`
	Result *PluginsResult `json:"result"`
}
type PluginsResult struct {
  
  
  
    /*
Dictionary mapping plugin names to bases
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Number of plugins loaded
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  }

func (t *PluginsResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PluginsResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PluginsResult%v", string(b))
}

/*
Add a new privilege.
*/
func (c *Client) PrivilegeAdd(
  reqArgs *PrivilegeAddArgs,
  optArgs *PrivilegeAddOptionalArgs, // can be nil
) (*PrivilegeAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeAddKwParams{
    PrivilegeAddArgs: reqArgs,
    PrivilegeAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeAddArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeAddOptionalArgs struct {
  
    /*
Description
Privilege description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type privilegeAddKwParams struct {
  *PrivilegeAddArgs
  *PrivilegeAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeAddResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeAddResult `json:"result"`
}
type PrivilegeAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Privilege `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *PrivilegeAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeAddResult%v", string(b))
}

/*
Add members to a privilege.
*/
func (c *Client) PrivilegeAddMember(
  reqArgs *PrivilegeAddMemberArgs,
  optArgs *PrivilegeAddMemberOptionalArgs, // can be nil
) (*PrivilegeAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeAddMemberKwParams{
    PrivilegeAddMemberArgs: reqArgs,
    PrivilegeAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_add_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeAddMemberArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member role
roles to add
    */
    Role *[]string `json:"role,omitempty"`
  }

type privilegeAddMemberKwParams struct {
  *PrivilegeAddMemberArgs
  *PrivilegeAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeAddMemberResult `json:"result"`
}
type PrivilegeAddMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *PrivilegeAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeAddMemberResult%v", string(b))
}

/*
Add permissions to a privilege.
*/
func (c *Client) PrivilegeAddPermission(
  reqArgs *PrivilegeAddPermissionArgs,
  optArgs *PrivilegeAddPermissionOptionalArgs, // can be nil
) (*PrivilegeAddPermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeAddPermissionKwParams{
    PrivilegeAddPermissionArgs: reqArgs,
    PrivilegeAddPermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_add_permission",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeAddPermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeAddPermissionArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeAddPermissionOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
permission
permissions
    */
    Permission *[]string `json:"permission,omitempty"`
  }

type privilegeAddPermissionKwParams struct {
  *PrivilegeAddPermissionArgs
  *PrivilegeAddPermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeAddPermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeAddPermissionResult `json:"result"`
}
type PrivilegeAddPermissionResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of permissions added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *PrivilegeAddPermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeAddPermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeAddPermissionResult%v", string(b))
}

/*
Delete a privilege.
*/
func (c *Client) PrivilegeDel(
  reqArgs *PrivilegeDelArgs,
  optArgs *PrivilegeDelOptionalArgs, // can be nil
) (*PrivilegeDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeDelKwParams{
    PrivilegeDelArgs: reqArgs,
    PrivilegeDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeDelArgs struct {
  
    /*
Privilege name

    */
    Cn []string `json:"cn,omitempty"`
  }

type PrivilegeDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type privilegeDelKwParams struct {
  *PrivilegeDelArgs
  *PrivilegeDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeDelResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeDelResult `json:"result"`
}
type PrivilegeDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *PrivilegeDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeDelResult%v", string(b))
}

/*
Search for privileges.
*/
func (c *Client) PrivilegeFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *PrivilegeFindArgs,
  optArgs *PrivilegeFindOptionalArgs, // can be nil
) (*PrivilegeFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeFindKwParams{
    PrivilegeFindArgs: reqArgs,
    PrivilegeFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeFindArgs struct {
  }

type PrivilegeFindOptionalArgs struct {
  
    /*
Privilege name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Privilege description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type privilegeFindKwParams struct {
  *PrivilegeFindArgs
  *PrivilegeFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeFindResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeFindResult `json:"result"`
}
type PrivilegeFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Privilege `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *PrivilegeFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeFindResult%v", string(b))
}

/*
Modify a privilege.
*/
func (c *Client) PrivilegeMod(
  reqArgs *PrivilegeModArgs,
  optArgs *PrivilegeModOptionalArgs, // can be nil
) (*PrivilegeModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeModKwParams{
    PrivilegeModArgs: reqArgs,
    PrivilegeModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeModArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeModOptionalArgs struct {
  
    /*
Description
Privilege description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the privilege object
    */
    Rename *string `json:"rename,omitempty"`
  }

type privilegeModKwParams struct {
  *PrivilegeModArgs
  *PrivilegeModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeModResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeModResult `json:"result"`
}
type PrivilegeModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Privilege `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *PrivilegeModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeModResult%v", string(b))
}

/*
Remove members from a privilege
*/
func (c *Client) PrivilegeRemoveMember(
  reqArgs *PrivilegeRemoveMemberArgs,
  optArgs *PrivilegeRemoveMemberOptionalArgs, // can be nil
) (*PrivilegeRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeRemoveMemberKwParams{
    PrivilegeRemoveMemberArgs: reqArgs,
    PrivilegeRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_remove_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeRemoveMemberArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member role
roles to remove
    */
    Role *[]string `json:"role,omitempty"`
  }

type privilegeRemoveMemberKwParams struct {
  *PrivilegeRemoveMemberArgs
  *PrivilegeRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeRemoveMemberResult `json:"result"`
}
type PrivilegeRemoveMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *PrivilegeRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeRemoveMemberResult%v", string(b))
}

/*
Remove permissions from a privilege.
*/
func (c *Client) PrivilegeRemovePermission(
  reqArgs *PrivilegeRemovePermissionArgs,
  optArgs *PrivilegeRemovePermissionOptionalArgs, // can be nil
) (*PrivilegeRemovePermissionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeRemovePermissionKwParams{
    PrivilegeRemovePermissionArgs: reqArgs,
    PrivilegeRemovePermissionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_remove_permission",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeRemovePermissionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeRemovePermissionArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeRemovePermissionOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
permission
permissions
    */
    Permission *[]string `json:"permission,omitempty"`
  }

type privilegeRemovePermissionKwParams struct {
  *PrivilegeRemovePermissionArgs
  *PrivilegeRemovePermissionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeRemovePermissionResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeRemovePermissionResult `json:"result"`
}
type PrivilegeRemovePermissionResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of permissions removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *PrivilegeRemovePermissionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeRemovePermissionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeRemovePermissionResult%v", string(b))
}

/*
Display information about a privilege.
*/
func (c *Client) PrivilegeShow(
  reqArgs *PrivilegeShowArgs,
  optArgs *PrivilegeShowOptionalArgs, // can be nil
) (*PrivilegeShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := privilegeShowKwParams{
    PrivilegeShowArgs: reqArgs,
    PrivilegeShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "privilege_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res privilegeShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PrivilegeShowArgs struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  }

type PrivilegeShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type privilegeShowKwParams struct {
  *PrivilegeShowArgs
  *PrivilegeShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type privilegeShowResponse struct {
	Error  *Error      `json:"error"`
	Result *PrivilegeShowResult `json:"result"`
}
type PrivilegeShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Privilege `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *PrivilegeShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PrivilegeShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PrivilegeShowResult%v", string(b))
}

/*
Add a new group password policy.
*/
func (c *Client) PwpolicyAdd(
  reqArgs *PwpolicyAddArgs,
  optArgs *PwpolicyAddOptionalArgs, // can be nil
) (*PwpolicyAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pwpolicyAddKwParams{
    PwpolicyAddArgs: reqArgs,
    PwpolicyAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pwpolicy_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pwpolicyAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PwpolicyAddArgs struct {
  
    /*
Group
Manage password policy for specific group
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Priority
Priority of the policy (higher number means lower priority
    */
    Cospriority int `json:"cospriority,omitempty"`
  }

type PwpolicyAddOptionalArgs struct {
  
    /*
Max lifetime (days)
Maximum password lifetime (in days)
    */
    Krbmaxpwdlife *int `json:"krbmaxpwdlife,omitempty"`
  
    /*
Min lifetime (hours)
Minimum password lifetime (in hours)
    */
    Krbminpwdlife *int `json:"krbminpwdlife,omitempty"`
  
    /*
History size
Password history size
    */
    Krbpwdhistorylength *int `json:"krbpwdhistorylength,omitempty"`
  
    /*
Character classes
Minimum number of character classes
    */
    Krbpwdmindiffchars *int `json:"krbpwdmindiffchars,omitempty"`
  
    /*
Min length
Minimum length of password
    */
    Krbpwdminlength *int `json:"krbpwdminlength,omitempty"`
  
    /*
Max failures
Consecutive failures before lockout
    */
    Krbpwdmaxfailure *int `json:"krbpwdmaxfailure,omitempty"`
  
    /*
Failure reset interval
Period after which failure count will be reset (seconds)
    */
    Krbpwdfailurecountinterval *int `json:"krbpwdfailurecountinterval,omitempty"`
  
    /*
Lockout duration
Period for which lockout is enforced (seconds)
    */
    Krbpwdlockoutduration *int `json:"krbpwdlockoutduration,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type pwpolicyAddKwParams struct {
  *PwpolicyAddArgs
  *PwpolicyAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pwpolicyAddResponse struct {
	Error  *Error      `json:"error"`
	Result *PwpolicyAddResult `json:"result"`
}
type PwpolicyAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Pwpolicy `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *PwpolicyAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PwpolicyAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PwpolicyAddResult%v", string(b))
}

/*
Delete a group password policy.
*/
func (c *Client) PwpolicyDel(
  reqArgs *PwpolicyDelArgs,
  optArgs *PwpolicyDelOptionalArgs, // can be nil
) (*PwpolicyDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pwpolicyDelKwParams{
    PwpolicyDelArgs: reqArgs,
    PwpolicyDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pwpolicy_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pwpolicyDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PwpolicyDelArgs struct {
  
    /*
Group
Manage password policy for specific group
    */
    Cn []string `json:"cn,omitempty"`
  }

type PwpolicyDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type pwpolicyDelKwParams struct {
  *PwpolicyDelArgs
  *PwpolicyDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pwpolicyDelResponse struct {
	Error  *Error      `json:"error"`
	Result *PwpolicyDelResult `json:"result"`
}
type PwpolicyDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *PwpolicyDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PwpolicyDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PwpolicyDelResult%v", string(b))
}

/*
Search for group password policies.
*/
func (c *Client) PwpolicyFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *PwpolicyFindArgs,
  optArgs *PwpolicyFindOptionalArgs, // can be nil
) (*PwpolicyFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pwpolicyFindKwParams{
    PwpolicyFindArgs: reqArgs,
    PwpolicyFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pwpolicy_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pwpolicyFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PwpolicyFindArgs struct {
  }

type PwpolicyFindOptionalArgs struct {
  
    /*
Group
Manage password policy for specific group
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Max lifetime (days)
Maximum password lifetime (in days)
    */
    Krbmaxpwdlife *int `json:"krbmaxpwdlife,omitempty"`
  
    /*
Min lifetime (hours)
Minimum password lifetime (in hours)
    */
    Krbminpwdlife *int `json:"krbminpwdlife,omitempty"`
  
    /*
History size
Password history size
    */
    Krbpwdhistorylength *int `json:"krbpwdhistorylength,omitempty"`
  
    /*
Character classes
Minimum number of character classes
    */
    Krbpwdmindiffchars *int `json:"krbpwdmindiffchars,omitempty"`
  
    /*
Min length
Minimum length of password
    */
    Krbpwdminlength *int `json:"krbpwdminlength,omitempty"`
  
    /*
Priority
Priority of the policy (higher number means lower priority
    */
    Cospriority *int `json:"cospriority,omitempty"`
  
    /*
Max failures
Consecutive failures before lockout
    */
    Krbpwdmaxfailure *int `json:"krbpwdmaxfailure,omitempty"`
  
    /*
Failure reset interval
Period after which failure count will be reset (seconds)
    */
    Krbpwdfailurecountinterval *int `json:"krbpwdfailurecountinterval,omitempty"`
  
    /*
Lockout duration
Period for which lockout is enforced (seconds)
    */
    Krbpwdlockoutduration *int `json:"krbpwdlockoutduration,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("group")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type pwpolicyFindKwParams struct {
  *PwpolicyFindArgs
  *PwpolicyFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pwpolicyFindResponse struct {
	Error  *Error      `json:"error"`
	Result *PwpolicyFindResult `json:"result"`
}
type PwpolicyFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Pwpolicy `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *PwpolicyFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PwpolicyFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PwpolicyFindResult%v", string(b))
}

/*
Modify a group password policy.
*/
func (c *Client) PwpolicyMod(
  cn string, // Manage password policy for specific group
  reqArgs *PwpolicyModArgs,
  optArgs *PwpolicyModOptionalArgs, // can be nil
) (*PwpolicyModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pwpolicyModKwParams{
    PwpolicyModArgs: reqArgs,
    PwpolicyModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pwpolicy_mod",
    Params: []interface{}{
      []interface{}{cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pwpolicyModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PwpolicyModArgs struct {
  }

type PwpolicyModOptionalArgs struct {
  
    /*
Max lifetime (days)
Maximum password lifetime (in days)
    */
    Krbmaxpwdlife *int `json:"krbmaxpwdlife,omitempty"`
  
    /*
Min lifetime (hours)
Minimum password lifetime (in hours)
    */
    Krbminpwdlife *int `json:"krbminpwdlife,omitempty"`
  
    /*
History size
Password history size
    */
    Krbpwdhistorylength *int `json:"krbpwdhistorylength,omitempty"`
  
    /*
Character classes
Minimum number of character classes
    */
    Krbpwdmindiffchars *int `json:"krbpwdmindiffchars,omitempty"`
  
    /*
Min length
Minimum length of password
    */
    Krbpwdminlength *int `json:"krbpwdminlength,omitempty"`
  
    /*
Priority
Priority of the policy (higher number means lower priority
    */
    Cospriority *int `json:"cospriority,omitempty"`
  
    /*
Max failures
Consecutive failures before lockout
    */
    Krbpwdmaxfailure *int `json:"krbpwdmaxfailure,omitempty"`
  
    /*
Failure reset interval
Period after which failure count will be reset (seconds)
    */
    Krbpwdfailurecountinterval *int `json:"krbpwdfailurecountinterval,omitempty"`
  
    /*
Lockout duration
Period for which lockout is enforced (seconds)
    */
    Krbpwdlockoutduration *int `json:"krbpwdlockoutduration,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type pwpolicyModKwParams struct {
  *PwpolicyModArgs
  *PwpolicyModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pwpolicyModResponse struct {
	Error  *Error      `json:"error"`
	Result *PwpolicyModResult `json:"result"`
}
type PwpolicyModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Pwpolicy `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *PwpolicyModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PwpolicyModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PwpolicyModResult%v", string(b))
}

/*
Display information about password policy.
*/
func (c *Client) PwpolicyShow(
  cn string, // Manage password policy for specific group
  reqArgs *PwpolicyShowArgs,
  optArgs *PwpolicyShowOptionalArgs, // can be nil
) (*PwpolicyShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := pwpolicyShowKwParams{
    PwpolicyShowArgs: reqArgs,
    PwpolicyShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "pwpolicy_show",
    Params: []interface{}{
      []interface{}{cn, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res pwpolicyShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type PwpolicyShowArgs struct {
  }

type PwpolicyShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
User
Display effective policy for a specific user
    */
    User *string `json:"user,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type pwpolicyShowKwParams struct {
  *PwpolicyShowArgs
  *PwpolicyShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type pwpolicyShowResponse struct {
	Error  *Error      `json:"error"`
	Result *PwpolicyShowResult `json:"result"`
}
type PwpolicyShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Pwpolicy `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *PwpolicyShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("PwpolicyShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("PwpolicyShowResult%v", string(b))
}

/*
Add a new RADIUS proxy server.
*/
func (c *Client) RadiusproxyAdd(
  reqArgs *RadiusproxyAddArgs,
  optArgs *RadiusproxyAddOptionalArgs, // can be nil
) (*RadiusproxyAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := radiusproxyAddKwParams{
    RadiusproxyAddArgs: reqArgs,
    RadiusproxyAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "radiusproxy_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res radiusproxyAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RadiusproxyAddArgs struct {
  
    /*
RADIUS proxy server name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Server
The hostname or IP (with or without port)
    */
    Ipatokenradiusserver string `json:"ipatokenradiusserver,omitempty"`
  
    /*
Secret
The secret used to encrypt data
    */
    Ipatokenradiussecret string `json:"ipatokenradiussecret,omitempty"`
  }

type RadiusproxyAddOptionalArgs struct {
  
    /*
Description
A description of this RADIUS proxy server
    */
    Description *string `json:"description,omitempty"`
  
    /*
Timeout
The total timeout across all retries (in seconds)
    */
    Ipatokenradiustimeout *int `json:"ipatokenradiustimeout,omitempty"`
  
    /*
Retries
The number of times to retry authentication
    */
    Ipatokenradiusretries *int `json:"ipatokenradiusretries,omitempty"`
  
    /*
User attribute
The username attribute on the user object
    */
    Ipatokenusermapattribute *string `json:"ipatokenusermapattribute,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type radiusproxyAddKwParams struct {
  *RadiusproxyAddArgs
  *RadiusproxyAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type radiusproxyAddResponse struct {
	Error  *Error      `json:"error"`
	Result *RadiusproxyAddResult `json:"result"`
}
type RadiusproxyAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Radiusproxy `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *RadiusproxyAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RadiusproxyAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RadiusproxyAddResult%v", string(b))
}

/*
Delete a RADIUS proxy server.
*/
func (c *Client) RadiusproxyDel(
  reqArgs *RadiusproxyDelArgs,
  optArgs *RadiusproxyDelOptionalArgs, // can be nil
) (*RadiusproxyDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := radiusproxyDelKwParams{
    RadiusproxyDelArgs: reqArgs,
    RadiusproxyDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "radiusproxy_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res radiusproxyDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RadiusproxyDelArgs struct {
  
    /*
RADIUS proxy server name

    */
    Cn []string `json:"cn,omitempty"`
  }

type RadiusproxyDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type radiusproxyDelKwParams struct {
  *RadiusproxyDelArgs
  *RadiusproxyDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type radiusproxyDelResponse struct {
	Error  *Error      `json:"error"`
	Result *RadiusproxyDelResult `json:"result"`
}
type RadiusproxyDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *RadiusproxyDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RadiusproxyDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RadiusproxyDelResult%v", string(b))
}

/*
Search for RADIUS proxy servers.
*/
func (c *Client) RadiusproxyFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *RadiusproxyFindArgs,
  optArgs *RadiusproxyFindOptionalArgs, // can be nil
) (*RadiusproxyFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := radiusproxyFindKwParams{
    RadiusproxyFindArgs: reqArgs,
    RadiusproxyFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "radiusproxy_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res radiusproxyFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RadiusproxyFindArgs struct {
  }

type RadiusproxyFindOptionalArgs struct {
  
    /*
RADIUS proxy server name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
A description of this RADIUS proxy server
    */
    Description *string `json:"description,omitempty"`
  
    /*
Server
The hostname or IP (with or without port)
    */
    Ipatokenradiusserver *string `json:"ipatokenradiusserver,omitempty"`
  
    /*
Secret
The secret used to encrypt data
    */
    Ipatokenradiussecret *string `json:"ipatokenradiussecret,omitempty"`
  
    /*
Timeout
The total timeout across all retries (in seconds)
    */
    Ipatokenradiustimeout *int `json:"ipatokenradiustimeout,omitempty"`
  
    /*
Retries
The number of times to retry authentication
    */
    Ipatokenradiusretries *int `json:"ipatokenradiusretries,omitempty"`
  
    /*
User attribute
The username attribute on the user object
    */
    Ipatokenusermapattribute *string `json:"ipatokenusermapattribute,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type radiusproxyFindKwParams struct {
  *RadiusproxyFindArgs
  *RadiusproxyFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type radiusproxyFindResponse struct {
	Error  *Error      `json:"error"`
	Result *RadiusproxyFindResult `json:"result"`
}
type RadiusproxyFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Radiusproxy `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *RadiusproxyFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RadiusproxyFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RadiusproxyFindResult%v", string(b))
}

/*
Modify a RADIUS proxy server.
*/
func (c *Client) RadiusproxyMod(
  reqArgs *RadiusproxyModArgs,
  optArgs *RadiusproxyModOptionalArgs, // can be nil
) (*RadiusproxyModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := radiusproxyModKwParams{
    RadiusproxyModArgs: reqArgs,
    RadiusproxyModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "radiusproxy_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res radiusproxyModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RadiusproxyModArgs struct {
  
    /*
RADIUS proxy server name

    */
    Cn string `json:"cn,omitempty"`
  }

type RadiusproxyModOptionalArgs struct {
  
    /*
Description
A description of this RADIUS proxy server
    */
    Description *string `json:"description,omitempty"`
  
    /*
Server
The hostname or IP (with or without port)
    */
    Ipatokenradiusserver *string `json:"ipatokenradiusserver,omitempty"`
  
    /*
Secret
The secret used to encrypt data
    */
    Ipatokenradiussecret *string `json:"ipatokenradiussecret,omitempty"`
  
    /*
Timeout
The total timeout across all retries (in seconds)
    */
    Ipatokenradiustimeout *int `json:"ipatokenradiustimeout,omitempty"`
  
    /*
Retries
The number of times to retry authentication
    */
    Ipatokenradiusretries *int `json:"ipatokenradiusretries,omitempty"`
  
    /*
User attribute
The username attribute on the user object
    */
    Ipatokenusermapattribute *string `json:"ipatokenusermapattribute,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Rename
Rename the RADIUS proxy server object
    */
    Rename *string `json:"rename,omitempty"`
  }

type radiusproxyModKwParams struct {
  *RadiusproxyModArgs
  *RadiusproxyModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type radiusproxyModResponse struct {
	Error  *Error      `json:"error"`
	Result *RadiusproxyModResult `json:"result"`
}
type RadiusproxyModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Radiusproxy `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *RadiusproxyModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RadiusproxyModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RadiusproxyModResult%v", string(b))
}

/*
Display information about a RADIUS proxy server.
*/
func (c *Client) RadiusproxyShow(
  reqArgs *RadiusproxyShowArgs,
  optArgs *RadiusproxyShowOptionalArgs, // can be nil
) (*RadiusproxyShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := radiusproxyShowKwParams{
    RadiusproxyShowArgs: reqArgs,
    RadiusproxyShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "radiusproxy_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res radiusproxyShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RadiusproxyShowArgs struct {
  
    /*
RADIUS proxy server name

    */
    Cn string `json:"cn,omitempty"`
  }

type RadiusproxyShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type radiusproxyShowKwParams struct {
  *RadiusproxyShowArgs
  *RadiusproxyShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type radiusproxyShowResponse struct {
	Error  *Error      `json:"error"`
	Result *RadiusproxyShowResult `json:"result"`
}
type RadiusproxyShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Radiusproxy `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *RadiusproxyShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RadiusproxyShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RadiusproxyShowResult%v", string(b))
}

/*
Modify realm domains.
*/
func (c *Client) RealmdomainsMod(
  reqArgs *RealmdomainsModArgs,
  optArgs *RealmdomainsModOptionalArgs, // can be nil
) (*RealmdomainsModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := realmdomainsModKwParams{
    RealmdomainsModArgs: reqArgs,
    RealmdomainsModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "realmdomains_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res realmdomainsModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RealmdomainsModArgs struct {
  }

type RealmdomainsModOptionalArgs struct {
  
    /*
Domain

    */
    Associateddomain *[]string `json:"associateddomain,omitempty"`
  
    /*
Add domain

    */
    AddDomain *string `json:"add_domain,omitempty"`
  
    /*
Delete domain

    */
    DelDomain *string `json:"del_domain,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Force
Force adding domain even if not in DNS
    */
    Force *bool `json:"force,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type realmdomainsModKwParams struct {
  *RealmdomainsModArgs
  *RealmdomainsModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type realmdomainsModResponse struct {
	Error  *Error      `json:"error"`
	Result *RealmdomainsModResult `json:"result"`
}
type RealmdomainsModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Realmdomains `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *RealmdomainsModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RealmdomainsModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RealmdomainsModResult%v", string(b))
}

/*
Display the list of realm domains.
*/
func (c *Client) RealmdomainsShow(
  reqArgs *RealmdomainsShowArgs,
  optArgs *RealmdomainsShowOptionalArgs, // can be nil
) (*RealmdomainsShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := realmdomainsShowKwParams{
    RealmdomainsShowArgs: reqArgs,
    RealmdomainsShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "realmdomains_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res realmdomainsShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RealmdomainsShowArgs struct {
  }

type RealmdomainsShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type realmdomainsShowKwParams struct {
  *RealmdomainsShowArgs
  *RealmdomainsShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type realmdomainsShowResponse struct {
	Error  *Error      `json:"error"`
	Result *RealmdomainsShowResult `json:"result"`
}
type RealmdomainsShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Realmdomains `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *RealmdomainsShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RealmdomainsShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RealmdomainsShowResult%v", string(b))
}

/*
Add a new role.
*/
func (c *Client) RoleAdd(
  reqArgs *RoleAddArgs,
  optArgs *RoleAddOptionalArgs, // can be nil
) (*RoleAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleAddKwParams{
    RoleAddArgs: reqArgs,
    RoleAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleAddArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleAddOptionalArgs struct {
  
    /*
Description
A description of this role-group
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type roleAddKwParams struct {
  *RoleAddArgs
  *RoleAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleAddResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleAddResult `json:"result"`
}
type RoleAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Role `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *RoleAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleAddResult%v", string(b))
}

/*
Add members to a role.
*/
func (c *Client) RoleAddMember(
  reqArgs *RoleAddMemberArgs,
  optArgs *RoleAddMemberOptionalArgs, // can be nil
) (*RoleAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleAddMemberKwParams{
    RoleAddMemberArgs: reqArgs,
    RoleAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_add_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleAddMemberArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
member service
services to add
    */
    Service *[]string `json:"service,omitempty"`
  }

type roleAddMemberKwParams struct {
  *RoleAddMemberArgs
  *RoleAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleAddMemberResult `json:"result"`
}
type RoleAddMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *RoleAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleAddMemberResult%v", string(b))
}

/*
Add privileges to a role.
*/
func (c *Client) RoleAddPrivilege(
  reqArgs *RoleAddPrivilegeArgs,
  optArgs *RoleAddPrivilegeOptionalArgs, // can be nil
) (*RoleAddPrivilegeResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleAddPrivilegeKwParams{
    RoleAddPrivilegeArgs: reqArgs,
    RoleAddPrivilegeOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_add_privilege",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleAddPrivilegeResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleAddPrivilegeArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleAddPrivilegeOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
privilege
privileges
    */
    Privilege *[]string `json:"privilege,omitempty"`
  }

type roleAddPrivilegeKwParams struct {
  *RoleAddPrivilegeArgs
  *RoleAddPrivilegeOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleAddPrivilegeResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleAddPrivilegeResult `json:"result"`
}
type RoleAddPrivilegeResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of privileges added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *RoleAddPrivilegeResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleAddPrivilegeResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleAddPrivilegeResult%v", string(b))
}

/*
Delete a role.
*/
func (c *Client) RoleDel(
  reqArgs *RoleDelArgs,
  optArgs *RoleDelOptionalArgs, // can be nil
) (*RoleDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleDelKwParams{
    RoleDelArgs: reqArgs,
    RoleDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleDelArgs struct {
  
    /*
Role name

    */
    Cn []string `json:"cn,omitempty"`
  }

type RoleDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type roleDelKwParams struct {
  *RoleDelArgs
  *RoleDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleDelResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleDelResult `json:"result"`
}
type RoleDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *RoleDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleDelResult%v", string(b))
}

/*
Search for roles.
*/
func (c *Client) RoleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *RoleFindArgs,
  optArgs *RoleFindOptionalArgs, // can be nil
) (*RoleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleFindKwParams{
    RoleFindArgs: reqArgs,
    RoleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleFindArgs struct {
  }

type RoleFindOptionalArgs struct {
  
    /*
Role name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
A description of this role-group
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type roleFindKwParams struct {
  *RoleFindArgs
  *RoleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleFindResult `json:"result"`
}
type RoleFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Role `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *RoleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleFindResult%v", string(b))
}

/*
Modify a role.
*/
func (c *Client) RoleMod(
  reqArgs *RoleModArgs,
  optArgs *RoleModOptionalArgs, // can be nil
) (*RoleModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleModKwParams{
    RoleModArgs: reqArgs,
    RoleModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleModArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleModOptionalArgs struct {
  
    /*
Description
A description of this role-group
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the role object
    */
    Rename *string `json:"rename,omitempty"`
  }

type roleModKwParams struct {
  *RoleModArgs
  *RoleModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleModResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleModResult `json:"result"`
}
type RoleModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Role `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *RoleModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleModResult%v", string(b))
}

/*
Remove members from a role.
*/
func (c *Client) RoleRemoveMember(
  reqArgs *RoleRemoveMemberArgs,
  optArgs *RoleRemoveMemberOptionalArgs, // can be nil
) (*RoleRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleRemoveMemberKwParams{
    RoleRemoveMemberArgs: reqArgs,
    RoleRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_remove_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleRemoveMemberArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
member service
services to remove
    */
    Service *[]string `json:"service,omitempty"`
  }

type roleRemoveMemberKwParams struct {
  *RoleRemoveMemberArgs
  *RoleRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleRemoveMemberResult `json:"result"`
}
type RoleRemoveMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *RoleRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleRemoveMemberResult%v", string(b))
}

/*
Remove privileges from a role.
*/
func (c *Client) RoleRemovePrivilege(
  reqArgs *RoleRemovePrivilegeArgs,
  optArgs *RoleRemovePrivilegeOptionalArgs, // can be nil
) (*RoleRemovePrivilegeResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleRemovePrivilegeKwParams{
    RoleRemovePrivilegeArgs: reqArgs,
    RoleRemovePrivilegeOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_remove_privilege",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleRemovePrivilegeResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleRemovePrivilegeArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleRemovePrivilegeOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
privilege
privileges
    */
    Privilege *[]string `json:"privilege,omitempty"`
  }

type roleRemovePrivilegeKwParams struct {
  *RoleRemovePrivilegeArgs
  *RoleRemovePrivilegeOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleRemovePrivilegeResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleRemovePrivilegeResult `json:"result"`
}
type RoleRemovePrivilegeResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of privileges removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *RoleRemovePrivilegeResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleRemovePrivilegeResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleRemovePrivilegeResult%v", string(b))
}

/*
Display information about a role.
*/
func (c *Client) RoleShow(
  reqArgs *RoleShowArgs,
  optArgs *RoleShowOptionalArgs, // can be nil
) (*RoleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := roleShowKwParams{
    RoleShowArgs: reqArgs,
    RoleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "role_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res roleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type RoleShowArgs struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  }

type RoleShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type roleShowKwParams struct {
  *RoleShowArgs
  *RoleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type roleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *RoleShowResult `json:"result"`
}
type RoleShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Role `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *RoleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("RoleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("RoleShowResult%v", string(b))
}

/*

*/
func (c *Client) Schema(
  reqArgs *SchemaArgs,
  optArgs *SchemaOptionalArgs, // can be nil
) (*SchemaResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := schemaKwParams{
    SchemaArgs: reqArgs,
    SchemaOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "schema",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res schemaResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SchemaArgs struct {
  }

type SchemaOptionalArgs struct {
  
    /*
Fingerprint of schema cached by client

    */
    KnownFingerprints *[]string `json:"known_fingerprints,omitempty"`
  }

type schemaKwParams struct {
  *SchemaArgs
  *SchemaOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type schemaResponse struct {
	Error  *Error      `json:"error"`
	Result *SchemaResult `json:"result"`
}
type SchemaResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *SchemaResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SchemaResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SchemaResult%v", string(b))
}

/*
Add a new self-service permission.
*/
func (c *Client) SelfserviceAdd(
  reqArgs *SelfserviceAddArgs,
  optArgs *SelfserviceAddOptionalArgs, // can be nil
) (*SelfserviceAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selfserviceAddKwParams{
    SelfserviceAddArgs: reqArgs,
    SelfserviceAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selfservice_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selfserviceAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelfserviceAddArgs struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
Attributes
Attributes to which the permission applies.
    */
    Attrs []string `json:"attrs,omitempty"`
  }

type SelfserviceAddOptionalArgs struct {
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type selfserviceAddKwParams struct {
  *SelfserviceAddArgs
  *SelfserviceAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selfserviceAddResponse struct {
	Error  *Error      `json:"error"`
	Result *SelfserviceAddResult `json:"result"`
}
type SelfserviceAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Selfservice `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SelfserviceAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelfserviceAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelfserviceAddResult%v", string(b))
}

/*
Delete a self-service permission.
*/
func (c *Client) SelfserviceDel(
  reqArgs *SelfserviceDelArgs,
  optArgs *SelfserviceDelOptionalArgs, // can be nil
) (*SelfserviceDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selfserviceDelKwParams{
    SelfserviceDelArgs: reqArgs,
    SelfserviceDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selfservice_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selfserviceDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelfserviceDelArgs struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type SelfserviceDelOptionalArgs struct {
  }

type selfserviceDelKwParams struct {
  *SelfserviceDelArgs
  *SelfserviceDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selfserviceDelResponse struct {
	Error  *Error      `json:"error"`
	Result *SelfserviceDelResult `json:"result"`
}
type SelfserviceDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SelfserviceDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelfserviceDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelfserviceDelResult%v", string(b))
}

/*
Search for a self-service permission.
*/
func (c *Client) SelfserviceFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *SelfserviceFindArgs,
  optArgs *SelfserviceFindOptionalArgs, // can be nil
) (*SelfserviceFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selfserviceFindKwParams{
    SelfserviceFindArgs: reqArgs,
    SelfserviceFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selfservice_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selfserviceFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelfserviceFindArgs struct {
  }

type SelfserviceFindOptionalArgs struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname *string `json:"aciname,omitempty"`
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the permission applies.
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type selfserviceFindKwParams struct {
  *SelfserviceFindArgs
  *SelfserviceFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selfserviceFindResponse struct {
	Error  *Error      `json:"error"`
	Result *SelfserviceFindResult `json:"result"`
}
type SelfserviceFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Selfservice `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *SelfserviceFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelfserviceFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelfserviceFindResult%v", string(b))
}

/*
Modify a self-service permission.
*/
func (c *Client) SelfserviceMod(
  reqArgs *SelfserviceModArgs,
  optArgs *SelfserviceModOptionalArgs, // can be nil
) (*SelfserviceModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selfserviceModKwParams{
    SelfserviceModArgs: reqArgs,
    SelfserviceModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selfservice_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selfserviceModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelfserviceModArgs struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type SelfserviceModOptionalArgs struct {
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the permission applies.
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type selfserviceModKwParams struct {
  *SelfserviceModArgs
  *SelfserviceModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selfserviceModResponse struct {
	Error  *Error      `json:"error"`
	Result *SelfserviceModResult `json:"result"`
}
type SelfserviceModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Selfservice `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SelfserviceModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelfserviceModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelfserviceModResult%v", string(b))
}

/*
Display information about a self-service permission.
*/
func (c *Client) SelfserviceShow(
  reqArgs *SelfserviceShowArgs,
  optArgs *SelfserviceShowOptionalArgs, // can be nil
) (*SelfserviceShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selfserviceShowKwParams{
    SelfserviceShowArgs: reqArgs,
    SelfserviceShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selfservice_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selfserviceShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelfserviceShowArgs struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname string `json:"aciname,omitempty"`
  }

type SelfserviceShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type selfserviceShowKwParams struct {
  *SelfserviceShowArgs
  *SelfserviceShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selfserviceShowResponse struct {
	Error  *Error      `json:"error"`
	Result *SelfserviceShowResult `json:"result"`
}
type SelfserviceShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Selfservice `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SelfserviceShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelfserviceShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelfserviceShowResult%v", string(b))
}

/*
Create a new SELinux User Map.
*/
func (c *Client) SelinuxusermapAdd(
  reqArgs *SelinuxusermapAddArgs,
  optArgs *SelinuxusermapAddOptionalArgs, // can be nil
) (*SelinuxusermapAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapAddKwParams{
    SelinuxusermapAddArgs: reqArgs,
    SelinuxusermapAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapAddArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
SELinux User

    */
    Ipaselinuxuser string `json:"ipaselinuxuser,omitempty"`
  }

type SelinuxusermapAddOptionalArgs struct {
  
    /*
HBAC Rule
HBAC Rule that defines the users, groups and hostgroups
    */
    Seealso *string `json:"seealso,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type selinuxusermapAddKwParams struct {
  *SelinuxusermapAddArgs
  *SelinuxusermapAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapAddResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapAddResult `json:"result"`
}
type SelinuxusermapAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Selinuxusermap `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SelinuxusermapAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapAddResult%v", string(b))
}

/*
Add target hosts and hostgroups to an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapAddHost(
  reqArgs *SelinuxusermapAddHostArgs,
  optArgs *SelinuxusermapAddHostOptionalArgs, // can be nil
) (*SelinuxusermapAddHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapAddHostKwParams{
    SelinuxusermapAddHostArgs: reqArgs,
    SelinuxusermapAddHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_add_host",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapAddHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapAddHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapAddHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type selinuxusermapAddHostKwParams struct {
  *SelinuxusermapAddHostArgs
  *SelinuxusermapAddHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapAddHostResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapAddHostResult `json:"result"`
}
type SelinuxusermapAddHostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SelinuxusermapAddHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapAddHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapAddHostResult%v", string(b))
}

/*
Add users and groups to an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapAddUser(
  reqArgs *SelinuxusermapAddUserArgs,
  optArgs *SelinuxusermapAddUserOptionalArgs, // can be nil
) (*SelinuxusermapAddUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapAddUserKwParams{
    SelinuxusermapAddUserArgs: reqArgs,
    SelinuxusermapAddUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_add_user",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapAddUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapAddUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapAddUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type selinuxusermapAddUserKwParams struct {
  *SelinuxusermapAddUserArgs
  *SelinuxusermapAddUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapAddUserResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapAddUserResult `json:"result"`
}
type SelinuxusermapAddUserResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SelinuxusermapAddUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapAddUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapAddUserResult%v", string(b))
}

/*
Delete a SELinux User Map.
*/
func (c *Client) SelinuxusermapDel(
  reqArgs *SelinuxusermapDelArgs,
  optArgs *SelinuxusermapDelOptionalArgs, // can be nil
) (*SelinuxusermapDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapDelKwParams{
    SelinuxusermapDelArgs: reqArgs,
    SelinuxusermapDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapDelArgs struct {
  
    /*
Rule name

    */
    Cn []string `json:"cn,omitempty"`
  }

type SelinuxusermapDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type selinuxusermapDelKwParams struct {
  *SelinuxusermapDelArgs
  *SelinuxusermapDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapDelResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapDelResult `json:"result"`
}
type SelinuxusermapDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *SelinuxusermapDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapDelResult%v", string(b))
}

/*
Disable an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapDisable(
  reqArgs *SelinuxusermapDisableArgs,
  optArgs *SelinuxusermapDisableOptionalArgs, // can be nil
) (*SelinuxusermapDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapDisableKwParams{
    SelinuxusermapDisableArgs: reqArgs,
    SelinuxusermapDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapDisableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapDisableOptionalArgs struct {
  }

type selinuxusermapDisableKwParams struct {
  *SelinuxusermapDisableArgs
  *SelinuxusermapDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapDisableResult `json:"result"`
}
type SelinuxusermapDisableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SelinuxusermapDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapDisableResult%v", string(b))
}

/*
Enable an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapEnable(
  reqArgs *SelinuxusermapEnableArgs,
  optArgs *SelinuxusermapEnableOptionalArgs, // can be nil
) (*SelinuxusermapEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapEnableKwParams{
    SelinuxusermapEnableArgs: reqArgs,
    SelinuxusermapEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_enable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapEnableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapEnableOptionalArgs struct {
  }

type selinuxusermapEnableKwParams struct {
  *SelinuxusermapEnableArgs
  *SelinuxusermapEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapEnableResult `json:"result"`
}
type SelinuxusermapEnableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SelinuxusermapEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapEnableResult%v", string(b))
}

/*
Search for SELinux User Maps.
*/
func (c *Client) SelinuxusermapFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *SelinuxusermapFindArgs,
  optArgs *SelinuxusermapFindOptionalArgs, // can be nil
) (*SelinuxusermapFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapFindKwParams{
    SelinuxusermapFindArgs: reqArgs,
    SelinuxusermapFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapFindArgs struct {
  }

type SelinuxusermapFindOptionalArgs struct {
  
    /*
Rule name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
SELinux User

    */
    Ipaselinuxuser *string `json:"ipaselinuxuser,omitempty"`
  
    /*
HBAC Rule
HBAC Rule that defines the users, groups and hostgroups
    */
    Seealso *string `json:"seealso,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type selinuxusermapFindKwParams struct {
  *SelinuxusermapFindArgs
  *SelinuxusermapFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapFindResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapFindResult `json:"result"`
}
type SelinuxusermapFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Selinuxusermap `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *SelinuxusermapFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapFindResult%v", string(b))
}

/*
Modify a SELinux User Map.
*/
func (c *Client) SelinuxusermapMod(
  reqArgs *SelinuxusermapModArgs,
  optArgs *SelinuxusermapModOptionalArgs, // can be nil
) (*SelinuxusermapModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapModKwParams{
    SelinuxusermapModArgs: reqArgs,
    SelinuxusermapModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapModArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapModOptionalArgs struct {
  
    /*
SELinux User

    */
    Ipaselinuxuser *string `json:"ipaselinuxuser,omitempty"`
  
    /*
HBAC Rule
HBAC Rule that defines the users, groups and hostgroups
    */
    Seealso *string `json:"seealso,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type selinuxusermapModKwParams struct {
  *SelinuxusermapModArgs
  *SelinuxusermapModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapModResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapModResult `json:"result"`
}
type SelinuxusermapModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Selinuxusermap `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SelinuxusermapModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapModResult%v", string(b))
}

/*
Remove target hosts and hostgroups from an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapRemoveHost(
  reqArgs *SelinuxusermapRemoveHostArgs,
  optArgs *SelinuxusermapRemoveHostOptionalArgs, // can be nil
) (*SelinuxusermapRemoveHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapRemoveHostKwParams{
    SelinuxusermapRemoveHostArgs: reqArgs,
    SelinuxusermapRemoveHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_remove_host",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapRemoveHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapRemoveHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapRemoveHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type selinuxusermapRemoveHostKwParams struct {
  *SelinuxusermapRemoveHostArgs
  *SelinuxusermapRemoveHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapRemoveHostResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapRemoveHostResult `json:"result"`
}
type SelinuxusermapRemoveHostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SelinuxusermapRemoveHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapRemoveHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapRemoveHostResult%v", string(b))
}

/*
Remove users and groups from an SELinux User Map rule.
*/
func (c *Client) SelinuxusermapRemoveUser(
  reqArgs *SelinuxusermapRemoveUserArgs,
  optArgs *SelinuxusermapRemoveUserOptionalArgs, // can be nil
) (*SelinuxusermapRemoveUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapRemoveUserKwParams{
    SelinuxusermapRemoveUserArgs: reqArgs,
    SelinuxusermapRemoveUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_remove_user",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapRemoveUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapRemoveUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapRemoveUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type selinuxusermapRemoveUserKwParams struct {
  *SelinuxusermapRemoveUserArgs
  *SelinuxusermapRemoveUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapRemoveUserResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapRemoveUserResult `json:"result"`
}
type SelinuxusermapRemoveUserResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SelinuxusermapRemoveUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapRemoveUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapRemoveUserResult%v", string(b))
}

/*
Display the properties of a SELinux User Map rule.
*/
func (c *Client) SelinuxusermapShow(
  reqArgs *SelinuxusermapShowArgs,
  optArgs *SelinuxusermapShowOptionalArgs, // can be nil
) (*SelinuxusermapShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := selinuxusermapShowKwParams{
    SelinuxusermapShowArgs: reqArgs,
    SelinuxusermapShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "selinuxusermap_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res selinuxusermapShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SelinuxusermapShowArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SelinuxusermapShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type selinuxusermapShowKwParams struct {
  *SelinuxusermapShowArgs
  *SelinuxusermapShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type selinuxusermapShowResponse struct {
	Error  *Error      `json:"error"`
	Result *SelinuxusermapShowResult `json:"result"`
}
type SelinuxusermapShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Selinuxusermap `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SelinuxusermapShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SelinuxusermapShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SelinuxusermapShowResult%v", string(b))
}

/*
Check connection to remote IPA server.
*/
func (c *Client) ServerConncheck(
  reqArgs *ServerConncheckArgs,
  optArgs *ServerConncheckOptionalArgs, // can be nil
) (*ServerConncheckResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverConncheckKwParams{
    ServerConncheckArgs: reqArgs,
    ServerConncheckOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_conncheck",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverConncheckResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerConncheckArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Remote server name
Remote IPA server hostname
    */
    RemoteCn string `json:"remote_cn,omitempty"`
  }

type ServerConncheckOptionalArgs struct {
  }

type serverConncheckKwParams struct {
  *ServerConncheckArgs
  *ServerConncheckOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverConncheckResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerConncheckResult `json:"result"`
}
type ServerConncheckResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServerConncheckResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerConncheckResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerConncheckResult%v", string(b))
}

/*
Delete IPA server.
*/
func (c *Client) ServerDel(
  reqArgs *ServerDelArgs,
  optArgs *ServerDelOptionalArgs, // can be nil
) (*ServerDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverDelKwParams{
    ServerDelArgs: reqArgs,
    ServerDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerDelArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn []string `json:"cn,omitempty"`
  }

type ServerDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*
Ignore topology errors
Ignore topology connectivity problems after removal
    */
    IgnoreTopologyDisconnect *bool `json:"ignore_topology_disconnect,omitempty"`
  
    /*
Ignore check for last remaining CA or DNS server
Skip a check whether the last CA master or DNS server is removed
    */
    IgnoreLastOfRole *bool `json:"ignore_last_of_role,omitempty"`
  
    /*
Force server removal
Force server removal even if it does not exist
    */
    Force *bool `json:"force,omitempty"`
  }

type serverDelKwParams struct {
  *ServerDelArgs
  *ServerDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverDelResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerDelResult `json:"result"`
}
type ServerDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *ServerDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerDelResult%v", string(b))
}

/*
Search for IPA servers.
*/
func (c *Client) ServerFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ServerFindArgs,
  optArgs *ServerFindOptionalArgs, // can be nil
) (*ServerFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverFindKwParams{
    ServerFindArgs: reqArgs,
    ServerFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerFindArgs struct {
  }

type ServerFindOptionalArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Min domain level
Minimum domain level
    */
    Ipamindomainlevel *int `json:"ipamindomainlevel,omitempty"`
  
    /*
Max domain level
Maximum domain level
    */
    Ipamaxdomainlevel *int `json:"ipamaxdomainlevel,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
suffix
Search for servers with these managed suffixes.
    */
    Topologysuffix *[]string `json:"topologysuffix,omitempty"`
  
    /*
suffix
Search for servers without these managed suffixes.
    */
    NoTopologysuffix *[]string `json:"no_topologysuffix,omitempty"`
  
    /*
location
Search for servers with these ipa locations.
    */
    InLocation *[]interface{} `json:"in_location,omitempty"`
  
    /*
location
Search for servers without these ipa locations.
    */
    NotInLocation *[]interface{} `json:"not_in_location,omitempty"`
  
    /*
role
Search for servers with these enabled roles.
    */
    Servrole *[]string `json:"servrole,omitempty"`
  }

type serverFindKwParams struct {
  *ServerFindArgs
  *ServerFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerFindResult `json:"result"`
}
type ServerFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Server `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *ServerFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerFindResult%v", string(b))
}

/*
Modify information about an IPA server.
*/
func (c *Client) ServerMod(
  reqArgs *ServerModArgs,
  optArgs *ServerModOptionalArgs, // can be nil
) (*ServerModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverModKwParams{
    ServerModArgs: reqArgs,
    ServerModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerModArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn string `json:"cn,omitempty"`
  }

type ServerModOptionalArgs struct {
  
    /*
Location
Server location
    */
    IpalocationLocation *interface{} `json:"ipalocation_location,omitempty"`
  
    /*
Service weight
Weight for server services
    */
    Ipaserviceweight *int `json:"ipaserviceweight,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serverModKwParams struct {
  *ServerModArgs
  *ServerModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverModResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerModResult `json:"result"`
}
type ServerModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Server `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServerModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerModResult%v", string(b))
}

/*
Find a server role on a server(s)
*/
func (c *Client) ServerRoleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ServerRoleFindArgs,
  optArgs *ServerRoleFindOptionalArgs, // can be nil
) (*ServerRoleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverRoleFindKwParams{
    ServerRoleFindArgs: reqArgs,
    ServerRoleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_role_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverRoleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerRoleFindArgs struct {
  }

type ServerRoleFindOptionalArgs struct {
  
    /*
Server name
IPA server hostname
    */
    ServerServer *string `json:"server_server,omitempty"`
  
    /*
Role name
IPA server role name
    */
    RoleServrole *string `json:"role_servrole,omitempty"`
  
    /*
Role status
Status of the role
    */
    Status *string `json:"status,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Include IPA master entries
    */
    IncludeMaster *bool `json:"include_master,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type serverRoleFindKwParams struct {
  *ServerRoleFindArgs
  *ServerRoleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverRoleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerRoleFindResult `json:"result"`
}
type ServerRoleFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []ServerRole `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *ServerRoleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerRoleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerRoleFindResult%v", string(b))
}

/*
Show role status on a server
*/
func (c *Client) ServerRoleShow(
  reqArgs *ServerRoleShowArgs,
  optArgs *ServerRoleShowOptionalArgs, // can be nil
) (*ServerRoleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverRoleShowKwParams{
    ServerRoleShowArgs: reqArgs,
    ServerRoleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_role_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverRoleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerRoleShowArgs struct {
  
    /*
Server name
IPA server hostname
    */
    ServerServer string `json:"server_server,omitempty"`
  
    /*
Role name
IPA server role name
    */
    RoleServrole string `json:"role_servrole,omitempty"`
  }

type ServerRoleShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type serverRoleShowKwParams struct {
  *ServerRoleShowArgs
  *ServerRoleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverRoleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerRoleShowResult `json:"result"`
}
type ServerRoleShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result ServerRole `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *ServerRoleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerRoleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerRoleShowResult%v", string(b))
}

/*
Show IPA server.
*/
func (c *Client) ServerShow(
  reqArgs *ServerShowArgs,
  optArgs *ServerShowOptionalArgs, // can be nil
) (*ServerShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverShowKwParams{
    ServerShowArgs: reqArgs,
    ServerShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerShowArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn string `json:"cn,omitempty"`
  }

type ServerShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serverShowKwParams struct {
  *ServerShowArgs
  *ServerShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerShowResult `json:"result"`
}
type ServerShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Server `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServerShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerShowResult%v", string(b))
}

/*
Set enabled/hidden state of a server.
*/
func (c *Client) ServerState(
  reqArgs *ServerStateArgs,
  optArgs *ServerStateOptionalArgs, // can be nil
) (*ServerStateResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serverStateKwParams{
    ServerStateArgs: reqArgs,
    ServerStateOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "server_state",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serverStateResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServerStateArgs struct {
  
    /*
Server name
IPA server hostname
    */
    Cn string `json:"cn,omitempty"`
  
    /*
State
Server state
    */
    State string `json:"state,omitempty"`
  }

type ServerStateOptionalArgs struct {
  }

type serverStateKwParams struct {
  *ServerStateArgs
  *ServerStateOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serverStateResponse struct {
	Error  *Error      `json:"error"`
	Result *ServerStateResult `json:"result"`
}
type ServerStateResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServerStateResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerStateResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerStateResult%v", string(b))
}

/*
Add a new IPA service.
*/
func (c *Client) ServiceAdd(
  reqArgs *ServiceAddArgs,
  optArgs *ServiceAddOptionalArgs, // can be nil
) (*ServiceAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAddKwParams{
    ServiceAddArgs: reqArgs,
    ServiceAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAddArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceAddOptionalArgs struct {
  
    /*
Certificate
Base-64 encoded service certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
PAC type
Override default list of supported PAC types. Use 'NONE' to disable PAC support for this service, e.g. this might be necessary for NFS services.
    */
    Ipakrbauthzdata *[]string `json:"ipakrbauthzdata,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *bool `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *bool `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *bool `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Force
force principal name even if not in DNS
    */
    Force *bool `json:"force,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceAddKwParams struct {
  *ServiceAddArgs
  *ServiceAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAddResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAddResult `json:"result"`
}
type ServiceAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Service `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServiceAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAddResult%v", string(b))
}

/*
Add new certificates to a service
*/
func (c *Client) ServiceAddCert(
  reqArgs *ServiceAddCertArgs,
  optArgs *ServiceAddCertOptionalArgs, // can be nil
) (*ServiceAddCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAddCertKwParams{
    ServiceAddCertArgs: reqArgs,
    ServiceAddCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_add_cert",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAddCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAddCertArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  
    /*
Certificate
Base-64 encoded service certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type ServiceAddCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceAddCertKwParams struct {
  *ServiceAddCertArgs
  *ServiceAddCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAddCertResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAddCertResult `json:"result"`
}
type ServiceAddCertResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServiceAddCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAddCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAddCertResult%v", string(b))
}

/*
Add hosts that can manage this service.
*/
func (c *Client) ServiceAddHost(
  reqArgs *ServiceAddHostArgs,
  optArgs *ServiceAddHostOptionalArgs, // can be nil
) (*ServiceAddHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAddHostKwParams{
    ServiceAddHostArgs: reqArgs,
    ServiceAddHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_add_host",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAddHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAddHostArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceAddHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  }

type serviceAddHostKwParams struct {
  *ServiceAddHostArgs
  *ServiceAddHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAddHostResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAddHostResult `json:"result"`
}
type ServiceAddHostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServiceAddHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAddHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAddHostResult%v", string(b))
}

/*
Add new principal alias to a service
*/
func (c *Client) ServiceAddPrincipal(
  reqArgs *ServiceAddPrincipalArgs,
  optArgs *ServiceAddPrincipalOptionalArgs, // can be nil
) (*ServiceAddPrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAddPrincipalKwParams{
    ServiceAddPrincipalArgs: reqArgs,
    ServiceAddPrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_add_principal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAddPrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAddPrincipalArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias
Service principal alias
    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type ServiceAddPrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceAddPrincipalKwParams struct {
  *ServiceAddPrincipalArgs
  *ServiceAddPrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAddPrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAddPrincipalResult `json:"result"`
}
type ServiceAddPrincipalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServiceAddPrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAddPrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAddPrincipalResult%v", string(b))
}

/*
Allow users, groups, hosts or host groups to create a keytab of this service.
*/
func (c *Client) ServiceAllowCreateKeytab(
  reqArgs *ServiceAllowCreateKeytabArgs,
  optArgs *ServiceAllowCreateKeytabOptionalArgs, // can be nil
) (*ServiceAllowCreateKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAllowCreateKeytabKwParams{
    ServiceAllowCreateKeytabArgs: reqArgs,
    ServiceAllowCreateKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_allow_create_keytab",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAllowCreateKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAllowCreateKeytabArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceAllowCreateKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type serviceAllowCreateKeytabKwParams struct {
  *ServiceAllowCreateKeytabArgs
  *ServiceAllowCreateKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAllowCreateKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAllowCreateKeytabResult `json:"result"`
}
type ServiceAllowCreateKeytabResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServiceAllowCreateKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAllowCreateKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAllowCreateKeytabResult%v", string(b))
}

/*
Allow users, groups, hosts or host groups to retrieve a keytab of this service.
*/
func (c *Client) ServiceAllowRetrieveKeytab(
  reqArgs *ServiceAllowRetrieveKeytabArgs,
  optArgs *ServiceAllowRetrieveKeytabOptionalArgs, // can be nil
) (*ServiceAllowRetrieveKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceAllowRetrieveKeytabKwParams{
    ServiceAllowRetrieveKeytabArgs: reqArgs,
    ServiceAllowRetrieveKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_allow_retrieve_keytab",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceAllowRetrieveKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceAllowRetrieveKeytabArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceAllowRetrieveKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type serviceAllowRetrieveKeytabKwParams struct {
  *ServiceAllowRetrieveKeytabArgs
  *ServiceAllowRetrieveKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceAllowRetrieveKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceAllowRetrieveKeytabResult `json:"result"`
}
type ServiceAllowRetrieveKeytabResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServiceAllowRetrieveKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceAllowRetrieveKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceAllowRetrieveKeytabResult%v", string(b))
}

/*
Delete an IPA service.
*/
func (c *Client) ServiceDel(
  reqArgs *ServiceDelArgs,
  optArgs *ServiceDelOptionalArgs, // can be nil
) (*ServiceDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceDelKwParams{
    ServiceDelArgs: reqArgs,
    ServiceDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceDelArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname []string `json:"krbcanonicalname,omitempty"`
  }

type ServiceDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type serviceDelKwParams struct {
  *ServiceDelArgs
  *ServiceDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceDelResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceDelResult `json:"result"`
}
type ServiceDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *ServiceDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceDelResult%v", string(b))
}

/*
Disable the Kerberos key and SSL certificate of a service.
*/
func (c *Client) ServiceDisable(
  reqArgs *ServiceDisableArgs,
  optArgs *ServiceDisableOptionalArgs, // can be nil
) (*ServiceDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceDisableKwParams{
    ServiceDisableArgs: reqArgs,
    ServiceDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceDisableArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceDisableOptionalArgs struct {
  }

type serviceDisableKwParams struct {
  *ServiceDisableArgs
  *ServiceDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceDisableResult `json:"result"`
}
type ServiceDisableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServiceDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceDisableResult%v", string(b))
}

/*
Disallow users, groups, hosts or host groups to create a keytab of this service.
*/
func (c *Client) ServiceDisallowCreateKeytab(
  reqArgs *ServiceDisallowCreateKeytabArgs,
  optArgs *ServiceDisallowCreateKeytabOptionalArgs, // can be nil
) (*ServiceDisallowCreateKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceDisallowCreateKeytabKwParams{
    ServiceDisallowCreateKeytabArgs: reqArgs,
    ServiceDisallowCreateKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_disallow_create_keytab",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceDisallowCreateKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceDisallowCreateKeytabArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceDisallowCreateKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type serviceDisallowCreateKeytabKwParams struct {
  *ServiceDisallowCreateKeytabArgs
  *ServiceDisallowCreateKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceDisallowCreateKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceDisallowCreateKeytabResult `json:"result"`
}
type ServiceDisallowCreateKeytabResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServiceDisallowCreateKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceDisallowCreateKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceDisallowCreateKeytabResult%v", string(b))
}

/*
Disallow users, groups, hosts or host groups to retrieve a keytab of this service.
*/
func (c *Client) ServiceDisallowRetrieveKeytab(
  reqArgs *ServiceDisallowRetrieveKeytabArgs,
  optArgs *ServiceDisallowRetrieveKeytabOptionalArgs, // can be nil
) (*ServiceDisallowRetrieveKeytabResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceDisallowRetrieveKeytabKwParams{
    ServiceDisallowRetrieveKeytabArgs: reqArgs,
    ServiceDisallowRetrieveKeytabOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_disallow_retrieve_keytab",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceDisallowRetrieveKeytabResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceDisallowRetrieveKeytabArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceDisallowRetrieveKeytabOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  }

type serviceDisallowRetrieveKeytabKwParams struct {
  *ServiceDisallowRetrieveKeytabArgs
  *ServiceDisallowRetrieveKeytabOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceDisallowRetrieveKeytabResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceDisallowRetrieveKeytabResult `json:"result"`
}
type ServiceDisallowRetrieveKeytabResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServiceDisallowRetrieveKeytabResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceDisallowRetrieveKeytabResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceDisallowRetrieveKeytabResult%v", string(b))
}

/*
Search for IPA services.
*/
func (c *Client) ServiceFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ServiceFindArgs,
  optArgs *ServiceFindOptionalArgs, // can be nil
) (*ServiceFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceFindKwParams{
    ServiceFindArgs: reqArgs,
    ServiceFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceFindArgs struct {
  }

type ServiceFindOptionalArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname *string `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias
Service principal alias
    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
PAC type
Override default list of supported PAC types. Use 'NONE' to disable PAC support for this service, e.g. this might be necessary for NFS services.
    */
    Ipakrbauthzdata *[]string `json:"ipakrbauthzdata,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("canonical-principal")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
host
Search for services with these managed by hosts.
    */
    ManByHost *[]string `json:"man_by_host,omitempty"`
  
    /*
host
Search for services without these managed by hosts.
    */
    NotManByHost *[]string `json:"not_man_by_host,omitempty"`
  }

type serviceFindKwParams struct {
  *ServiceFindArgs
  *ServiceFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceFindResult `json:"result"`
}
type ServiceFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Service `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *ServiceFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceFindResult%v", string(b))
}

/*
Modify an existing IPA service.
*/
func (c *Client) ServiceMod(
  reqArgs *ServiceModArgs,
  optArgs *ServiceModOptionalArgs, // can be nil
) (*ServiceModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceModKwParams{
    ServiceModArgs: reqArgs,
    ServiceModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceModArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceModOptionalArgs struct {
  
    /*
Principal alias
Service principal alias
    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Certificate
Base-64 encoded service certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
PAC type
Override default list of supported PAC types. Use 'NONE' to disable PAC support for this service, e.g. this might be necessary for NFS services.
    */
    Ipakrbauthzdata *[]string `json:"ipakrbauthzdata,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *bool `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *bool `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *bool `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceModKwParams struct {
  *ServiceModArgs
  *ServiceModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceModResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceModResult `json:"result"`
}
type ServiceModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Service `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServiceModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceModResult%v", string(b))
}

/*
Remove certificates from a service
*/
func (c *Client) ServiceRemoveCert(
  reqArgs *ServiceRemoveCertArgs,
  optArgs *ServiceRemoveCertOptionalArgs, // can be nil
) (*ServiceRemoveCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceRemoveCertKwParams{
    ServiceRemoveCertArgs: reqArgs,
    ServiceRemoveCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_remove_cert",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceRemoveCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceRemoveCertArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  
    /*
Certificate
Base-64 encoded service certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type ServiceRemoveCertOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceRemoveCertKwParams struct {
  *ServiceRemoveCertArgs
  *ServiceRemoveCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceRemoveCertResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceRemoveCertResult `json:"result"`
}
type ServiceRemoveCertResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServiceRemoveCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceRemoveCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceRemoveCertResult%v", string(b))
}

/*
Remove hosts that can manage this service.
*/
func (c *Client) ServiceRemoveHost(
  reqArgs *ServiceRemoveHostArgs,
  optArgs *ServiceRemoveHostOptionalArgs, // can be nil
) (*ServiceRemoveHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceRemoveHostKwParams{
    ServiceRemoveHostArgs: reqArgs,
    ServiceRemoveHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_remove_host",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceRemoveHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceRemoveHostArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceRemoveHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  }

type serviceRemoveHostKwParams struct {
  *ServiceRemoveHostArgs
  *ServiceRemoveHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceRemoveHostResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceRemoveHostResult `json:"result"`
}
type ServiceRemoveHostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServiceRemoveHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceRemoveHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceRemoveHostResult%v", string(b))
}

/*
Remove principal alias from a service
*/
func (c *Client) ServiceRemovePrincipal(
  reqArgs *ServiceRemovePrincipalArgs,
  optArgs *ServiceRemovePrincipalOptionalArgs, // can be nil
) (*ServiceRemovePrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceRemovePrincipalKwParams{
    ServiceRemovePrincipalArgs: reqArgs,
    ServiceRemovePrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_remove_principal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceRemovePrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceRemovePrincipalArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias
Service principal alias
    */
    Krbprincipalname []string `json:"krbprincipalname,omitempty"`
  }

type ServiceRemovePrincipalOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceRemovePrincipalKwParams struct {
  *ServiceRemovePrincipalArgs
  *ServiceRemovePrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceRemovePrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceRemovePrincipalResult `json:"result"`
}
type ServiceRemovePrincipalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServiceRemovePrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceRemovePrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceRemovePrincipalResult%v", string(b))
}

/*
Display information about an IPA service.
*/
func (c *Client) ServiceShow(
  reqArgs *ServiceShowArgs,
  optArgs *ServiceShowOptionalArgs, // can be nil
) (*ServiceShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := serviceShowKwParams{
    ServiceShowArgs: reqArgs,
    ServiceShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "service_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res serviceShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServiceShowArgs struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  }

type ServiceShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

file to store certificate in
    */
    Out *string `json:"out,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type serviceShowKwParams struct {
  *ServiceShowArgs
  *ServiceShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type serviceShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ServiceShowResult `json:"result"`
}
type ServiceShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Service `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServiceShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServiceShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServiceShowResult%v", string(b))
}

/*
Create a new service delegation rule.
*/
func (c *Client) ServicedelegationruleAdd(
  reqArgs *ServicedelegationruleAddArgs,
  optArgs *ServicedelegationruleAddOptionalArgs, // can be nil
) (*ServicedelegationruleAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleAddKwParams{
    ServicedelegationruleAddArgs: reqArgs,
    ServicedelegationruleAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleAddArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type servicedelegationruleAddKwParams struct {
  *ServicedelegationruleAddArgs
  *ServicedelegationruleAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleAddResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleAddResult `json:"result"`
}
type ServicedelegationruleAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Servicedelegationrule `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServicedelegationruleAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleAddResult%v", string(b))
}

/*
Add member to a named service delegation rule.
*/
func (c *Client) ServicedelegationruleAddMember(
  reqArgs *ServicedelegationruleAddMemberArgs,
  optArgs *ServicedelegationruleAddMemberOptionalArgs, // can be nil
) (*ServicedelegationruleAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleAddMemberKwParams{
    ServicedelegationruleAddMemberArgs: reqArgs,
    ServicedelegationruleAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_add_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleAddMemberArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member principal
principal to add
    */
    Principal *[]string `json:"principal,omitempty"`
  }

type servicedelegationruleAddMemberKwParams struct {
  *ServicedelegationruleAddMemberArgs
  *ServicedelegationruleAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleAddMemberResult `json:"result"`
}
type ServicedelegationruleAddMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServicedelegationruleAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleAddMemberResult%v", string(b))
}

/*
Add target to a named service delegation rule.
*/
func (c *Client) ServicedelegationruleAddTarget(
  reqArgs *ServicedelegationruleAddTargetArgs,
  optArgs *ServicedelegationruleAddTargetOptionalArgs, // can be nil
) (*ServicedelegationruleAddTargetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleAddTargetKwParams{
    ServicedelegationruleAddTargetArgs: reqArgs,
    ServicedelegationruleAddTargetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_add_target",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleAddTargetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleAddTargetArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleAddTargetOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member service delegation target
service delegation targets to add
    */
    Servicedelegationtarget *[]string `json:"servicedelegationtarget,omitempty"`
  }

type servicedelegationruleAddTargetKwParams struct {
  *ServicedelegationruleAddTargetArgs
  *ServicedelegationruleAddTargetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleAddTargetResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleAddTargetResult `json:"result"`
}
type ServicedelegationruleAddTargetResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServicedelegationruleAddTargetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleAddTargetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleAddTargetResult%v", string(b))
}

/*
Delete service delegation.
*/
func (c *Client) ServicedelegationruleDel(
  reqArgs *ServicedelegationruleDelArgs,
  optArgs *ServicedelegationruleDelOptionalArgs, // can be nil
) (*ServicedelegationruleDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleDelKwParams{
    ServicedelegationruleDelArgs: reqArgs,
    ServicedelegationruleDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleDelArgs struct {
  
    /*
Delegation name

    */
    Cn []string `json:"cn,omitempty"`
  }

type ServicedelegationruleDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type servicedelegationruleDelKwParams struct {
  *ServicedelegationruleDelArgs
  *ServicedelegationruleDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleDelResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleDelResult `json:"result"`
}
type ServicedelegationruleDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *ServicedelegationruleDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleDelResult%v", string(b))
}

/*
Search for service delegations rule.
*/
func (c *Client) ServicedelegationruleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ServicedelegationruleFindArgs,
  optArgs *ServicedelegationruleFindOptionalArgs, // can be nil
) (*ServicedelegationruleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleFindKwParams{
    ServicedelegationruleFindArgs: reqArgs,
    ServicedelegationruleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleFindArgs struct {
  }

type ServicedelegationruleFindOptionalArgs struct {
  
    /*
Delegation name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("delegation-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type servicedelegationruleFindKwParams struct {
  *ServicedelegationruleFindArgs
  *ServicedelegationruleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleFindResult `json:"result"`
}
type ServicedelegationruleFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Servicedelegationrule `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *ServicedelegationruleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleFindResult%v", string(b))
}

/*
Remove member from a named service delegation rule.
*/
func (c *Client) ServicedelegationruleRemoveMember(
  reqArgs *ServicedelegationruleRemoveMemberArgs,
  optArgs *ServicedelegationruleRemoveMemberOptionalArgs, // can be nil
) (*ServicedelegationruleRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleRemoveMemberKwParams{
    ServicedelegationruleRemoveMemberArgs: reqArgs,
    ServicedelegationruleRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_remove_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleRemoveMemberArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member principal
principal to remove
    */
    Principal *[]string `json:"principal,omitempty"`
  }

type servicedelegationruleRemoveMemberKwParams struct {
  *ServicedelegationruleRemoveMemberArgs
  *ServicedelegationruleRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleRemoveMemberResult `json:"result"`
}
type ServicedelegationruleRemoveMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServicedelegationruleRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleRemoveMemberResult%v", string(b))
}

/*
Remove target from a named service delegation rule.
*/
func (c *Client) ServicedelegationruleRemoveTarget(
  reqArgs *ServicedelegationruleRemoveTargetArgs,
  optArgs *ServicedelegationruleRemoveTargetOptionalArgs, // can be nil
) (*ServicedelegationruleRemoveTargetResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleRemoveTargetKwParams{
    ServicedelegationruleRemoveTargetArgs: reqArgs,
    ServicedelegationruleRemoveTargetOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_remove_target",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleRemoveTargetResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleRemoveTargetArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleRemoveTargetOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member service delegation target
service delegation targets to remove
    */
    Servicedelegationtarget *[]string `json:"servicedelegationtarget,omitempty"`
  }

type servicedelegationruleRemoveTargetKwParams struct {
  *ServicedelegationruleRemoveTargetArgs
  *ServicedelegationruleRemoveTargetOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleRemoveTargetResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleRemoveTargetResult `json:"result"`
}
type ServicedelegationruleRemoveTargetResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServicedelegationruleRemoveTargetResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleRemoveTargetResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleRemoveTargetResult%v", string(b))
}

/*
Display information about a named service delegation rule.
*/
func (c *Client) ServicedelegationruleShow(
  reqArgs *ServicedelegationruleShowArgs,
  optArgs *ServicedelegationruleShowOptionalArgs, // can be nil
) (*ServicedelegationruleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationruleShowKwParams{
    ServicedelegationruleShowArgs: reqArgs,
    ServicedelegationruleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationrule_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationruleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationruleShowArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationruleShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type servicedelegationruleShowKwParams struct {
  *ServicedelegationruleShowArgs
  *ServicedelegationruleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationruleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationruleShowResult `json:"result"`
}
type ServicedelegationruleShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Servicedelegationrule `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServicedelegationruleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationruleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationruleShowResult%v", string(b))
}

/*
Create a new service delegation target.
*/
func (c *Client) ServicedelegationtargetAdd(
  reqArgs *ServicedelegationtargetAddArgs,
  optArgs *ServicedelegationtargetAddOptionalArgs, // can be nil
) (*ServicedelegationtargetAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetAddKwParams{
    ServicedelegationtargetAddArgs: reqArgs,
    ServicedelegationtargetAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetAddArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationtargetAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type servicedelegationtargetAddKwParams struct {
  *ServicedelegationtargetAddArgs
  *ServicedelegationtargetAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetAddResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetAddResult `json:"result"`
}
type ServicedelegationtargetAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Servicedelegationtarget `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServicedelegationtargetAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetAddResult%v", string(b))
}

/*
Add member to a named service delegation target.
*/
func (c *Client) ServicedelegationtargetAddMember(
  reqArgs *ServicedelegationtargetAddMemberArgs,
  optArgs *ServicedelegationtargetAddMemberOptionalArgs, // can be nil
) (*ServicedelegationtargetAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetAddMemberKwParams{
    ServicedelegationtargetAddMemberArgs: reqArgs,
    ServicedelegationtargetAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_add_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetAddMemberArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationtargetAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
member principal
principal to add
    */
    Principal *[]string `json:"principal,omitempty"`
  }

type servicedelegationtargetAddMemberKwParams struct {
  *ServicedelegationtargetAddMemberArgs
  *ServicedelegationtargetAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetAddMemberResult `json:"result"`
}
type ServicedelegationtargetAddMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServicedelegationtargetAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetAddMemberResult%v", string(b))
}

/*
Delete service delegation target.
*/
func (c *Client) ServicedelegationtargetDel(
  reqArgs *ServicedelegationtargetDelArgs,
  optArgs *ServicedelegationtargetDelOptionalArgs, // can be nil
) (*ServicedelegationtargetDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetDelKwParams{
    ServicedelegationtargetDelArgs: reqArgs,
    ServicedelegationtargetDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetDelArgs struct {
  
    /*
Delegation name

    */
    Cn []string `json:"cn,omitempty"`
  }

type ServicedelegationtargetDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type servicedelegationtargetDelKwParams struct {
  *ServicedelegationtargetDelArgs
  *ServicedelegationtargetDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetDelResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetDelResult `json:"result"`
}
type ServicedelegationtargetDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *ServicedelegationtargetDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetDelResult%v", string(b))
}

/*
Search for service delegation target.
*/
func (c *Client) ServicedelegationtargetFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *ServicedelegationtargetFindArgs,
  optArgs *ServicedelegationtargetFindOptionalArgs, // can be nil
) (*ServicedelegationtargetFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetFindKwParams{
    ServicedelegationtargetFindArgs: reqArgs,
    ServicedelegationtargetFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetFindArgs struct {
  }

type ServicedelegationtargetFindOptionalArgs struct {
  
    /*
Delegation name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("delegation-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type servicedelegationtargetFindKwParams struct {
  *ServicedelegationtargetFindArgs
  *ServicedelegationtargetFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetFindResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetFindResult `json:"result"`
}
type ServicedelegationtargetFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Servicedelegationtarget `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *ServicedelegationtargetFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetFindResult%v", string(b))
}

/*
Remove member from a named service delegation target.
*/
func (c *Client) ServicedelegationtargetRemoveMember(
  reqArgs *ServicedelegationtargetRemoveMemberArgs,
  optArgs *ServicedelegationtargetRemoveMemberOptionalArgs, // can be nil
) (*ServicedelegationtargetRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetRemoveMemberKwParams{
    ServicedelegationtargetRemoveMemberArgs: reqArgs,
    ServicedelegationtargetRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_remove_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetRemoveMemberArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationtargetRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
member principal
principal to remove
    */
    Principal *[]string `json:"principal,omitempty"`
  }

type servicedelegationtargetRemoveMemberKwParams struct {
  *ServicedelegationtargetRemoveMemberArgs
  *ServicedelegationtargetRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetRemoveMemberResult `json:"result"`
}
type ServicedelegationtargetRemoveMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *ServicedelegationtargetRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetRemoveMemberResult%v", string(b))
}

/*
Display information about a named service delegation target.
*/
func (c *Client) ServicedelegationtargetShow(
  reqArgs *ServicedelegationtargetShowArgs,
  optArgs *ServicedelegationtargetShowOptionalArgs, // can be nil
) (*ServicedelegationtargetShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := servicedelegationtargetShowKwParams{
    ServicedelegationtargetShowArgs: reqArgs,
    ServicedelegationtargetShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "servicedelegationtarget_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res servicedelegationtargetShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type ServicedelegationtargetShowArgs struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  }

type ServicedelegationtargetShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type servicedelegationtargetShowKwParams struct {
  *ServicedelegationtargetShowArgs
  *ServicedelegationtargetShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type servicedelegationtargetShowResponse struct {
	Error  *Error      `json:"error"`
	Result *ServicedelegationtargetShowResult `json:"result"`
}
type ServicedelegationtargetShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Servicedelegationtarget `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *ServicedelegationtargetShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServicedelegationtargetShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServicedelegationtargetShowResult%v", string(b))
}

/*
RPC command used to log the current user out of their session.
*/
func (c *Client) SessionLogout(
  reqArgs *SessionLogoutArgs,
  optArgs *SessionLogoutOptionalArgs, // can be nil
) (*SessionLogoutResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sessionLogoutKwParams{
    SessionLogoutArgs: reqArgs,
    SessionLogoutOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "session_logout",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sessionLogoutResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SessionLogoutArgs struct {
  }

type SessionLogoutOptionalArgs struct {
  }

type sessionLogoutKwParams struct {
  *SessionLogoutArgs
  *SessionLogoutOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sessionLogoutResponse struct {
	Error  *Error      `json:"error"`
	Result *SessionLogoutResult `json:"result"`
}
type SessionLogoutResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *SessionLogoutResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SessionLogoutResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SessionLogoutResult%v", string(b))
}

/*
Determine whether ipa-adtrust-install has been run with sidgen task
*/
func (c *Client) SidgenWasRun(
  reqArgs *SidgenWasRunArgs,
  optArgs *SidgenWasRunOptionalArgs, // can be nil
) (*SidgenWasRunResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sidgenWasRunKwParams{
    SidgenWasRunArgs: reqArgs,
    SidgenWasRunOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sidgen_was_run",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sidgenWasRunResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SidgenWasRunArgs struct {
  }

type SidgenWasRunOptionalArgs struct {
  }

type sidgenWasRunKwParams struct {
  *SidgenWasRunArgs
  *SidgenWasRunOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sidgenWasRunResponse struct {
	Error  *Error      `json:"error"`
	Result *SidgenWasRunResult `json:"result"`
}
type SidgenWasRunResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *SidgenWasRunResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SidgenWasRunResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SidgenWasRunResult%v", string(b))
}

/*
Activate a stage user.
*/
func (c *Client) StageuserActivate(
  reqArgs *StageuserActivateArgs,
  optArgs *StageuserActivateOptionalArgs, // can be nil
) (*StageuserActivateResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserActivateKwParams{
    StageuserActivateArgs: reqArgs,
    StageuserActivateOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_activate",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserActivateResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserActivateArgs struct {
  }

type StageuserActivateOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserActivateKwParams struct {
  *StageuserActivateArgs
  *StageuserActivateOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserActivateResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserActivateResult `json:"result"`
}
type StageuserActivateResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *StageuserActivateResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserActivateResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserActivateResult%v", string(b))
}

/*
Add a new stage user.
*/
func (c *Client) StageuserAdd(
  reqArgs *StageuserAddArgs,
  optArgs *StageuserAddOptionalArgs, // can be nil
) (*StageuserAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserAddKwParams{
    StageuserAddArgs: reqArgs,
    StageuserAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserAddArgs struct {
  
    /*
First name

    */
    Givenname string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn string `json:"sn,omitempty"`
  }

type StageuserAddOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *bool `json:"random,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Create Stage user in from a delete user
    */
    FromDelete *bool `json:"from_delete,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserAddKwParams struct {
  *StageuserAddArgs
  *StageuserAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserAddResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserAddResult `json:"result"`
}
type StageuserAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Stageuser `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *StageuserAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserAddResult%v", string(b))
}

/*
Add one or more certificates to the stageuser entry
*/
func (c *Client) StageuserAddCert(
  reqArgs *StageuserAddCertArgs,
  optArgs *StageuserAddCertOptionalArgs, // can be nil
) (*StageuserAddCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserAddCertKwParams{
    StageuserAddCertArgs: reqArgs,
    StageuserAddCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_add_cert",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserAddCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserAddCertArgs struct {
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type StageuserAddCertOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserAddCertKwParams struct {
  *StageuserAddCertArgs
  *StageuserAddCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserAddCertResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserAddCertResult `json:"result"`
}
type StageuserAddCertResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *StageuserAddCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserAddCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserAddCertResult%v", string(b))
}

/*
Add one or more certificate mappings to the stage user entry.
*/
func (c *Client) StageuserAddCertmapdata(
  ipacertmapdata string, // Certificate mapping data
  reqArgs *StageuserAddCertmapdataArgs,
  optArgs *StageuserAddCertmapdataOptionalArgs, // can be nil
) (*StageuserAddCertmapdataResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserAddCertmapdataKwParams{
    StageuserAddCertmapdataArgs: reqArgs,
    StageuserAddCertmapdataOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_add_certmapdata",
    Params: []interface{}{
      []interface{}{ipacertmapdata, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserAddCertmapdataResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserAddCertmapdataArgs struct {
  }

type StageuserAddCertmapdataOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Issuer
Issuer of the certificate
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Subject
Subject of the certificate
    */
    Subject *string `json:"subject,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Certificate *[]interface{} `json:"certificate,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserAddCertmapdataKwParams struct {
  *StageuserAddCertmapdataArgs
  *StageuserAddCertmapdataOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserAddCertmapdataResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserAddCertmapdataResult `json:"result"`
}
type StageuserAddCertmapdataResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *StageuserAddCertmapdataResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserAddCertmapdataResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserAddCertmapdataResult%v", string(b))
}

/*
Add a manager to the stage user entry
*/
func (c *Client) StageuserAddManager(
  reqArgs *StageuserAddManagerArgs,
  optArgs *StageuserAddManagerOptionalArgs, // can be nil
) (*StageuserAddManagerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserAddManagerKwParams{
    StageuserAddManagerArgs: reqArgs,
    StageuserAddManagerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_add_manager",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserAddManagerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserAddManagerArgs struct {
  }

type StageuserAddManagerOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  }

type stageuserAddManagerKwParams struct {
  *StageuserAddManagerArgs
  *StageuserAddManagerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserAddManagerResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserAddManagerResult `json:"result"`
}
type StageuserAddManagerResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *StageuserAddManagerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserAddManagerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserAddManagerResult%v", string(b))
}

/*
Add new principal alias to the stageuser entry
*/
func (c *Client) StageuserAddPrincipal(
  reqArgs *StageuserAddPrincipalArgs,
  optArgs *StageuserAddPrincipalOptionalArgs, // can be nil
) (*StageuserAddPrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserAddPrincipalKwParams{
    StageuserAddPrincipalArgs: reqArgs,
    StageuserAddPrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_add_principal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserAddPrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserAddPrincipalArgs struct {
  }

type StageuserAddPrincipalOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserAddPrincipalKwParams struct {
  *StageuserAddPrincipalArgs
  *StageuserAddPrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserAddPrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserAddPrincipalResult `json:"result"`
}
type StageuserAddPrincipalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *StageuserAddPrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserAddPrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserAddPrincipalResult%v", string(b))
}

/*
Delete a stage user.
*/
func (c *Client) StageuserDel(
  reqArgs *StageuserDelArgs,
  optArgs *StageuserDelOptionalArgs, // can be nil
) (*StageuserDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserDelKwParams{
    StageuserDelArgs: reqArgs,
    StageuserDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserDelArgs struct {
  }

type StageuserDelOptionalArgs struct {
  
    /*
User login

    */
    UID *[]string `json:"uid,omitempty"`
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type stageuserDelKwParams struct {
  *StageuserDelArgs
  *StageuserDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserDelResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserDelResult `json:"result"`
}
type StageuserDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *StageuserDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserDelResult%v", string(b))
}

/*
Search for stage users.
*/
func (c *Client) StageuserFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *StageuserFindArgs,
  optArgs *StageuserFindOptionalArgs, // can be nil
) (*StageuserFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserFindKwParams{
    StageuserFindArgs: reqArgs,
    StageuserFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserFindArgs struct {
  }

type StageuserFindOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
First name

    */
    Givenname *string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn *string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("login")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
group
Search for stage users with these member of groups.
    */
    InGroup *[]string `json:"in_group,omitempty"`
  
    /*
group
Search for stage users without these member of groups.
    */
    NotInGroup *[]string `json:"not_in_group,omitempty"`
  
    /*
netgroup
Search for stage users with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for stage users without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  
    /*
role
Search for stage users with these member of roles.
    */
    InRole *[]string `json:"in_role,omitempty"`
  
    /*
role
Search for stage users without these member of roles.
    */
    NotInRole *[]string `json:"not_in_role,omitempty"`
  
    /*
HBAC rule
Search for stage users with these member of HBAC rules.
    */
    InHbacrule *[]string `json:"in_hbacrule,omitempty"`
  
    /*
HBAC rule
Search for stage users without these member of HBAC rules.
    */
    NotInHbacrule *[]string `json:"not_in_hbacrule,omitempty"`
  
    /*
sudo rule
Search for stage users with these member of sudo rules.
    */
    InSudorule *[]string `json:"in_sudorule,omitempty"`
  
    /*
sudo rule
Search for stage users without these member of sudo rules.
    */
    NotInSudorule *[]string `json:"not_in_sudorule,omitempty"`
  }

type stageuserFindKwParams struct {
  *StageuserFindArgs
  *StageuserFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserFindResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserFindResult `json:"result"`
}
type StageuserFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Stageuser `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *StageuserFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserFindResult%v", string(b))
}

/*
Modify a stage user.
*/
func (c *Client) StageuserMod(
  reqArgs *StageuserModArgs,
  optArgs *StageuserModOptionalArgs, // can be nil
) (*StageuserModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserModKwParams{
    StageuserModArgs: reqArgs,
    StageuserModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserModArgs struct {
  }

type StageuserModOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
First name

    */
    Givenname *string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn *string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *bool `json:"random,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the stage user object
    */
    Rename *string `json:"rename,omitempty"`
  }

type stageuserModKwParams struct {
  *StageuserModArgs
  *StageuserModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserModResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserModResult `json:"result"`
}
type StageuserModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Stageuser `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *StageuserModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserModResult%v", string(b))
}

/*
Remove one or more certificates to the stageuser entry
*/
func (c *Client) StageuserRemoveCert(
  reqArgs *StageuserRemoveCertArgs,
  optArgs *StageuserRemoveCertOptionalArgs, // can be nil
) (*StageuserRemoveCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserRemoveCertKwParams{
    StageuserRemoveCertArgs: reqArgs,
    StageuserRemoveCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_remove_cert",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserRemoveCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserRemoveCertArgs struct {
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type StageuserRemoveCertOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserRemoveCertKwParams struct {
  *StageuserRemoveCertArgs
  *StageuserRemoveCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserRemoveCertResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserRemoveCertResult `json:"result"`
}
type StageuserRemoveCertResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *StageuserRemoveCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserRemoveCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserRemoveCertResult%v", string(b))
}

/*
Remove one or more certificate mappings from the stage user entry.
*/
func (c *Client) StageuserRemoveCertmapdata(
  ipacertmapdata string, // Certificate mapping data
  reqArgs *StageuserRemoveCertmapdataArgs,
  optArgs *StageuserRemoveCertmapdataOptionalArgs, // can be nil
) (*StageuserRemoveCertmapdataResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserRemoveCertmapdataKwParams{
    StageuserRemoveCertmapdataArgs: reqArgs,
    StageuserRemoveCertmapdataOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_remove_certmapdata",
    Params: []interface{}{
      []interface{}{ipacertmapdata, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserRemoveCertmapdataResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserRemoveCertmapdataArgs struct {
  }

type StageuserRemoveCertmapdataOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Issuer
Issuer of the certificate
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Subject
Subject of the certificate
    */
    Subject *string `json:"subject,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Certificate *[]interface{} `json:"certificate,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserRemoveCertmapdataKwParams struct {
  *StageuserRemoveCertmapdataArgs
  *StageuserRemoveCertmapdataOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserRemoveCertmapdataResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserRemoveCertmapdataResult `json:"result"`
}
type StageuserRemoveCertmapdataResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *StageuserRemoveCertmapdataResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserRemoveCertmapdataResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserRemoveCertmapdataResult%v", string(b))
}

/*
Remove a manager to the stage user entry
*/
func (c *Client) StageuserRemoveManager(
  reqArgs *StageuserRemoveManagerArgs,
  optArgs *StageuserRemoveManagerOptionalArgs, // can be nil
) (*StageuserRemoveManagerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserRemoveManagerKwParams{
    StageuserRemoveManagerArgs: reqArgs,
    StageuserRemoveManagerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_remove_manager",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserRemoveManagerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserRemoveManagerArgs struct {
  }

type StageuserRemoveManagerOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  }

type stageuserRemoveManagerKwParams struct {
  *StageuserRemoveManagerArgs
  *StageuserRemoveManagerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserRemoveManagerResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserRemoveManagerResult `json:"result"`
}
type StageuserRemoveManagerResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *StageuserRemoveManagerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserRemoveManagerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserRemoveManagerResult%v", string(b))
}

/*
Remove principal alias from the stageuser entry
*/
func (c *Client) StageuserRemovePrincipal(
  reqArgs *StageuserRemovePrincipalArgs,
  optArgs *StageuserRemovePrincipalOptionalArgs, // can be nil
) (*StageuserRemovePrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserRemovePrincipalKwParams{
    StageuserRemovePrincipalArgs: reqArgs,
    StageuserRemovePrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_remove_principal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserRemovePrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserRemovePrincipalArgs struct {
  }

type StageuserRemovePrincipalOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserRemovePrincipalKwParams struct {
  *StageuserRemovePrincipalArgs
  *StageuserRemovePrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserRemovePrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserRemovePrincipalResult `json:"result"`
}
type StageuserRemovePrincipalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *StageuserRemovePrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserRemovePrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserRemovePrincipalResult%v", string(b))
}

/*
Display information about a stage user.
*/
func (c *Client) StageuserShow(
  reqArgs *StageuserShowArgs,
  optArgs *StageuserShowOptionalArgs, // can be nil
) (*StageuserShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := stageuserShowKwParams{
    StageuserShowArgs: reqArgs,
    StageuserShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "stageuser_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res stageuserShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type StageuserShowArgs struct {
  }

type StageuserShowOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type stageuserShowKwParams struct {
  *StageuserShowArgs
  *StageuserShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type stageuserShowResponse struct {
	Error  *Error      `json:"error"`
	Result *StageuserShowResult `json:"result"`
}
type StageuserShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Stageuser `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *StageuserShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("StageuserShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("StageuserShowResult%v", string(b))
}

/*
Create new Sudo Command.
*/
func (c *Client) SudocmdAdd(
  reqArgs *SudocmdAddArgs,
  optArgs *SudocmdAddOptionalArgs, // can be nil
) (*SudocmdAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdAddKwParams{
    SudocmdAddArgs: reqArgs,
    SudocmdAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmd_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdAddArgs struct {
  
    /*
Sudo Command

    */
    Sudocmd string `json:"sudocmd,omitempty"`
  }

type SudocmdAddOptionalArgs struct {
  
    /*
Description
A description of this command
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdAddKwParams struct {
  *SudocmdAddArgs
  *SudocmdAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdAddResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdAddResult `json:"result"`
}
type SudocmdAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Sudocmd `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SudocmdAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdAddResult%v", string(b))
}

/*
Delete Sudo Command.
*/
func (c *Client) SudocmdDel(
  reqArgs *SudocmdDelArgs,
  optArgs *SudocmdDelOptionalArgs, // can be nil
) (*SudocmdDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdDelKwParams{
    SudocmdDelArgs: reqArgs,
    SudocmdDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmd_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdDelArgs struct {
  
    /*
Sudo Command

    */
    Sudocmd []string `json:"sudocmd,omitempty"`
  }

type SudocmdDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type sudocmdDelKwParams struct {
  *SudocmdDelArgs
  *SudocmdDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdDelResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdDelResult `json:"result"`
}
type SudocmdDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *SudocmdDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdDelResult%v", string(b))
}

/*
Search for Sudo Commands.
*/
func (c *Client) SudocmdFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *SudocmdFindArgs,
  optArgs *SudocmdFindOptionalArgs, // can be nil
) (*SudocmdFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdFindKwParams{
    SudocmdFindArgs: reqArgs,
    SudocmdFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmd_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdFindArgs struct {
  }

type SudocmdFindOptionalArgs struct {
  
    /*
Sudo Command

    */
    Sudocmd *string `json:"sudocmd,omitempty"`
  
    /*
Description
A description of this command
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("command")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type sudocmdFindKwParams struct {
  *SudocmdFindArgs
  *SudocmdFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdFindResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdFindResult `json:"result"`
}
type SudocmdFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Sudocmd `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *SudocmdFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdFindResult%v", string(b))
}

/*
Modify Sudo Command.
*/
func (c *Client) SudocmdMod(
  reqArgs *SudocmdModArgs,
  optArgs *SudocmdModOptionalArgs, // can be nil
) (*SudocmdModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdModKwParams{
    SudocmdModArgs: reqArgs,
    SudocmdModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmd_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdModArgs struct {
  
    /*
Sudo Command

    */
    Sudocmd string `json:"sudocmd,omitempty"`
  }

type SudocmdModOptionalArgs struct {
  
    /*
Description
A description of this command
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdModKwParams struct {
  *SudocmdModArgs
  *SudocmdModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdModResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdModResult `json:"result"`
}
type SudocmdModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Sudocmd `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SudocmdModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdModResult%v", string(b))
}

/*
Display Sudo Command.
*/
func (c *Client) SudocmdShow(
  reqArgs *SudocmdShowArgs,
  optArgs *SudocmdShowOptionalArgs, // can be nil
) (*SudocmdShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdShowKwParams{
    SudocmdShowArgs: reqArgs,
    SudocmdShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmd_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdShowArgs struct {
  
    /*
Sudo Command

    */
    Sudocmd string `json:"sudocmd,omitempty"`
  }

type SudocmdShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdShowKwParams struct {
  *SudocmdShowArgs
  *SudocmdShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdShowResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdShowResult `json:"result"`
}
type SudocmdShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Sudocmd `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SudocmdShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdShowResult%v", string(b))
}

/*
Create new Sudo Command Group.
*/
func (c *Client) SudocmdgroupAdd(
  reqArgs *SudocmdgroupAddArgs,
  optArgs *SudocmdgroupAddOptionalArgs, // can be nil
) (*SudocmdgroupAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupAddKwParams{
    SudocmdgroupAddArgs: reqArgs,
    SudocmdgroupAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupAddArgs struct {
  
    /*
Sudo Command Group

    */
    Cn string `json:"cn,omitempty"`
  }

type SudocmdgroupAddOptionalArgs struct {
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdgroupAddKwParams struct {
  *SudocmdgroupAddArgs
  *SudocmdgroupAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupAddResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupAddResult `json:"result"`
}
type SudocmdgroupAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Sudocmdgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SudocmdgroupAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupAddResult%v", string(b))
}

/*
Add members to Sudo Command Group.
*/
func (c *Client) SudocmdgroupAddMember(
  reqArgs *SudocmdgroupAddMemberArgs,
  optArgs *SudocmdgroupAddMemberOptionalArgs, // can be nil
) (*SudocmdgroupAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupAddMemberKwParams{
    SudocmdgroupAddMemberArgs: reqArgs,
    SudocmdgroupAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_add_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupAddMemberArgs struct {
  
    /*
Sudo Command Group

    */
    Cn string `json:"cn,omitempty"`
  }

type SudocmdgroupAddMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to add
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  }

type sudocmdgroupAddMemberKwParams struct {
  *SudocmdgroupAddMemberArgs
  *SudocmdgroupAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupAddMemberResult `json:"result"`
}
type SudocmdgroupAddMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudocmdgroupAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupAddMemberResult%v", string(b))
}

/*
Delete Sudo Command Group.
*/
func (c *Client) SudocmdgroupDel(
  reqArgs *SudocmdgroupDelArgs,
  optArgs *SudocmdgroupDelOptionalArgs, // can be nil
) (*SudocmdgroupDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupDelKwParams{
    SudocmdgroupDelArgs: reqArgs,
    SudocmdgroupDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupDelArgs struct {
  
    /*
Sudo Command Group

    */
    Cn []string `json:"cn,omitempty"`
  }

type SudocmdgroupDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type sudocmdgroupDelKwParams struct {
  *SudocmdgroupDelArgs
  *SudocmdgroupDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupDelResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupDelResult `json:"result"`
}
type SudocmdgroupDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *SudocmdgroupDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupDelResult%v", string(b))
}

/*
Search for Sudo Command Groups.
*/
func (c *Client) SudocmdgroupFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *SudocmdgroupFindArgs,
  optArgs *SudocmdgroupFindOptionalArgs, // can be nil
) (*SudocmdgroupFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupFindKwParams{
    SudocmdgroupFindArgs: reqArgs,
    SudocmdgroupFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupFindArgs struct {
  }

type SudocmdgroupFindOptionalArgs struct {
  
    /*
Sudo Command Group

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("sudocmdgroup-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type sudocmdgroupFindKwParams struct {
  *SudocmdgroupFindArgs
  *SudocmdgroupFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupFindResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupFindResult `json:"result"`
}
type SudocmdgroupFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Sudocmdgroup `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *SudocmdgroupFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupFindResult%v", string(b))
}

/*
Modify Sudo Command Group.
*/
func (c *Client) SudocmdgroupMod(
  reqArgs *SudocmdgroupModArgs,
  optArgs *SudocmdgroupModOptionalArgs, // can be nil
) (*SudocmdgroupModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupModKwParams{
    SudocmdgroupModArgs: reqArgs,
    SudocmdgroupModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupModArgs struct {
  
    /*
Sudo Command Group

    */
    Cn string `json:"cn,omitempty"`
  }

type SudocmdgroupModOptionalArgs struct {
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdgroupModKwParams struct {
  *SudocmdgroupModArgs
  *SudocmdgroupModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupModResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupModResult `json:"result"`
}
type SudocmdgroupModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Sudocmdgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SudocmdgroupModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupModResult%v", string(b))
}

/*
Remove members from Sudo Command Group.
*/
func (c *Client) SudocmdgroupRemoveMember(
  reqArgs *SudocmdgroupRemoveMemberArgs,
  optArgs *SudocmdgroupRemoveMemberOptionalArgs, // can be nil
) (*SudocmdgroupRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupRemoveMemberKwParams{
    SudocmdgroupRemoveMemberArgs: reqArgs,
    SudocmdgroupRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_remove_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupRemoveMemberArgs struct {
  
    /*
Sudo Command Group

    */
    Cn string `json:"cn,omitempty"`
  }

type SudocmdgroupRemoveMemberOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to remove
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  }

type sudocmdgroupRemoveMemberKwParams struct {
  *SudocmdgroupRemoveMemberArgs
  *SudocmdgroupRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupRemoveMemberResult `json:"result"`
}
type SudocmdgroupRemoveMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudocmdgroupRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupRemoveMemberResult%v", string(b))
}

/*
Display Sudo Command Group.
*/
func (c *Client) SudocmdgroupShow(
  reqArgs *SudocmdgroupShowArgs,
  optArgs *SudocmdgroupShowOptionalArgs, // can be nil
) (*SudocmdgroupShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudocmdgroupShowKwParams{
    SudocmdgroupShowArgs: reqArgs,
    SudocmdgroupShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudocmdgroup_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudocmdgroupShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudocmdgroupShowArgs struct {
  
    /*
Sudo Command Group

    */
    Cn string `json:"cn,omitempty"`
  }

type SudocmdgroupShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudocmdgroupShowKwParams struct {
  *SudocmdgroupShowArgs
  *SudocmdgroupShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudocmdgroupShowResponse struct {
	Error  *Error      `json:"error"`
	Result *SudocmdgroupShowResult `json:"result"`
}
type SudocmdgroupShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Sudocmdgroup `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SudocmdgroupShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudocmdgroupShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudocmdgroupShowResult%v", string(b))
}

/*
Create new Sudo Rule.
*/
func (c *Client) SudoruleAdd(
  reqArgs *SudoruleAddArgs,
  optArgs *SudoruleAddOptionalArgs, // can be nil
) (*SudoruleAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddKwParams{
    SudoruleAddArgs: reqArgs,
    SudoruleAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Command category
Command category the rule applies to
    */
    Cmdcategory *string `json:"cmdcategory,omitempty"`
  
    /*
RunAs User category
RunAs User category the rule applies to
    */
    Ipasudorunasusercategory *string `json:"ipasudorunasusercategory,omitempty"`
  
    /*
RunAs Group category
RunAs Group category the rule applies to
    */
    Ipasudorunasgroupcategory *string `json:"ipasudorunasgroupcategory,omitempty"`
  
    /*
Sudo order
integer to order the Sudo rules
    */
    Sudoorder *int `json:"sudoorder,omitempty"`
  
    /*
External User
External User the rule applies to (sudorule-find only)
    */
    Externaluser *string `json:"externaluser,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
RunAs External User
External User the commands can run as (sudorule-find only)
    */
    Ipasudorunasextuser *string `json:"ipasudorunasextuser,omitempty"`
  
    /*
RunAs External Group
External Group the commands can run as (sudorule-find only)
    */
    Ipasudorunasextgroup *string `json:"ipasudorunasextgroup,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudoruleAddKwParams struct {
  *SudoruleAddArgs
  *SudoruleAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddResult `json:"result"`
}
type SudoruleAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Sudorule `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SudoruleAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddResult%v", string(b))
}

/*
Add commands and sudo command groups affected by Sudo Rule.
*/
func (c *Client) SudoruleAddAllowCommand(
  reqArgs *SudoruleAddAllowCommandArgs,
  optArgs *SudoruleAddAllowCommandOptionalArgs, // can be nil
) (*SudoruleAddAllowCommandResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddAllowCommandKwParams{
    SudoruleAddAllowCommandArgs: reqArgs,
    SudoruleAddAllowCommandOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_allow_command",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddAllowCommandResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddAllowCommandArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddAllowCommandOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to add
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  
    /*
member sudo command group
sudo command groups to add
    */
    Sudocmdgroup *[]string `json:"sudocmdgroup,omitempty"`
  }

type sudoruleAddAllowCommandKwParams struct {
  *SudoruleAddAllowCommandArgs
  *SudoruleAddAllowCommandOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddAllowCommandResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddAllowCommandResult `json:"result"`
}
type SudoruleAddAllowCommandResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleAddAllowCommandResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddAllowCommandResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddAllowCommandResult%v", string(b))
}

/*
Add commands and sudo command groups affected by Sudo Rule.
*/
func (c *Client) SudoruleAddDenyCommand(
  reqArgs *SudoruleAddDenyCommandArgs,
  optArgs *SudoruleAddDenyCommandOptionalArgs, // can be nil
) (*SudoruleAddDenyCommandResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddDenyCommandKwParams{
    SudoruleAddDenyCommandArgs: reqArgs,
    SudoruleAddDenyCommandOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_deny_command",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddDenyCommandResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddDenyCommandArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddDenyCommandOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to add
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  
    /*
member sudo command group
sudo command groups to add
    */
    Sudocmdgroup *[]string `json:"sudocmdgroup,omitempty"`
  }

type sudoruleAddDenyCommandKwParams struct {
  *SudoruleAddDenyCommandArgs
  *SudoruleAddDenyCommandOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddDenyCommandResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddDenyCommandResult `json:"result"`
}
type SudoruleAddDenyCommandResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleAddDenyCommandResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddDenyCommandResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddDenyCommandResult%v", string(b))
}

/*
Add hosts and hostgroups affected by Sudo Rule.
*/
func (c *Client) SudoruleAddHost(
  reqArgs *SudoruleAddHostArgs,
  optArgs *SudoruleAddHostOptionalArgs, // can be nil
) (*SudoruleAddHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddHostKwParams{
    SudoruleAddHostArgs: reqArgs,
    SudoruleAddHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_host",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to add
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to add
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
host masks of allowed hosts

    */
    Hostmask *[]string `json:"hostmask,omitempty"`
  }

type sudoruleAddHostKwParams struct {
  *SudoruleAddHostArgs
  *SudoruleAddHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddHostResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddHostResult `json:"result"`
}
type SudoruleAddHostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleAddHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddHostResult%v", string(b))
}

/*
Add an option to the Sudo Rule.
*/
func (c *Client) SudoruleAddOption(
  reqArgs *SudoruleAddOptionArgs,
  optArgs *SudoruleAddOptionOptionalArgs, // can be nil
) (*SudoruleAddOptionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddOptionKwParams{
    SudoruleAddOptionArgs: reqArgs,
    SudoruleAddOptionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_option",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddOptionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddOptionArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Sudo Option

    */
    Ipasudoopt string `json:"ipasudoopt,omitempty"`
  }

type SudoruleAddOptionOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudoruleAddOptionKwParams struct {
  *SudoruleAddOptionArgs
  *SudoruleAddOptionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddOptionResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddOptionResult `json:"result"`
}
type SudoruleAddOptionResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SudoruleAddOptionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddOptionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddOptionResult%v", string(b))
}

/*
Add group for Sudo to execute as.
*/
func (c *Client) SudoruleAddRunasgroup(
  reqArgs *SudoruleAddRunasgroupArgs,
  optArgs *SudoruleAddRunasgroupOptionalArgs, // can be nil
) (*SudoruleAddRunasgroupResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddRunasgroupKwParams{
    SudoruleAddRunasgroupArgs: reqArgs,
    SudoruleAddRunasgroupOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_runasgroup",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddRunasgroupResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddRunasgroupArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddRunasgroupOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleAddRunasgroupKwParams struct {
  *SudoruleAddRunasgroupArgs
  *SudoruleAddRunasgroupOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddRunasgroupResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddRunasgroupResult `json:"result"`
}
type SudoruleAddRunasgroupResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleAddRunasgroupResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddRunasgroupResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddRunasgroupResult%v", string(b))
}

/*
Add users and groups for Sudo to execute as.
*/
func (c *Client) SudoruleAddRunasuser(
  reqArgs *SudoruleAddRunasuserArgs,
  optArgs *SudoruleAddRunasuserOptionalArgs, // can be nil
) (*SudoruleAddRunasuserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddRunasuserKwParams{
    SudoruleAddRunasuserArgs: reqArgs,
    SudoruleAddRunasuserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_runasuser",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddRunasuserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddRunasuserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddRunasuserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleAddRunasuserKwParams struct {
  *SudoruleAddRunasuserArgs
  *SudoruleAddRunasuserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddRunasuserResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddRunasuserResult `json:"result"`
}
type SudoruleAddRunasuserResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleAddRunasuserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddRunasuserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddRunasuserResult%v", string(b))
}

/*
Add users and groups affected by Sudo Rule.
*/
func (c *Client) SudoruleAddUser(
  reqArgs *SudoruleAddUserArgs,
  optArgs *SudoruleAddUserOptionalArgs, // can be nil
) (*SudoruleAddUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleAddUserKwParams{
    SudoruleAddUserArgs: reqArgs,
    SudoruleAddUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_add_user",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleAddUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleAddUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleAddUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleAddUserKwParams struct {
  *SudoruleAddUserArgs
  *SudoruleAddUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleAddUserResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleAddUserResult `json:"result"`
}
type SudoruleAddUserResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleAddUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleAddUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleAddUserResult%v", string(b))
}

/*
Delete Sudo Rule.
*/
func (c *Client) SudoruleDel(
  reqArgs *SudoruleDelArgs,
  optArgs *SudoruleDelOptionalArgs, // can be nil
) (*SudoruleDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleDelKwParams{
    SudoruleDelArgs: reqArgs,
    SudoruleDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleDelArgs struct {
  
    /*
Rule name

    */
    Cn []string `json:"cn,omitempty"`
  }

type SudoruleDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type sudoruleDelKwParams struct {
  *SudoruleDelArgs
  *SudoruleDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleDelResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleDelResult `json:"result"`
}
type SudoruleDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *SudoruleDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleDelResult%v", string(b))
}

/*
Disable a Sudo Rule.
*/
func (c *Client) SudoruleDisable(
  reqArgs *SudoruleDisableArgs,
  optArgs *SudoruleDisableOptionalArgs, // can be nil
) (*SudoruleDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleDisableKwParams{
    SudoruleDisableArgs: reqArgs,
    SudoruleDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleDisableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleDisableOptionalArgs struct {
  }

type sudoruleDisableKwParams struct {
  *SudoruleDisableArgs
  *SudoruleDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleDisableResult `json:"result"`
}
type SudoruleDisableResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *SudoruleDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleDisableResult%v", string(b))
}

/*
Enable a Sudo Rule.
*/
func (c *Client) SudoruleEnable(
  reqArgs *SudoruleEnableArgs,
  optArgs *SudoruleEnableOptionalArgs, // can be nil
) (*SudoruleEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleEnableKwParams{
    SudoruleEnableArgs: reqArgs,
    SudoruleEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_enable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleEnableArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleEnableOptionalArgs struct {
  }

type sudoruleEnableKwParams struct {
  *SudoruleEnableArgs
  *SudoruleEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleEnableResult `json:"result"`
}
type SudoruleEnableResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *SudoruleEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleEnableResult%v", string(b))
}

/*
Search for Sudo Rule.
*/
func (c *Client) SudoruleFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *SudoruleFindArgs,
  optArgs *SudoruleFindOptionalArgs, // can be nil
) (*SudoruleFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleFindKwParams{
    SudoruleFindArgs: reqArgs,
    SudoruleFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleFindArgs struct {
  }

type SudoruleFindOptionalArgs struct {
  
    /*
Rule name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Command category
Command category the rule applies to
    */
    Cmdcategory *string `json:"cmdcategory,omitempty"`
  
    /*
RunAs User category
RunAs User category the rule applies to
    */
    Ipasudorunasusercategory *string `json:"ipasudorunasusercategory,omitempty"`
  
    /*
RunAs Group category
RunAs Group category the rule applies to
    */
    Ipasudorunasgroupcategory *string `json:"ipasudorunasgroupcategory,omitempty"`
  
    /*
Sudo order
integer to order the Sudo rules
    */
    Sudoorder *int `json:"sudoorder,omitempty"`
  
    /*
External User
External User the rule applies to (sudorule-find only)
    */
    Externaluser *string `json:"externaluser,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
RunAs External User
External User the commands can run as (sudorule-find only)
    */
    Ipasudorunasextuser *string `json:"ipasudorunasextuser,omitempty"`
  
    /*
RunAs External Group
External Group the commands can run as (sudorule-find only)
    */
    Ipasudorunasextgroup *string `json:"ipasudorunasextgroup,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("sudorule-name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type sudoruleFindKwParams struct {
  *SudoruleFindArgs
  *SudoruleFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleFindResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleFindResult `json:"result"`
}
type SudoruleFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Sudorule `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *SudoruleFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleFindResult%v", string(b))
}

/*
Modify Sudo Rule.
*/
func (c *Client) SudoruleMod(
  reqArgs *SudoruleModArgs,
  optArgs *SudoruleModOptionalArgs, // can be nil
) (*SudoruleModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleModKwParams{
    SudoruleModArgs: reqArgs,
    SudoruleModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleModArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleModOptionalArgs struct {
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Command category
Command category the rule applies to
    */
    Cmdcategory *string `json:"cmdcategory,omitempty"`
  
    /*
RunAs User category
RunAs User category the rule applies to
    */
    Ipasudorunasusercategory *string `json:"ipasudorunasusercategory,omitempty"`
  
    /*
RunAs Group category
RunAs Group category the rule applies to
    */
    Ipasudorunasgroupcategory *string `json:"ipasudorunasgroupcategory,omitempty"`
  
    /*
Sudo order
integer to order the Sudo rules
    */
    Sudoorder *int `json:"sudoorder,omitempty"`
  
    /*
External User
External User the rule applies to (sudorule-find only)
    */
    Externaluser *string `json:"externaluser,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
RunAs External User
External User the commands can run as (sudorule-find only)
    */
    Ipasudorunasextuser *string `json:"ipasudorunasextuser,omitempty"`
  
    /*
RunAs External Group
External Group the commands can run as (sudorule-find only)
    */
    Ipasudorunasextgroup *string `json:"ipasudorunasextgroup,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the sudo rule object
    */
    Rename *string `json:"rename,omitempty"`
  }

type sudoruleModKwParams struct {
  *SudoruleModArgs
  *SudoruleModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleModResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleModResult `json:"result"`
}
type SudoruleModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Sudorule `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SudoruleModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleModResult%v", string(b))
}

/*
Remove commands and sudo command groups affected by Sudo Rule.
*/
func (c *Client) SudoruleRemoveAllowCommand(
  reqArgs *SudoruleRemoveAllowCommandArgs,
  optArgs *SudoruleRemoveAllowCommandOptionalArgs, // can be nil
) (*SudoruleRemoveAllowCommandResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveAllowCommandKwParams{
    SudoruleRemoveAllowCommandArgs: reqArgs,
    SudoruleRemoveAllowCommandOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_allow_command",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveAllowCommandResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveAllowCommandArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveAllowCommandOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to remove
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  
    /*
member sudo command group
sudo command groups to remove
    */
    Sudocmdgroup *[]string `json:"sudocmdgroup,omitempty"`
  }

type sudoruleRemoveAllowCommandKwParams struct {
  *SudoruleRemoveAllowCommandArgs
  *SudoruleRemoveAllowCommandOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveAllowCommandResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveAllowCommandResult `json:"result"`
}
type SudoruleRemoveAllowCommandResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleRemoveAllowCommandResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveAllowCommandResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveAllowCommandResult%v", string(b))
}

/*
Remove commands and sudo command groups affected by Sudo Rule.
*/
func (c *Client) SudoruleRemoveDenyCommand(
  reqArgs *SudoruleRemoveDenyCommandArgs,
  optArgs *SudoruleRemoveDenyCommandOptionalArgs, // can be nil
) (*SudoruleRemoveDenyCommandResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveDenyCommandKwParams{
    SudoruleRemoveDenyCommandArgs: reqArgs,
    SudoruleRemoveDenyCommandOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_deny_command",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveDenyCommandResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveDenyCommandArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveDenyCommandOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member sudo command
sudo commands to remove
    */
    Sudocmd *[]string `json:"sudocmd,omitempty"`
  
    /*
member sudo command group
sudo command groups to remove
    */
    Sudocmdgroup *[]string `json:"sudocmdgroup,omitempty"`
  }

type sudoruleRemoveDenyCommandKwParams struct {
  *SudoruleRemoveDenyCommandArgs
  *SudoruleRemoveDenyCommandOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveDenyCommandResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveDenyCommandResult `json:"result"`
}
type SudoruleRemoveDenyCommandResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleRemoveDenyCommandResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveDenyCommandResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveDenyCommandResult%v", string(b))
}

/*
Remove hosts and hostgroups affected by Sudo Rule.
*/
func (c *Client) SudoruleRemoveHost(
  reqArgs *SudoruleRemoveHostArgs,
  optArgs *SudoruleRemoveHostOptionalArgs, // can be nil
) (*SudoruleRemoveHostResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveHostKwParams{
    SudoruleRemoveHostArgs: reqArgs,
    SudoruleRemoveHostOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_host",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveHostResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveHostArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveHostOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member host
hosts to remove
    */
    Host *[]string `json:"host,omitempty"`
  
    /*
member host group
host groups to remove
    */
    Hostgroup *[]string `json:"hostgroup,omitempty"`
  
    /*
host masks of allowed hosts

    */
    Hostmask *[]string `json:"hostmask,omitempty"`
  }

type sudoruleRemoveHostKwParams struct {
  *SudoruleRemoveHostArgs
  *SudoruleRemoveHostOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveHostResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveHostResult `json:"result"`
}
type SudoruleRemoveHostResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleRemoveHostResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveHostResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveHostResult%v", string(b))
}

/*
Remove an option from Sudo Rule.
*/
func (c *Client) SudoruleRemoveOption(
  reqArgs *SudoruleRemoveOptionArgs,
  optArgs *SudoruleRemoveOptionOptionalArgs, // can be nil
) (*SudoruleRemoveOptionResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveOptionKwParams{
    SudoruleRemoveOptionArgs: reqArgs,
    SudoruleRemoveOptionOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_option",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveOptionResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveOptionArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Sudo Option

    */
    Ipasudoopt string `json:"ipasudoopt,omitempty"`
  }

type SudoruleRemoveOptionOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudoruleRemoveOptionKwParams struct {
  *SudoruleRemoveOptionArgs
  *SudoruleRemoveOptionOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveOptionResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveOptionResult `json:"result"`
}
type SudoruleRemoveOptionResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SudoruleRemoveOptionResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveOptionResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveOptionResult%v", string(b))
}

/*
Remove group for Sudo to execute as.
*/
func (c *Client) SudoruleRemoveRunasgroup(
  reqArgs *SudoruleRemoveRunasgroupArgs,
  optArgs *SudoruleRemoveRunasgroupOptionalArgs, // can be nil
) (*SudoruleRemoveRunasgroupResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveRunasgroupKwParams{
    SudoruleRemoveRunasgroupArgs: reqArgs,
    SudoruleRemoveRunasgroupOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_runasgroup",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveRunasgroupResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveRunasgroupArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveRunasgroupOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleRemoveRunasgroupKwParams struct {
  *SudoruleRemoveRunasgroupArgs
  *SudoruleRemoveRunasgroupOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveRunasgroupResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveRunasgroupResult `json:"result"`
}
type SudoruleRemoveRunasgroupResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleRemoveRunasgroupResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveRunasgroupResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveRunasgroupResult%v", string(b))
}

/*
Remove users and groups for Sudo to execute as.
*/
func (c *Client) SudoruleRemoveRunasuser(
  reqArgs *SudoruleRemoveRunasuserArgs,
  optArgs *SudoruleRemoveRunasuserOptionalArgs, // can be nil
) (*SudoruleRemoveRunasuserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveRunasuserKwParams{
    SudoruleRemoveRunasuserArgs: reqArgs,
    SudoruleRemoveRunasuserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_runasuser",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveRunasuserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveRunasuserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveRunasuserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleRemoveRunasuserKwParams struct {
  *SudoruleRemoveRunasuserArgs
  *SudoruleRemoveRunasuserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveRunasuserResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveRunasuserResult `json:"result"`
}
type SudoruleRemoveRunasuserResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleRemoveRunasuserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveRunasuserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveRunasuserResult%v", string(b))
}

/*
Remove users and groups affected by Sudo Rule.
*/
func (c *Client) SudoruleRemoveUser(
  reqArgs *SudoruleRemoveUserArgs,
  optArgs *SudoruleRemoveUserOptionalArgs, // can be nil
) (*SudoruleRemoveUserResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleRemoveUserKwParams{
    SudoruleRemoveUserArgs: reqArgs,
    SudoruleRemoveUserOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_remove_user",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleRemoveUserResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleRemoveUserArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleRemoveUserOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  }

type sudoruleRemoveUserKwParams struct {
  *SudoruleRemoveUserArgs
  *SudoruleRemoveUserOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleRemoveUserResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleRemoveUserResult `json:"result"`
}
type SudoruleRemoveUserResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *SudoruleRemoveUserResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleRemoveUserResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleRemoveUserResult%v", string(b))
}

/*
Display Sudo Rule.
*/
func (c *Client) SudoruleShow(
  reqArgs *SudoruleShowArgs,
  optArgs *SudoruleShowOptionalArgs, // can be nil
) (*SudoruleShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := sudoruleShowKwParams{
    SudoruleShowArgs: reqArgs,
    SudoruleShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "sudorule_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res sudoruleShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type SudoruleShowArgs struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  }

type SudoruleShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type sudoruleShowKwParams struct {
  *SudoruleShowArgs
  *SudoruleShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type sudoruleShowResponse struct {
	Error  *Error      `json:"error"`
	Result *SudoruleShowResult `json:"result"`
}
type SudoruleShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Sudorule `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *SudoruleShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("SudoruleShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("SudoruleShowResult%v", string(b))
}

/*
Search for help topics.
*/
func (c *Client) TopicFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *TopicFindArgs,
  optArgs *TopicFindOptionalArgs, // can be nil
) (*TopicFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topicFindKwParams{
    TopicFindArgs: reqArgs,
    TopicFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topic_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topicFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopicFindArgs struct {
  }

type TopicFindOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type topicFindKwParams struct {
  *TopicFindArgs
  *TopicFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topicFindResponse struct {
	Error  *Error      `json:"error"`
	Result *TopicFindResult `json:"result"`
}
type TopicFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Topic `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *TopicFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopicFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopicFindResult%v", string(b))
}

/*
Display information about a help topic.
*/
func (c *Client) TopicShow(
  reqArgs *TopicShowArgs,
  optArgs *TopicShowOptionalArgs, // can be nil
) (*TopicShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topicShowKwParams{
    TopicShowArgs: reqArgs,
    TopicShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topic_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topicShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopicShowArgs struct {
  
    /*
Full name

    */
    FullName string `json:"full_name,omitempty"`
  }

type TopicShowOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topicShowKwParams struct {
  *TopicShowArgs
  *TopicShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topicShowResponse struct {
	Error  *Error      `json:"error"`
	Result *TopicShowResult `json:"result"`
}
type TopicShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Topic `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TopicShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopicShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopicShowResult%v", string(b))
}

/*
Add a new segment.
*/
func (c *Client) TopologysegmentAdd(
  reqArgs *TopologysegmentAddArgs,
  optArgs *TopologysegmentAddOptionalArgs, // can be nil
) (*TopologysegmentAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentAddKwParams{
    TopologysegmentAddArgs: reqArgs,
    TopologysegmentAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentAddArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  
    /*
Left node
Left replication node - an IPA server
    */
    Iparepltoposegmentleftnode string `json:"iparepltoposegmentleftnode,omitempty"`
  
    /*
Right node
Right replication node - an IPA server
    */
    Iparepltoposegmentrightnode string `json:"iparepltoposegmentrightnode,omitempty"`
  }

type TopologysegmentAddOptionalArgs struct {
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Connectivity
Direction of replication between left and right replication node
    */
    Iparepltoposegmentdirection *string `json:"iparepltoposegmentdirection,omitempty"`
  
    /*
Attributes to strip
A space separated list of attributes which are removed from replication updates.
    */
    Nsds5replicastripattrs *string `json:"nsds5replicastripattrs,omitempty"`
  
    /*
Attributes to replicate
Attributes that are not replicated to a consumer server during a fractional update. E.g., `(objectclass=*) $ EXCLUDE accountlockout memberof
    */
    Nsds5replicatedattributelist *string `json:"nsds5replicatedattributelist,omitempty"`
  
    /*
Attributes for total update
Attributes that are not replicated to a consumer server during a total update. E.g. (objectclass=*) $ EXCLUDE accountlockout
    */
    Nsds5replicatedattributelisttotal *string `json:"nsds5replicatedattributelisttotal,omitempty"`
  
    /*
Session timeout
Number of seconds outbound LDAP operations waits for a response from the remote replica before timing out and failing
    */
    Nsds5replicatimeout *int `json:"nsds5replicatimeout,omitempty"`
  
    /*
Replication agreement enabled
Whether a replication agreement is active, meaning whether replication is occurring per that agreement
    */
    Nsds5replicaenabled *string `json:"nsds5replicaenabled,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysegmentAddKwParams struct {
  *TopologysegmentAddArgs
  *TopologysegmentAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentAddResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentAddResult `json:"result"`
}
type TopologysegmentAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Topologysegment `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TopologysegmentAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentAddResult%v", string(b))
}

/*
Delete a segment.
*/
func (c *Client) TopologysegmentDel(
  reqArgs *TopologysegmentDelArgs,
  optArgs *TopologysegmentDelOptionalArgs, // can be nil
) (*TopologysegmentDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentDelKwParams{
    TopologysegmentDelArgs: reqArgs,
    TopologysegmentDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentDelArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  }

type TopologysegmentDelOptionalArgs struct {
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn *[]string `json:"cn,omitempty"`
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type topologysegmentDelKwParams struct {
  *TopologysegmentDelArgs
  *TopologysegmentDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentDelResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentDelResult `json:"result"`
}
type TopologysegmentDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *TopologysegmentDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentDelResult%v", string(b))
}

/*
Search for topology segments.
*/
func (c *Client) TopologysegmentFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *TopologysegmentFindArgs,
  optArgs *TopologysegmentFindOptionalArgs, // can be nil
) (*TopologysegmentFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentFindKwParams{
    TopologysegmentFindArgs: reqArgs,
    TopologysegmentFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentFindArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  }

type TopologysegmentFindOptionalArgs struct {
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Left node
Left replication node - an IPA server
    */
    Iparepltoposegmentleftnode *string `json:"iparepltoposegmentleftnode,omitempty"`
  
    /*
Right node
Right replication node - an IPA server
    */
    Iparepltoposegmentrightnode *string `json:"iparepltoposegmentrightnode,omitempty"`
  
    /*
Connectivity
Direction of replication between left and right replication node
    */
    Iparepltoposegmentdirection *string `json:"iparepltoposegmentdirection,omitempty"`
  
    /*
Attributes to strip
A space separated list of attributes which are removed from replication updates.
    */
    Nsds5replicastripattrs *string `json:"nsds5replicastripattrs,omitempty"`
  
    /*
Attributes to replicate
Attributes that are not replicated to a consumer server during a fractional update. E.g., `(objectclass=*) $ EXCLUDE accountlockout memberof
    */
    Nsds5replicatedattributelist *string `json:"nsds5replicatedattributelist,omitempty"`
  
    /*
Attributes for total update
Attributes that are not replicated to a consumer server during a total update. E.g. (objectclass=*) $ EXCLUDE accountlockout
    */
    Nsds5replicatedattributelisttotal *string `json:"nsds5replicatedattributelisttotal,omitempty"`
  
    /*
Session timeout
Number of seconds outbound LDAP operations waits for a response from the remote replica before timing out and failing
    */
    Nsds5replicatimeout *int `json:"nsds5replicatimeout,omitempty"`
  
    /*
Replication agreement enabled
Whether a replication agreement is active, meaning whether replication is occurring per that agreement
    */
    Nsds5replicaenabled *string `json:"nsds5replicaenabled,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type topologysegmentFindKwParams struct {
  *TopologysegmentFindArgs
  *TopologysegmentFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentFindResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentFindResult `json:"result"`
}
type TopologysegmentFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Topologysegment `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *TopologysegmentFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentFindResult%v", string(b))
}

/*
Modify a segment.
*/
func (c *Client) TopologysegmentMod(
  reqArgs *TopologysegmentModArgs,
  optArgs *TopologysegmentModOptionalArgs, // can be nil
) (*TopologysegmentModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentModKwParams{
    TopologysegmentModArgs: reqArgs,
    TopologysegmentModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentModArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  }

type TopologysegmentModOptionalArgs struct {
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Attributes to strip
A space separated list of attributes which are removed from replication updates.
    */
    Nsds5replicastripattrs *string `json:"nsds5replicastripattrs,omitempty"`
  
    /*
Attributes to replicate
Attributes that are not replicated to a consumer server during a fractional update. E.g., `(objectclass=*) $ EXCLUDE accountlockout memberof
    */
    Nsds5replicatedattributelist *string `json:"nsds5replicatedattributelist,omitempty"`
  
    /*
Attributes for total update
Attributes that are not replicated to a consumer server during a total update. E.g. (objectclass=*) $ EXCLUDE accountlockout
    */
    Nsds5replicatedattributelisttotal *string `json:"nsds5replicatedattributelisttotal,omitempty"`
  
    /*
Session timeout
Number of seconds outbound LDAP operations waits for a response from the remote replica before timing out and failing
    */
    Nsds5replicatimeout *int `json:"nsds5replicatimeout,omitempty"`
  
    /*
Replication agreement enabled
Whether a replication agreement is active, meaning whether replication is occurring per that agreement
    */
    Nsds5replicaenabled *string `json:"nsds5replicaenabled,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysegmentModKwParams struct {
  *TopologysegmentModArgs
  *TopologysegmentModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentModResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentModResult `json:"result"`
}
type TopologysegmentModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Topologysegment `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TopologysegmentModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentModResult%v", string(b))
}

/*
Request a full re-initialization of the node retrieving data from the other node.
*/
func (c *Client) TopologysegmentReinitialize(
  reqArgs *TopologysegmentReinitializeArgs,
  optArgs *TopologysegmentReinitializeOptionalArgs, // can be nil
) (*TopologysegmentReinitializeResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentReinitializeKwParams{
    TopologysegmentReinitializeArgs: reqArgs,
    TopologysegmentReinitializeOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_reinitialize",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentReinitializeResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentReinitializeArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  }

type TopologysegmentReinitializeOptionalArgs struct {
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn *string `json:"cn,omitempty"`
  
    /*

Initialize left node
    */
    Left *bool `json:"left,omitempty"`
  
    /*

Initialize right node
    */
    Right *bool `json:"right,omitempty"`
  
    /*

Stop already started refresh of chosen node(s)
    */
    Stop *bool `json:"stop,omitempty"`
  }

type topologysegmentReinitializeKwParams struct {
  *TopologysegmentReinitializeArgs
  *TopologysegmentReinitializeOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentReinitializeResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentReinitializeResult `json:"result"`
}
type TopologysegmentReinitializeResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TopologysegmentReinitializeResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentReinitializeResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentReinitializeResult%v", string(b))
}

/*
Display a segment.
*/
func (c *Client) TopologysegmentShow(
  reqArgs *TopologysegmentShowArgs,
  optArgs *TopologysegmentShowOptionalArgs, // can be nil
) (*TopologysegmentShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysegmentShowKwParams{
    TopologysegmentShowArgs: reqArgs,
    TopologysegmentShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysegment_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysegmentShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysegmentShowArgs struct {
  
    /*
Suffix name

    */
    Topologysuffixcn string `json:"topologysuffixcn,omitempty"`
  }

type TopologysegmentShowOptionalArgs struct {
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysegmentShowKwParams struct {
  *TopologysegmentShowArgs
  *TopologysegmentShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysegmentShowResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysegmentShowResult `json:"result"`
}
type TopologysegmentShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Topologysegment `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TopologysegmentShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysegmentShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysegmentShowResult%v", string(b))
}

/*
Add a new topology suffix to be managed.
*/
func (c *Client) TopologysuffixAdd(
  reqArgs *TopologysuffixAddArgs,
  optArgs *TopologysuffixAddOptionalArgs, // can be nil
) (*TopologysuffixAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixAddKwParams{
    TopologysuffixAddArgs: reqArgs,
    TopologysuffixAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixAddArgs struct {
  
    /*
Suffix name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Managed LDAP suffix DN

    */
    Iparepltopoconfroot string `json:"iparepltopoconfroot,omitempty"`
  }

type TopologysuffixAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysuffixAddKwParams struct {
  *TopologysuffixAddArgs
  *TopologysuffixAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixAddResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixAddResult `json:"result"`
}
type TopologysuffixAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Topologysuffix `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TopologysuffixAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixAddResult%v", string(b))
}

/*
Delete a topology suffix.
*/
func (c *Client) TopologysuffixDel(
  reqArgs *TopologysuffixDelArgs,
  optArgs *TopologysuffixDelOptionalArgs, // can be nil
) (*TopologysuffixDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixDelKwParams{
    TopologysuffixDelArgs: reqArgs,
    TopologysuffixDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixDelArgs struct {
  
    /*
Suffix name

    */
    Cn []string `json:"cn,omitempty"`
  }

type TopologysuffixDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type topologysuffixDelKwParams struct {
  *TopologysuffixDelArgs
  *TopologysuffixDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixDelResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixDelResult `json:"result"`
}
type TopologysuffixDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *TopologysuffixDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixDelResult%v", string(b))
}

/*
Search for topology suffixes.
*/
func (c *Client) TopologysuffixFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *TopologysuffixFindArgs,
  optArgs *TopologysuffixFindOptionalArgs, // can be nil
) (*TopologysuffixFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixFindKwParams{
    TopologysuffixFindArgs: reqArgs,
    TopologysuffixFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixFindArgs struct {
  }

type TopologysuffixFindOptionalArgs struct {
  
    /*
Suffix name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Managed LDAP suffix DN

    */
    Iparepltopoconfroot *string `json:"iparepltopoconfroot,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type topologysuffixFindKwParams struct {
  *TopologysuffixFindArgs
  *TopologysuffixFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixFindResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixFindResult `json:"result"`
}
type TopologysuffixFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Topologysuffix `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *TopologysuffixFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixFindResult%v", string(b))
}

/*
Modify a topology suffix.
*/
func (c *Client) TopologysuffixMod(
  reqArgs *TopologysuffixModArgs,
  optArgs *TopologysuffixModOptionalArgs, // can be nil
) (*TopologysuffixModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixModKwParams{
    TopologysuffixModArgs: reqArgs,
    TopologysuffixModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixModArgs struct {
  
    /*
Suffix name

    */
    Cn string `json:"cn,omitempty"`
  }

type TopologysuffixModOptionalArgs struct {
  
    /*
Managed LDAP suffix DN

    */
    Iparepltopoconfroot *string `json:"iparepltopoconfroot,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysuffixModKwParams struct {
  *TopologysuffixModArgs
  *TopologysuffixModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixModResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixModResult `json:"result"`
}
type TopologysuffixModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Topologysuffix `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TopologysuffixModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixModResult%v", string(b))
}

/*
Show managed suffix.
*/
func (c *Client) TopologysuffixShow(
  reqArgs *TopologysuffixShowArgs,
  optArgs *TopologysuffixShowOptionalArgs, // can be nil
) (*TopologysuffixShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixShowKwParams{
    TopologysuffixShowArgs: reqArgs,
    TopologysuffixShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixShowArgs struct {
  
    /*
Suffix name

    */
    Cn string `json:"cn,omitempty"`
  }

type TopologysuffixShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type topologysuffixShowKwParams struct {
  *TopologysuffixShowArgs
  *TopologysuffixShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixShowResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixShowResult `json:"result"`
}
type TopologysuffixShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Topologysuffix `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TopologysuffixShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixShowResult%v", string(b))
}

/*
Verify replication topology for suffix.

Checks done:
  1. check if a topology is not disconnected. In other words if there are
     replication paths between all servers.
  2. check if servers don't have more than the recommended number of
     replication agreements
*/
func (c *Client) TopologysuffixVerify(
  reqArgs *TopologysuffixVerifyArgs,
  optArgs *TopologysuffixVerifyOptionalArgs, // can be nil
) (*TopologysuffixVerifyResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := topologysuffixVerifyKwParams{
    TopologysuffixVerifyArgs: reqArgs,
    TopologysuffixVerifyOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "topologysuffix_verify",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res topologysuffixVerifyResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TopologysuffixVerifyArgs struct {
  
    /*
Suffix name

    */
    Cn string `json:"cn,omitempty"`
  }

type TopologysuffixVerifyOptionalArgs struct {
  }

type topologysuffixVerifyKwParams struct {
  *TopologysuffixVerifyArgs
  *TopologysuffixVerifyOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type topologysuffixVerifyResponse struct {
	Error  *Error      `json:"error"`
	Result *TopologysuffixVerifyResult `json:"result"`
}
type TopologysuffixVerifyResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  }

func (t *TopologysuffixVerifyResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TopologysuffixVerifyResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TopologysuffixVerifyResult%v", string(b))
}

/*
Add new trust to use.

This command establishes trust relationship to another domain
which becomes 'trusted'. As result, users of the trusted domain
may access resources of this domain.

Only trusts to Active Directory domains are supported right now.

The command can be safely run multiple times against the same domain,
this will cause change to trust relationship credentials on both
sides.

Note that if the command was previously run with a specific range type,
or with automatic detection of the range type, and you want to configure a
different range type, you may need to delete first the ID range using
ipa idrange-del before retrying the command with the desired range type.
*/
func (c *Client) TrustAdd(
  reqArgs *TrustAddArgs,
  optArgs *TrustAddOptionalArgs, // can be nil
) (*TrustAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustAddKwParams{
    TrustAddArgs: reqArgs,
    TrustAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustAddArgs struct {
  
    /*
Realm name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustAddOptionalArgs struct {
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Trust type (ad for Active Directory, default)

    */
    TrustType *string `json:"trust_type,omitempty"`
  
    /*
Active Directory domain administrator

    */
    RealmAdmin *string `json:"realm_admin,omitempty"`
  
    /*
Active Directory domain administrator's password

    */
    RealmPasswd *string `json:"realm_passwd,omitempty"`
  
    /*
Domain controller for the Active Directory domain (optional)

    */
    RealmServer *string `json:"realm_server,omitempty"`
  
    /*
Shared secret for the trust

    */
    TrustSecret *string `json:"trust_secret,omitempty"`
  
    /*
First Posix ID of the range reserved for the trusted domain

    */
    BaseID *int `json:"base_id,omitempty"`
  
    /*
Size of the ID range reserved for the trusted domain

    */
    RangeSize *int `json:"range_size,omitempty"`
  
    /*
Range type
Type of trusted domain ID range, one of ipa-ad-trust, ipa-ad-trust-posix
    */
    RangeType *string `json:"range_type,omitempty"`
  
    /*
Two-way trust
Establish bi-directional trust. By default trust is inbound one-way only.
    */
    Bidirectional *bool `json:"bidirectional,omitempty"`
  
    /*
External trust
Establish external trust to a domain in another forest. The trust is not transitive beyond the domain.
    */
    External *bool `json:"external,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustAddKwParams struct {
  *TrustAddArgs
  *TrustAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustAddResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustAddResult `json:"result"`
}
type TrustAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Trust `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TrustAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustAddResult%v", string(b))
}

/*
Delete a trust.
*/
func (c *Client) TrustDel(
  reqArgs *TrustDelArgs,
  optArgs *TrustDelOptionalArgs, // can be nil
) (*TrustDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustDelKwParams{
    TrustDelArgs: reqArgs,
    TrustDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustDelArgs struct {
  
    /*
Realm name

    */
    Cn []string `json:"cn,omitempty"`
  }

type TrustDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type trustDelKwParams struct {
  *TrustDelArgs
  *TrustDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustDelResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustDelResult `json:"result"`
}
type TrustDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *TrustDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustDelResult%v", string(b))
}

/*
Configure this server as a trust agent.
*/
func (c *Client) TrustEnableAgent(
  reqArgs *TrustEnableAgentArgs,
  optArgs *TrustEnableAgentOptionalArgs, // can be nil
) (*TrustEnableAgentResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustEnableAgentKwParams{
    TrustEnableAgentArgs: reqArgs,
    TrustEnableAgentOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_enable_agent",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustEnableAgentResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustEnableAgentArgs struct {
  
    /*
Remote server name
Remote IPA server hostname
    */
    RemoteCn string `json:"remote_cn,omitempty"`
  }

type TrustEnableAgentOptionalArgs struct {
  
    /*

Enable support for trusted domains for old clients
    */
    EnableCompat *bool `json:"enable_compat,omitempty"`
  }

type trustEnableAgentKwParams struct {
  *TrustEnableAgentArgs
  *TrustEnableAgentOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustEnableAgentResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustEnableAgentResult `json:"result"`
}
type TrustEnableAgentResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *TrustEnableAgentResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustEnableAgentResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustEnableAgentResult%v", string(b))
}

/*
Refresh list of the domains associated with the trust
*/
func (c *Client) TrustFetchDomains(
  reqArgs *TrustFetchDomainsArgs,
  optArgs *TrustFetchDomainsOptionalArgs, // can be nil
) (*TrustFetchDomainsResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustFetchDomainsKwParams{
    TrustFetchDomainsArgs: reqArgs,
    TrustFetchDomainsOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_fetch_domains",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustFetchDomainsResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustFetchDomainsArgs struct {
  
    /*
Realm name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustFetchDomainsOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Active Directory domain administrator

    */
    RealmAdmin *string `json:"realm_admin,omitempty"`
  
    /*
Active Directory domain administrator's password

    */
    RealmPasswd *string `json:"realm_passwd,omitempty"`
  
    /*
Domain controller for the Active Directory domain (optional)

    */
    RealmServer *string `json:"realm_server,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustFetchDomainsKwParams struct {
  *TrustFetchDomainsArgs
  *TrustFetchDomainsOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustFetchDomainsResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustFetchDomainsResult `json:"result"`
}
type TrustFetchDomainsResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []interface{} `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *TrustFetchDomainsResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustFetchDomainsResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustFetchDomainsResult%v", string(b))
}

/*
Search for trusts.
*/
func (c *Client) TrustFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *TrustFindArgs,
  optArgs *TrustFindOptionalArgs, // can be nil
) (*TrustFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustFindKwParams{
    TrustFindArgs: reqArgs,
    TrustFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustFindArgs struct {
  }

type TrustFindOptionalArgs struct {
  
    /*
Realm name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Domain NetBIOS name

    */
    Ipantflatname *string `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
SID blacklist incoming

    */
    Ipantsidblacklistincoming *[]string `json:"ipantsidblacklistincoming,omitempty"`
  
    /*
SID blacklist outgoing

    */
    Ipantsidblacklistoutgoing *[]string `json:"ipantsidblacklistoutgoing,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("realm")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type trustFindKwParams struct {
  *TrustFindArgs
  *TrustFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustFindResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustFindResult `json:"result"`
}
type TrustFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Trust `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *TrustFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustFindResult%v", string(b))
}

/*
Modify a trust (for future use).

    Currently only the default option to modify the LDAP attributes is
    available. More specific options will be added in coming releases.
*/
func (c *Client) TrustMod(
  reqArgs *TrustModArgs,
  optArgs *TrustModOptionalArgs, // can be nil
) (*TrustModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustModKwParams{
    TrustModArgs: reqArgs,
    TrustModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustModArgs struct {
  
    /*
Realm name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustModOptionalArgs struct {
  
    /*
SID blacklist incoming

    */
    Ipantsidblacklistincoming *[]string `json:"ipantsidblacklistincoming,omitempty"`
  
    /*
SID blacklist outgoing

    */
    Ipantsidblacklistoutgoing *[]string `json:"ipantsidblacklistoutgoing,omitempty"`
  
    /*
UPN suffixes

    */
    Ipantadditionalsuffixes *[]string `json:"ipantadditionalsuffixes,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustModKwParams struct {
  *TrustModArgs
  *TrustModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustModResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustModResult `json:"result"`
}
type TrustModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Trust `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TrustModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustModResult%v", string(b))
}

/*
Resolve security identifiers of users and groups in trusted domains
*/
func (c *Client) TrustResolve(
  reqArgs *TrustResolveArgs,
  optArgs *TrustResolveOptionalArgs, // can be nil
) (*TrustResolveResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustResolveKwParams{
    TrustResolveArgs: reqArgs,
    TrustResolveOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_resolve",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustResolveResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustResolveArgs struct {
  
    /*
Security Identifiers (SIDs)

    */
    Sids []string `json:"sids,omitempty"`
  }

type TrustResolveOptionalArgs struct {
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustResolveKwParams struct {
  *TrustResolveArgs
  *TrustResolveOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustResolveResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustResolveResult `json:"result"`
}
type TrustResolveResult struct {
  
  
  
    /*

    (required)
    */
    
    Result []interface{} `json:"result,omitempty"`
    
  }

func (t *TrustResolveResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustResolveResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustResolveResult%v", string(b))
}

/*
Display information about a trust.
*/
func (c *Client) TrustShow(
  reqArgs *TrustShowArgs,
  optArgs *TrustShowOptionalArgs, // can be nil
) (*TrustShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustShowKwParams{
    TrustShowArgs: reqArgs,
    TrustShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trust_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustShowArgs struct {
  
    /*
Realm name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustShowKwParams struct {
  *TrustShowArgs
  *TrustShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustShowResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustShowResult `json:"result"`
}
type TrustShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Trust `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TrustShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustShowResult%v", string(b))
}

/*
Modify global trust configuration.
*/
func (c *Client) TrustconfigMod(
  reqArgs *TrustconfigModArgs,
  optArgs *TrustconfigModOptionalArgs, // can be nil
) (*TrustconfigModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustconfigModKwParams{
    TrustconfigModArgs: reqArgs,
    TrustconfigModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustconfig_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustconfigModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustconfigModArgs struct {
  }

type TrustconfigModOptionalArgs struct {
  
    /*
Fallback primary group

    */
    Ipantfallbackprimarygroup *string `json:"ipantfallbackprimarygroup,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Trust type (ad for Active Directory, default)

    */
    TrustType *string `json:"trust_type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustconfigModKwParams struct {
  *TrustconfigModArgs
  *TrustconfigModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustconfigModResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustconfigModResult `json:"result"`
}
type TrustconfigModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Trustconfig `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TrustconfigModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustconfigModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustconfigModResult%v", string(b))
}

/*
Show global trust configuration.
*/
func (c *Client) TrustconfigShow(
  reqArgs *TrustconfigShowArgs,
  optArgs *TrustconfigShowOptionalArgs, // can be nil
) (*TrustconfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustconfigShowKwParams{
    TrustconfigShowArgs: reqArgs,
    TrustconfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustconfig_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustconfigShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustconfigShowArgs struct {
  }

type TrustconfigShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Trust type (ad for Active Directory, default)

    */
    TrustType *string `json:"trust_type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustconfigShowKwParams struct {
  *TrustconfigShowArgs
  *TrustconfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustconfigShowResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustconfigShowResult `json:"result"`
}
type TrustconfigShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Trustconfig `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TrustconfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustconfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustconfigShowResult%v", string(b))
}

/*
Allow access from the trusted domain
*/
func (c *Client) TrustdomainAdd(
  reqArgs *TrustdomainAddArgs,
  optArgs *TrustdomainAddOptionalArgs, // can be nil
) (*TrustdomainAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainAddKwParams{
    TrustdomainAddArgs: reqArgs,
    TrustdomainAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainAddArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  
    /*
Domain name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustdomainAddOptionalArgs struct {
  
    /*
Domain NetBIOS name

    */
    Ipantflatname *string `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*
Trust type (ad for Active Directory, default)

    */
    TrustType *string `json:"trust_type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustdomainAddKwParams struct {
  *TrustdomainAddArgs
  *TrustdomainAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainAddResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainAddResult `json:"result"`
}
type TrustdomainAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Trustdomain `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TrustdomainAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainAddResult%v", string(b))
}

/*
Remove information about the domain associated with the trust.
*/
func (c *Client) TrustdomainDel(
  reqArgs *TrustdomainDelArgs,
  optArgs *TrustdomainDelOptionalArgs, // can be nil
) (*TrustdomainDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainDelKwParams{
    TrustdomainDelArgs: reqArgs,
    TrustdomainDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainDelArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  
    /*
Domain name

    */
    Cn []string `json:"cn,omitempty"`
  }

type TrustdomainDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type trustdomainDelKwParams struct {
  *TrustdomainDelArgs
  *TrustdomainDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainDelResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainDelResult `json:"result"`
}
type TrustdomainDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *TrustdomainDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainDelResult%v", string(b))
}

/*
Disable use of IPA resources by the domain of the trust
*/
func (c *Client) TrustdomainDisable(
  reqArgs *TrustdomainDisableArgs,
  optArgs *TrustdomainDisableOptionalArgs, // can be nil
) (*TrustdomainDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainDisableKwParams{
    TrustdomainDisableArgs: reqArgs,
    TrustdomainDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainDisableArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  
    /*
Domain name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustdomainDisableOptionalArgs struct {
  }

type trustdomainDisableKwParams struct {
  *TrustdomainDisableArgs
  *TrustdomainDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainDisableResult `json:"result"`
}
type TrustdomainDisableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TrustdomainDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainDisableResult%v", string(b))
}

/*
Allow use of IPA resources by the domain of the trust
*/
func (c *Client) TrustdomainEnable(
  reqArgs *TrustdomainEnableArgs,
  optArgs *TrustdomainEnableOptionalArgs, // can be nil
) (*TrustdomainEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainEnableKwParams{
    TrustdomainEnableArgs: reqArgs,
    TrustdomainEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_enable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainEnableArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  
    /*
Domain name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustdomainEnableOptionalArgs struct {
  }

type trustdomainEnableKwParams struct {
  *TrustdomainEnableArgs
  *TrustdomainEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainEnableResult `json:"result"`
}
type TrustdomainEnableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TrustdomainEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainEnableResult%v", string(b))
}

/*
Search domains of the trust
*/
func (c *Client) TrustdomainFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *TrustdomainFindArgs,
  optArgs *TrustdomainFindOptionalArgs, // can be nil
) (*TrustdomainFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainFindKwParams{
    TrustdomainFindArgs: reqArgs,
    TrustdomainFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainFindArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  }

type TrustdomainFindOptionalArgs struct {
  
    /*
Domain name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Domain NetBIOS name

    */
    Ipantflatname *string `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("domain")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type trustdomainFindKwParams struct {
  *TrustdomainFindArgs
  *TrustdomainFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainFindResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainFindResult `json:"result"`
}
type TrustdomainFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Trustdomain `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *TrustdomainFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainFindResult%v", string(b))
}

/*
Modify trustdomain of the trust
*/
func (c *Client) TrustdomainMod(
  reqArgs *TrustdomainModArgs,
  optArgs *TrustdomainModOptionalArgs, // can be nil
) (*TrustdomainModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := trustdomainModKwParams{
    TrustdomainModArgs: reqArgs,
    TrustdomainModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "trustdomain_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res trustdomainModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type TrustdomainModArgs struct {
  
    /*
Realm name

    */
    Trustcn string `json:"trustcn,omitempty"`
  
    /*
Domain name

    */
    Cn string `json:"cn,omitempty"`
  }

type TrustdomainModOptionalArgs struct {
  
    /*
Domain NetBIOS name

    */
    Ipantflatname *string `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*
Trust type (ad for Active Directory, default)

    */
    TrustType *string `json:"trust_type,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type trustdomainModKwParams struct {
  *TrustdomainModArgs
  *TrustdomainModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type trustdomainModResponse struct {
	Error  *Error      `json:"error"`
	Result *TrustdomainModResult `json:"result"`
}
type TrustdomainModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Trustdomain `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *TrustdomainModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("TrustdomainModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("TrustdomainModResult%v", string(b))
}

/*
Add a new user.
*/
func (c *Client) UserAdd(
  reqArgs *UserAddArgs,
  optArgs *UserAddOptionalArgs, // can be nil
) (*UserAddResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userAddKwParams{
    UserAddArgs: reqArgs,
    UserAddOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_add",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userAddResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserAddArgs struct {
  
    /*
First name

    */
    Givenname string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn string `json:"sn,omitempty"`
  }

type UserAddOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *bool `json:"random,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Account disabled

    */
    Nsaccountlock *bool `json:"nsaccountlock,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Don't create user private group
    */
    Noprivate *bool `json:"noprivate,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userAddKwParams struct {
  *UserAddArgs
  *UserAddOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userAddResponse struct {
	Error  *Error      `json:"error"`
	Result *UserAddResult `json:"result"`
}
type UserAddResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result User `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserAddResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserAddResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserAddResult%v", string(b))
}

/*
Add one or more certificates to the user entry
*/
func (c *Client) UserAddCert(
  reqArgs *UserAddCertArgs,
  optArgs *UserAddCertOptionalArgs, // can be nil
) (*UserAddCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userAddCertKwParams{
    UserAddCertArgs: reqArgs,
    UserAddCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_add_cert",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userAddCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserAddCertArgs struct {
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type UserAddCertOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userAddCertKwParams struct {
  *UserAddCertArgs
  *UserAddCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userAddCertResponse struct {
	Error  *Error      `json:"error"`
	Result *UserAddCertResult `json:"result"`
}
type UserAddCertResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserAddCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserAddCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserAddCertResult%v", string(b))
}

/*
Add one or more certificate mappings to the user entry.
*/
func (c *Client) UserAddCertmapdata(
  ipacertmapdata string, // Certificate mapping data
  reqArgs *UserAddCertmapdataArgs,
  optArgs *UserAddCertmapdataOptionalArgs, // can be nil
) (*UserAddCertmapdataResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userAddCertmapdataKwParams{
    UserAddCertmapdataArgs: reqArgs,
    UserAddCertmapdataOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_add_certmapdata",
    Params: []interface{}{
      []interface{}{ipacertmapdata, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userAddCertmapdataResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserAddCertmapdataArgs struct {
  }

type UserAddCertmapdataOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Issuer
Issuer of the certificate
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Subject
Subject of the certificate
    */
    Subject *string `json:"subject,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Certificate *[]interface{} `json:"certificate,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userAddCertmapdataKwParams struct {
  *UserAddCertmapdataArgs
  *UserAddCertmapdataOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userAddCertmapdataResponse struct {
	Error  *Error      `json:"error"`
	Result *UserAddCertmapdataResult `json:"result"`
}
type UserAddCertmapdataResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserAddCertmapdataResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserAddCertmapdataResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserAddCertmapdataResult%v", string(b))
}

/*
Add a manager to the user entry
*/
func (c *Client) UserAddManager(
  reqArgs *UserAddManagerArgs,
  optArgs *UserAddManagerOptionalArgs, // can be nil
) (*UserAddManagerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userAddManagerKwParams{
    UserAddManagerArgs: reqArgs,
    UserAddManagerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_add_manager",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userAddManagerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserAddManagerArgs struct {
  }

type UserAddManagerOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  }

type userAddManagerKwParams struct {
  *UserAddManagerArgs
  *UserAddManagerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userAddManagerResponse struct {
	Error  *Error      `json:"error"`
	Result *UserAddManagerResult `json:"result"`
}
type UserAddManagerResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *UserAddManagerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserAddManagerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserAddManagerResult%v", string(b))
}

/*
Add new principal alias to the user entry
*/
func (c *Client) UserAddPrincipal(
  reqArgs *UserAddPrincipalArgs,
  optArgs *UserAddPrincipalOptionalArgs, // can be nil
) (*UserAddPrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userAddPrincipalKwParams{
    UserAddPrincipalArgs: reqArgs,
    UserAddPrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_add_principal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userAddPrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserAddPrincipalArgs struct {
  }

type UserAddPrincipalOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userAddPrincipalKwParams struct {
  *UserAddPrincipalArgs
  *UserAddPrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userAddPrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *UserAddPrincipalResult `json:"result"`
}
type UserAddPrincipalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserAddPrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserAddPrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserAddPrincipalResult%v", string(b))
}

/*
Delete a user.
*/
func (c *Client) UserDel(
  reqArgs *UserDelArgs,
  optArgs *UserDelOptionalArgs, // can be nil
) (*UserDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userDelKwParams{
    UserDelArgs: reqArgs,
    UserDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserDelArgs struct {
  }

type UserDelOptionalArgs struct {
  
    /*
User login

    */
    UID *[]string `json:"uid,omitempty"`
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*


    */
    Preserve *bool `json:"preserve,omitempty"`
  }

type userDelKwParams struct {
  *UserDelArgs
  *UserDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userDelResponse struct {
	Error  *Error      `json:"error"`
	Result *UserDelResult `json:"result"`
}
type UserDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *UserDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserDelResult%v", string(b))
}

/*
Disable a user account.
*/
func (c *Client) UserDisable(
  reqArgs *UserDisableArgs,
  optArgs *UserDisableOptionalArgs, // can be nil
) (*UserDisableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userDisableKwParams{
    UserDisableArgs: reqArgs,
    UserDisableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_disable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userDisableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserDisableArgs struct {
  }

type UserDisableOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  }

type userDisableKwParams struct {
  *UserDisableArgs
  *UserDisableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userDisableResponse struct {
	Error  *Error      `json:"error"`
	Result *UserDisableResult `json:"result"`
}
type UserDisableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserDisableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserDisableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserDisableResult%v", string(b))
}

/*
Enable a user account.
*/
func (c *Client) UserEnable(
  reqArgs *UserEnableArgs,
  optArgs *UserEnableOptionalArgs, // can be nil
) (*UserEnableResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userEnableKwParams{
    UserEnableArgs: reqArgs,
    UserEnableOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_enable",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userEnableResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserEnableArgs struct {
  }

type UserEnableOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  }

type userEnableKwParams struct {
  *UserEnableArgs
  *UserEnableOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userEnableResponse struct {
	Error  *Error      `json:"error"`
	Result *UserEnableResult `json:"result"`
}
type UserEnableResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserEnableResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserEnableResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserEnableResult%v", string(b))
}

/*
Search for users.
*/
func (c *Client) UserFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *UserFindArgs,
  optArgs *UserFindOptionalArgs, // can be nil
) (*UserFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userFindKwParams{
    UserFindArgs: reqArgs,
    UserFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserFindArgs struct {
  }

type UserFindOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
First name

    */
    Givenname *string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn *string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Account disabled

    */
    Nsaccountlock *bool `json:"nsaccountlock,omitempty"`
  
    /*
Preserved user

    */
    Preserved *bool `json:"preserved,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*
Self
Display user record for current Kerberos principal
    */
    Whoami *bool `json:"whoami,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("login")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  
    /*
group
Search for users with these member of groups.
    */
    InGroup *[]string `json:"in_group,omitempty"`
  
    /*
group
Search for users without these member of groups.
    */
    NotInGroup *[]string `json:"not_in_group,omitempty"`
  
    /*
netgroup
Search for users with these member of netgroups.
    */
    InNetgroup *[]string `json:"in_netgroup,omitempty"`
  
    /*
netgroup
Search for users without these member of netgroups.
    */
    NotInNetgroup *[]string `json:"not_in_netgroup,omitempty"`
  
    /*
role
Search for users with these member of roles.
    */
    InRole *[]string `json:"in_role,omitempty"`
  
    /*
role
Search for users without these member of roles.
    */
    NotInRole *[]string `json:"not_in_role,omitempty"`
  
    /*
HBAC rule
Search for users with these member of HBAC rules.
    */
    InHbacrule *[]string `json:"in_hbacrule,omitempty"`
  
    /*
HBAC rule
Search for users without these member of HBAC rules.
    */
    NotInHbacrule *[]string `json:"not_in_hbacrule,omitempty"`
  
    /*
sudo rule
Search for users with these member of sudo rules.
    */
    InSudorule *[]string `json:"in_sudorule,omitempty"`
  
    /*
sudo rule
Search for users without these member of sudo rules.
    */
    NotInSudorule *[]string `json:"not_in_sudorule,omitempty"`
  }

type userFindKwParams struct {
  *UserFindArgs
  *UserFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userFindResponse struct {
	Error  *Error      `json:"error"`
	Result *UserFindResult `json:"result"`
}
type UserFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []User `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *UserFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserFindResult%v", string(b))
}

/*
Modify a user.
*/
func (c *Client) UserMod(
  reqArgs *UserModArgs,
  optArgs *UserModOptionalArgs, // can be nil
) (*UserModResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userModKwParams{
    UserModArgs: reqArgs,
    UserModOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_mod",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userModResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserModArgs struct {
  }

type UserModOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
First name

    */
    Givenname *string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn *string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *bool `json:"random,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Account disabled

    */
    Nsaccountlock *bool `json:"nsaccountlock,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Rename
Rename the user object
    */
    Rename *string `json:"rename,omitempty"`
  }

type userModKwParams struct {
  *UserModArgs
  *UserModOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userModResponse struct {
	Error  *Error      `json:"error"`
	Result *UserModResult `json:"result"`
}
type UserModResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result User `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserModResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserModResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserModResult%v", string(b))
}

/*
Remove one or more certificates to the user entry
*/
func (c *Client) UserRemoveCert(
  reqArgs *UserRemoveCertArgs,
  optArgs *UserRemoveCertOptionalArgs, // can be nil
) (*UserRemoveCertResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userRemoveCertKwParams{
    UserRemoveCertArgs: reqArgs,
    UserRemoveCertOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_remove_cert",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userRemoveCertResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserRemoveCertArgs struct {
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate []interface{} `json:"usercertificate,omitempty"`
  }

type UserRemoveCertOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userRemoveCertKwParams struct {
  *UserRemoveCertArgs
  *UserRemoveCertOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userRemoveCertResponse struct {
	Error  *Error      `json:"error"`
	Result *UserRemoveCertResult `json:"result"`
}
type UserRemoveCertResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserRemoveCertResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserRemoveCertResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserRemoveCertResult%v", string(b))
}

/*
Remove one or more certificate mappings from the user entry.
*/
func (c *Client) UserRemoveCertmapdata(
  ipacertmapdata string, // Certificate mapping data
  reqArgs *UserRemoveCertmapdataArgs,
  optArgs *UserRemoveCertmapdataOptionalArgs, // can be nil
) (*UserRemoveCertmapdataResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userRemoveCertmapdataKwParams{
    UserRemoveCertmapdataArgs: reqArgs,
    UserRemoveCertmapdataOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_remove_certmapdata",
    Params: []interface{}{
      []interface{}{ipacertmapdata, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userRemoveCertmapdataResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserRemoveCertmapdataArgs struct {
  }

type UserRemoveCertmapdataOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Issuer
Issuer of the certificate
    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Subject
Subject of the certificate
    */
    Subject *string `json:"subject,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Certificate *[]interface{} `json:"certificate,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userRemoveCertmapdataKwParams struct {
  *UserRemoveCertmapdataArgs
  *UserRemoveCertmapdataOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userRemoveCertmapdataResponse struct {
	Error  *Error      `json:"error"`
	Result *UserRemoveCertmapdataResult `json:"result"`
}
type UserRemoveCertmapdataResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserRemoveCertmapdataResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserRemoveCertmapdataResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserRemoveCertmapdataResult%v", string(b))
}

/*
Remove a manager to the user entry
*/
func (c *Client) UserRemoveManager(
  reqArgs *UserRemoveManagerArgs,
  optArgs *UserRemoveManagerOptionalArgs, // can be nil
) (*UserRemoveManagerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userRemoveManagerKwParams{
    UserRemoveManagerArgs: reqArgs,
    UserRemoveManagerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_remove_manager",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userRemoveManagerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserRemoveManagerArgs struct {
  }

type UserRemoveManagerOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  }

type userRemoveManagerKwParams struct {
  *UserRemoveManagerArgs
  *UserRemoveManagerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userRemoveManagerResponse struct {
	Error  *Error      `json:"error"`
	Result *UserRemoveManagerResult `json:"result"`
}
type UserRemoveManagerResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *UserRemoveManagerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserRemoveManagerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserRemoveManagerResult%v", string(b))
}

/*
Remove principal alias from the user entry
*/
func (c *Client) UserRemovePrincipal(
  reqArgs *UserRemovePrincipalArgs,
  optArgs *UserRemovePrincipalOptionalArgs, // can be nil
) (*UserRemovePrincipalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userRemovePrincipalKwParams{
    UserRemovePrincipalArgs: reqArgs,
    UserRemovePrincipalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_remove_principal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userRemovePrincipalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserRemovePrincipalArgs struct {
  }

type UserRemovePrincipalOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userRemovePrincipalKwParams struct {
  *UserRemovePrincipalArgs
  *UserRemovePrincipalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userRemovePrincipalResponse struct {
	Error  *Error      `json:"error"`
	Result *UserRemovePrincipalResult `json:"result"`
}
type UserRemovePrincipalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserRemovePrincipalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserRemovePrincipalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserRemovePrincipalResult%v", string(b))
}

/*
Display information about a user.
*/
func (c *Client) UserShow(
  reqArgs *UserShowArgs,
  optArgs *UserShowOptionalArgs, // can be nil
) (*UserShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userShowKwParams{
    UserShowArgs: reqArgs,
    UserShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserShowArgs struct {
  }

type UserShowOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

file to store certificate in
    */
    Out *string `json:"out,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type userShowKwParams struct {
  *UserShowArgs
  *UserShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userShowResponse struct {
	Error  *Error      `json:"error"`
	Result *UserShowResult `json:"result"`
}
type UserShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result User `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserShowResult%v", string(b))
}

/*
Move deleted user into staged area
*/
func (c *Client) UserStage(
  reqArgs *UserStageArgs,
  optArgs *UserStageOptionalArgs, // can be nil
) (*UserStageResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userStageKwParams{
    UserStageArgs: reqArgs,
    UserStageOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_stage",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userStageResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserStageArgs struct {
  }

type UserStageOptionalArgs struct {
  
    /*
User login

    */
    UID *[]string `json:"uid,omitempty"`
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  }

type userStageKwParams struct {
  *UserStageArgs
  *UserStageOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userStageResponse struct {
	Error  *Error      `json:"error"`
	Result *UserStageResult `json:"result"`
}
type UserStageResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *UserStageResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserStageResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserStageResult%v", string(b))
}

/*
Lockout status of a user account

    An account may become locked if the password is entered incorrectly too
    many times within a specific time period as controlled by password
    policy. A locked account is a temporary condition and may be unlocked by
    an administrator.

    This connects to each IPA master and displays the lockout status on
    each one.

    To determine whether an account is locked on a given server you need
    to compare the number of failed logins and the time of the last failure.
    For an account to be locked it must exceed the maxfail failures within
    the failinterval duration as specified in the password policy associated
    with the user.

    The failed login counter is modified only when a user attempts a log in
    so it is possible that an account may appear locked but the last failed
    login attempt is older than the lockouttime of the password policy. This
    means that the user may attempt a login again.
*/
func (c *Client) UserStatus(
  reqArgs *UserStatusArgs,
  optArgs *UserStatusOptionalArgs, // can be nil
) (*UserStatusResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userStatusKwParams{
    UserStatusArgs: reqArgs,
    UserStatusOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_status",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userStatusResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserStatusArgs struct {
  }

type UserStatusOptionalArgs struct {
  
    /*
User login

    */
    Useruid *string `json:"useruid,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type userStatusKwParams struct {
  *UserStatusArgs
  *UserStatusOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userStatusResponse struct {
	Error  *Error      `json:"error"`
	Result *UserStatusResult `json:"result"`
}
type UserStatusResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Userstatus `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *UserStatusResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserStatusResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserStatusResult%v", string(b))
}

/*
Undelete a delete user account.
*/
func (c *Client) UserUndel(
  reqArgs *UserUndelArgs,
  optArgs *UserUndelOptionalArgs, // can be nil
) (*UserUndelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userUndelKwParams{
    UserUndelArgs: reqArgs,
    UserUndelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_undel",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userUndelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserUndelArgs struct {
  }

type UserUndelOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  }

type userUndelKwParams struct {
  *UserUndelArgs
  *UserUndelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userUndelResponse struct {
	Error  *Error      `json:"error"`
	Result *UserUndelResult `json:"result"`
}
type UserUndelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserUndelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserUndelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserUndelResult%v", string(b))
}

/*
Unlock a user account

    An account may become locked if the password is entered incorrectly too
    many times within a specific time period as controlled by password
    policy. A locked account is a temporary condition and may be unlocked by
    an administrator.
*/
func (c *Client) UserUnlock(
  reqArgs *UserUnlockArgs,
  optArgs *UserUnlockOptionalArgs, // can be nil
) (*UserUnlockResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := userUnlockKwParams{
    UserUnlockArgs: reqArgs,
    UserUnlockOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "user_unlock",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res userUnlockResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type UserUnlockArgs struct {
  }

type UserUnlockOptionalArgs struct {
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  }

type userUnlockKwParams struct {
  *UserUnlockArgs
  *UserUnlockOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type userUnlockResponse struct {
	Error  *Error      `json:"error"`
	Result *UserUnlockResult `json:"result"`
}
type UserUnlockResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
True means the operation was successful
    (required)
    */
    
    Result bool `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *UserUnlockResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("UserUnlockResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("UserUnlockResult%v", string(b))
}

/*

*/
func (c *Client) VaultAddInternal(
  reqArgs *VaultAddInternalArgs,
  optArgs *VaultAddInternalOptionalArgs, // can be nil
) (*VaultAddInternalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultAddInternalKwParams{
    VaultAddInternalArgs: reqArgs,
    VaultAddInternalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_add_internal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultAddInternalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultAddInternalArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultAddInternalOptionalArgs struct {
  
    /*
Description
Vault description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Type
Vault type
    */
    Ipavaulttype *string `json:"ipavaulttype,omitempty"`
  
    /*
Salt
Vault salt
    */
    Ipavaultsalt *string `json:"ipavaultsalt,omitempty"`
  
    /*
Public key
Vault public key
    */
    Ipavaultpublickey *string `json:"ipavaultpublickey,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type vaultAddInternalKwParams struct {
  *VaultAddInternalArgs
  *VaultAddInternalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultAddInternalResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultAddInternalResult `json:"result"`
}
type VaultAddInternalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *VaultAddInternalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultAddInternalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultAddInternalResult%v", string(b))
}

/*
Add members to a vault.
*/
func (c *Client) VaultAddMember(
  reqArgs *VaultAddMemberArgs,
  optArgs *VaultAddMemberOptionalArgs, // can be nil
) (*VaultAddMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultAddMemberKwParams{
    VaultAddMemberArgs: reqArgs,
    VaultAddMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_add_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultAddMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultAddMemberArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultAddMemberOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member service
services to add
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultAddMemberKwParams struct {
  *VaultAddMemberArgs
  *VaultAddMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultAddMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultAddMemberResult `json:"result"`
}
type VaultAddMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *VaultAddMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultAddMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultAddMemberResult%v", string(b))
}

/*
Add owners to a vault.
*/
func (c *Client) VaultAddOwner(
  reqArgs *VaultAddOwnerArgs,
  optArgs *VaultAddOwnerOptionalArgs, // can be nil
) (*VaultAddOwnerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultAddOwnerKwParams{
    VaultAddOwnerArgs: reqArgs,
    VaultAddOwnerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_add_owner",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultAddOwnerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultAddOwnerArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultAddOwnerOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
owner user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
owner group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
owner service
services to add
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultAddOwnerKwParams struct {
  *VaultAddOwnerArgs
  *VaultAddOwnerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultAddOwnerResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultAddOwnerResult `json:"result"`
}
type VaultAddOwnerResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Owners that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of owners added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *VaultAddOwnerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultAddOwnerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultAddOwnerResult%v", string(b))
}

/*

*/
func (c *Client) VaultArchiveInternal(
  reqArgs *VaultArchiveInternalArgs,
  optArgs *VaultArchiveInternalOptionalArgs, // can be nil
) (*VaultArchiveInternalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultArchiveInternalKwParams{
    VaultArchiveInternalArgs: reqArgs,
    VaultArchiveInternalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_archive_internal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultArchiveInternalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultArchiveInternalArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  
    /*

Session key wrapped with transport certificate
    */
    SessionKey string `json:"session_key,omitempty"`
  
    /*

Vault data encrypted with session key
    */
    VaultData string `json:"vault_data,omitempty"`
  
    /*

Nonce
    */
    Nonce string `json:"nonce,omitempty"`
  }

type VaultArchiveInternalOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type vaultArchiveInternalKwParams struct {
  *VaultArchiveInternalArgs
  *VaultArchiveInternalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultArchiveInternalResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultArchiveInternalResult `json:"result"`
}
type VaultArchiveInternalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *VaultArchiveInternalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultArchiveInternalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultArchiveInternalResult%v", string(b))
}

/*
Delete a vault.
*/
func (c *Client) VaultDel(
  reqArgs *VaultDelArgs,
  optArgs *VaultDelOptionalArgs, // can be nil
) (*VaultDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultDelKwParams{
    VaultDelArgs: reqArgs,
    VaultDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultDelArgs struct {
  
    /*
Vault name

    */
    Cn []string `json:"cn,omitempty"`
  }

type VaultDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  }

type vaultDelKwParams struct {
  *VaultDelArgs
  *VaultDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultDelResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultDelResult `json:"result"`
}
type VaultDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []string `json:"value,omitempty"`
    
  }

func (t *VaultDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultDelResult%v", string(b))
}

/*
Search for vaults.
*/
func (c *Client) VaultFind(
  criteria string, // A string searched in all relevant object attributes
  reqArgs *VaultFindArgs,
  optArgs *VaultFindOptionalArgs, // can be nil
) (*VaultFindResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultFindKwParams{
    VaultFindArgs: reqArgs,
    VaultFindOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_find",
    Params: []interface{}{
      []interface{}{criteria, }, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultFindResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultFindArgs struct {
  }

type VaultFindOptionalArgs struct {
  
    /*
Vault name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Description
Vault description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Type
Vault type
    */
    Ipavaulttype *string `json:"ipavaulttype,omitempty"`
  
    /*
Time Limit
Time limit of search in seconds (0 is unlimited)
    */
    Timelimit *int `json:"timelimit,omitempty"`
  
    /*
Size Limit
Maximum number of entries returned (0 is unlimited)
    */
    Sizelimit *int `json:"sizelimit,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

List all service vaults
    */
    Services *bool `json:"services,omitempty"`
  
    /*

List all user vaults
    */
    Users *bool `json:"users,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
Primary key only
Results should contain primary key attribute only ("name")
    */
    PkeyOnly *bool `json:"pkey_only,omitempty"`
  }

type vaultFindKwParams struct {
  *VaultFindArgs
  *VaultFindOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultFindResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultFindResult `json:"result"`
}
type VaultFindResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result []Vault `json:"result,omitempty"`
    
  
    /*
Number of entries returned
    (required)
    */
    
    Count int `json:"count,omitempty"`
    
  
    /*
True if not all results were returned
    (required)
    */
    
    Truncated bool `json:"truncated,omitempty"`
    
  }

func (t *VaultFindResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultFindResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultFindResult%v", string(b))
}

/*

*/
func (c *Client) VaultModInternal(
  reqArgs *VaultModInternalArgs,
  optArgs *VaultModInternalOptionalArgs, // can be nil
) (*VaultModInternalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultModInternalKwParams{
    VaultModInternalArgs: reqArgs,
    VaultModInternalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_mod_internal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultModInternalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultModInternalArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultModInternalOptionalArgs struct {
  
    /*
Description
Vault description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Type
Vault type
    */
    Ipavaulttype *string `json:"ipavaulttype,omitempty"`
  
    /*
Salt
Vault salt
    */
    Ipavaultsalt *string `json:"ipavaultsalt,omitempty"`
  
    /*
Public key
Vault public key
    */
    Ipavaultpublickey *string `json:"ipavaultpublickey,omitempty"`
  
    /*

Set an attribute to a name/value pair. Format is attr=value.
For multi-valued attributes, the command replaces the values already present.
    */
    Setattr *[]string `json:"setattr,omitempty"`
  
    /*

Add an attribute/value pair. Format is attr=value. The attribute
must be part of the schema.
    */
    Addattr *[]string `json:"addattr,omitempty"`
  
    /*

Delete an attribute/value pair. The option will be evaluated
last, after all sets and adds.
    */
    Delattr *[]string `json:"delattr,omitempty"`
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type vaultModInternalKwParams struct {
  *VaultModInternalArgs
  *VaultModInternalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultModInternalResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultModInternalResult `json:"result"`
}
type VaultModInternalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *VaultModInternalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultModInternalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultModInternalResult%v", string(b))
}

/*
Remove members from a vault.
*/
func (c *Client) VaultRemoveMember(
  reqArgs *VaultRemoveMemberArgs,
  optArgs *VaultRemoveMemberOptionalArgs, // can be nil
) (*VaultRemoveMemberResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultRemoveMemberKwParams{
    VaultRemoveMemberArgs: reqArgs,
    VaultRemoveMemberOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_remove_member",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultRemoveMemberResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultRemoveMemberArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultRemoveMemberOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
member user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
member group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
member service
services to remove
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultRemoveMemberKwParams struct {
  *VaultRemoveMemberArgs
  *VaultRemoveMemberOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultRemoveMemberResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultRemoveMemberResult `json:"result"`
}
type VaultRemoveMemberResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Members that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of members removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *VaultRemoveMemberResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultRemoveMemberResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultRemoveMemberResult%v", string(b))
}

/*
Remove owners from a vault.
*/
func (c *Client) VaultRemoveOwner(
  reqArgs *VaultRemoveOwnerArgs,
  optArgs *VaultRemoveOwnerOptionalArgs, // can be nil
) (*VaultRemoveOwnerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultRemoveOwnerKwParams{
    VaultRemoveOwnerArgs: reqArgs,
    VaultRemoveOwnerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_remove_owner",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultRemoveOwnerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultRemoveOwnerArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultRemoveOwnerOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
owner user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
owner group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
owner service
services to remove
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultRemoveOwnerKwParams struct {
  *VaultRemoveOwnerArgs
  *VaultRemoveOwnerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultRemoveOwnerResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultRemoveOwnerResult `json:"result"`
}
type VaultRemoveOwnerResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Owners that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of owners removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *VaultRemoveOwnerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultRemoveOwnerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultRemoveOwnerResult%v", string(b))
}

/*

*/
func (c *Client) VaultRetrieveInternal(
  reqArgs *VaultRetrieveInternalArgs,
  optArgs *VaultRetrieveInternalOptionalArgs, // can be nil
) (*VaultRetrieveInternalResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultRetrieveInternalKwParams{
    VaultRetrieveInternalArgs: reqArgs,
    VaultRetrieveInternalOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_retrieve_internal",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultRetrieveInternalResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultRetrieveInternalArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  
    /*

Session key wrapped with transport certificate
    */
    SessionKey string `json:"session_key,omitempty"`
  }

type VaultRetrieveInternalOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type vaultRetrieveInternalKwParams struct {
  *VaultRetrieveInternalArgs
  *VaultRetrieveInternalOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultRetrieveInternalResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultRetrieveInternalResult `json:"result"`
}
type VaultRetrieveInternalResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *VaultRetrieveInternalResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultRetrieveInternalResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultRetrieveInternalResult%v", string(b))
}

/*
Display information about a vault.
*/
func (c *Client) VaultShow(
  reqArgs *VaultShowArgs,
  optArgs *VaultShowOptionalArgs, // can be nil
) (*VaultShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultShowKwParams{
    VaultShowArgs: reqArgs,
    VaultShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vault_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultShowArgs struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  }

type VaultShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type vaultShowKwParams struct {
  *VaultShowArgs
  *VaultShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultShowResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultShowResult `json:"result"`
}
type VaultShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Vault `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value string `json:"value,omitempty"`
    
  }

func (t *VaultShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultShowResult%v", string(b))
}

/*
Show vault configuration.
*/
func (c *Client) VaultconfigShow(
  reqArgs *VaultconfigShowArgs,
  optArgs *VaultconfigShowOptionalArgs, // can be nil
) (*VaultconfigShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultconfigShowKwParams{
    VaultconfigShowArgs: reqArgs,
    VaultconfigShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vaultconfig_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultconfigShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultconfigShowArgs struct {
  }

type VaultconfigShowOptionalArgs struct {
  
    /*

Output file to store the transport certificate
    */
    TransportOut *string `json:"transport_out,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  }

type vaultconfigShowKwParams struct {
  *VaultconfigShowArgs
  *VaultconfigShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultconfigShowResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultconfigShowResult `json:"result"`
}
type VaultconfigShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Vaultconfig `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *VaultconfigShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultconfigShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultconfigShowResult%v", string(b))
}

/*
Add owners to a vault container.
*/
func (c *Client) VaultcontainerAddOwner(
  reqArgs *VaultcontainerAddOwnerArgs,
  optArgs *VaultcontainerAddOwnerOptionalArgs, // can be nil
) (*VaultcontainerAddOwnerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultcontainerAddOwnerKwParams{
    VaultcontainerAddOwnerArgs: reqArgs,
    VaultcontainerAddOwnerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vaultcontainer_add_owner",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultcontainerAddOwnerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultcontainerAddOwnerArgs struct {
  }

type VaultcontainerAddOwnerOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
owner user
users to add
    */
    User *[]string `json:"user,omitempty"`
  
    /*
owner group
groups to add
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
owner service
services to add
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultcontainerAddOwnerKwParams struct {
  *VaultcontainerAddOwnerArgs
  *VaultcontainerAddOwnerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultcontainerAddOwnerResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultcontainerAddOwnerResult `json:"result"`
}
type VaultcontainerAddOwnerResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Owners that could not be added
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of owners added
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *VaultcontainerAddOwnerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultcontainerAddOwnerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultcontainerAddOwnerResult%v", string(b))
}

/*
Delete a vault container.
*/
func (c *Client) VaultcontainerDel(
  reqArgs *VaultcontainerDelArgs,
  optArgs *VaultcontainerDelOptionalArgs, // can be nil
) (*VaultcontainerDelResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultcontainerDelKwParams{
    VaultcontainerDelArgs: reqArgs,
    VaultcontainerDelOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vaultcontainer_del",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultcontainerDelResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultcontainerDelArgs struct {
  }

type VaultcontainerDelOptionalArgs struct {
  
    /*

Continuous mode: Don't stop on errors.
    */
    Continue *bool `json:"continue,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  }

type vaultcontainerDelKwParams struct {
  *VaultcontainerDelArgs
  *VaultcontainerDelOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultcontainerDelResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultcontainerDelResult `json:"result"`
}
type VaultcontainerDelResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*
List of deletions that failed
    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*

    (required)
    */
    
    Value []interface{} `json:"value,omitempty"`
    
  }

func (t *VaultcontainerDelResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultcontainerDelResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultcontainerDelResult%v", string(b))
}

/*
Remove owners from a vault container.
*/
func (c *Client) VaultcontainerRemoveOwner(
  reqArgs *VaultcontainerRemoveOwnerArgs,
  optArgs *VaultcontainerRemoveOwnerOptionalArgs, // can be nil
) (*VaultcontainerRemoveOwnerResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultcontainerRemoveOwnerKwParams{
    VaultcontainerRemoveOwnerArgs: reqArgs,
    VaultcontainerRemoveOwnerOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vaultcontainer_remove_owner",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultcontainerRemoveOwnerResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultcontainerRemoveOwnerArgs struct {
  }

type VaultcontainerRemoveOwnerOptionalArgs struct {
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  
    /*
owner user
users to remove
    */
    User *[]string `json:"user,omitempty"`
  
    /*
owner group
groups to remove
    */
    Group *[]string `json:"group,omitempty"`
  
    /*
owner service
services to remove
    */
    Services *[]string `json:"services,omitempty"`
  }

type vaultcontainerRemoveOwnerKwParams struct {
  *VaultcontainerRemoveOwnerArgs
  *VaultcontainerRemoveOwnerOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultcontainerRemoveOwnerResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultcontainerRemoveOwnerResult `json:"result"`
}
type VaultcontainerRemoveOwnerResult struct {
  
  
  
    /*

    (required)
    */
    
    Result interface{} `json:"result,omitempty"`
    
  
    /*
Owners that could not be removed
    (required)
    */
    
    Failed FailedOperations`json:"failed,omitempty"`
    
  
    /*
Number of owners removed
    (required)
    */
    
    Completed int `json:"completed,omitempty"`
    
  }

func (t *VaultcontainerRemoveOwnerResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultcontainerRemoveOwnerResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultcontainerRemoveOwnerResult%v", string(b))
}

/*
Display information about a vault container.
*/
func (c *Client) VaultcontainerShow(
  reqArgs *VaultcontainerShowArgs,
  optArgs *VaultcontainerShowOptionalArgs, // can be nil
) (*VaultcontainerShowResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := vaultcontainerShowKwParams{
    VaultcontainerShowArgs: reqArgs,
    VaultcontainerShowOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "vaultcontainer_show",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res vaultcontainerShowResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type VaultcontainerShowArgs struct {
  }

type VaultcontainerShowOptionalArgs struct {
  
    /*
Rights
Display the access rights of this entry (requires --all). See ipa man page for details.
    */
    Rights *bool `json:"rights,omitempty"`
  
    /*

Service name of the service vault
    */
    Service *string `json:"service,omitempty"`
  
    /*

Shared vault
    */
    Shared *bool `json:"shared,omitempty"`
  
    /*

Username of the user vault
    */
    Username *string `json:"username,omitempty"`
  
    /*

Retrieve and print all attributes from the server. Affects command output.
    */
    All *bool `json:"all,omitempty"`
  
    /*

Print entries as stored on the server. Only affects output format.
    */
    Raw *bool `json:"raw,omitempty"`
  
    /*

Suppress processing of membership attributes.
    */
    NoMembers *bool `json:"no_members,omitempty"`
  }

type vaultcontainerShowKwParams struct {
  *VaultcontainerShowArgs
  *VaultcontainerShowOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type vaultcontainerShowResponse struct {
	Error  *Error      `json:"error"`
	Result *VaultcontainerShowResult `json:"result"`
}
type VaultcontainerShowResult struct {
  
  
  
    /*
User-friendly description of action performed
    (optional)
    */
    
    Summary *string `json:"summary,omitempty"`
    
  
    /*

    (required)
    */
    
    Result Vaultcontainer `json:"result,omitempty"`
    
  
    /*
The primary_key value of the entry, e.g. 'jdoe' for a user
    (required)
    */
    
    Value interface{} `json:"value,omitempty"`
    
  }

func (t *VaultcontainerShowResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("VaultcontainerShowResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("VaultcontainerShowResult%v", string(b))
}

/*
Describe currently authenticated identity.
*/
func (c *Client) Whoami(
  reqArgs *WhoamiArgs,
  optArgs *WhoamiOptionalArgs, // can be nil
) (*WhoamiResult, error) {
  if reqArgs == nil {
    return nil, fmt.Errorf("reqArgs cannot be nil")
  }
  kwp := whoamiKwParams{
    WhoamiArgs: reqArgs,
    WhoamiOptionalArgs: optArgs,
    Version: apiVersion,
  }
  req := request{
    Method: "whoami",
    Params: []interface{}{
      []interface{}{}, &kwp},
  }
  readCloser, e := c.exec(&req)
  if e != nil {
    return nil, e
  }
  defer readCloser.Close()
  var res whoamiResponse
	if e := json.NewDecoder(readCloser).Decode(&res); e != nil {
		return nil, e
	}
	if res.Error != nil {
		return nil, res.Error
	}
  if res.Result == nil {
    return nil, fmt.Errorf("missing result in response")
  }
  return res.Result, nil
}

type WhoamiArgs struct {
  }

type WhoamiOptionalArgs struct {
  }

type whoamiKwParams struct {
  *WhoamiArgs
  *WhoamiOptionalArgs

  /*
  Automatically set.
  Used by the server to determine whether to accept the request.
  */
  Version string `json:"version"`
}

type whoamiResponse struct {
	Error  *Error      `json:"error"`
	Result *WhoamiResult `json:"result"`
}
type WhoamiResult struct {
  
  
  
    /*
Object class name
    (required)
    */
    
    Object string `json:"object,omitempty"`
    
  
    /*
Function to get details
    (required)
    */
    
    Command string `json:"command,omitempty"`
    
  
    /*
Arguments to details function
    (required)
    */
    
    Arguments []interface{} `json:"arguments,omitempty"`
    
  }

func (t *WhoamiResult) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("WhoamiResult[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("WhoamiResult%v", string(b))
}



type Aci struct {
  
    /*
ACI name

    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
Permission
Permission ACI grants access to
    */
    Permission *string `json:"permission,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group *string `json:"group,omitempty"`
  
    /*
Permissions
Permissions to grant(read, write, add, delete, all)
    */
    Permissions []string `json:"permissions,omitempty"`
  
    /*
Attributes to which the permission applies
Attributes
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Type
type of IPA object (user, group, host, hostgroup, service, netgroup)
    */
    Type *string `json:"type,omitempty"`
  
    /*
Member of
Member of a group
    */
    Memberof *string `json:"memberof,omitempty"`
  
    /*
Filter
Legal LDAP filter (e.g. ou=Engineering)
    */
    Filter *string `json:"filter,omitempty"`
  
    /*
Subtree
Subtree to apply ACI to
    */
    Subtree *string `json:"subtree,omitempty"`
  
    /*
Target group
Group to apply ACI to
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Target your own entry (self)
Apply ACI to your own entry (self)
    */
    Selfaci *bool `json:"selfaci,omitempty"`
  
    /*
ACI prefix
Prefix used to distinguish ACI types (permission, delegation, selfservice, none)
    */
    Aciprefix string `json:"aciprefix,omitempty"`
  
    /*
ACI

    */
    Aci string `json:"aci,omitempty"`
  }

func (t *Aci) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Aci[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Aci%v", string(b))
}

type jsonAci struct {
  
    Aciname interface{} `json:"aciname"`
  
    Permission interface{} `json:"permission"`
  
    Group interface{} `json:"group"`
  
    Permissions interface{} `json:"permissions"`
  
    Attrs interface{} `json:"attrs"`
  
    Type interface{} `json:"type"`
  
    Memberof interface{} `json:"memberof"`
  
    Filter interface{} `json:"filter"`
  
    Subtree interface{} `json:"subtree"`
  
    Targetgroup interface{} `json:"targetgroup"`
  
    Selfaci interface{} `json:"selfaci"`
  
    Aciprefix interface{} `json:"aciprefix"`
  
    Aci interface{} `json:"aci"`
  }

func (out *Aci) UnmarshalJSON(data []byte) error {
  var in jsonAci
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Aciname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Aciname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Aciname: %v; expected exactly one element", raw)
          }
          out.Aciname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Aciname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Permission != nil {
    raw := in.Permission
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Permission = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Permission = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Permission: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Permission: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Group != nil {
    raw := in.Group
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Group = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Group = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Group: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Group: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Permissions
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Permissions = []string{plainV}
      } else if sliceOk {
        
          if len(sliceV) < 1 {
            return fmt.Errorf("unexpected value for field Permissions: %v; expected at least one element", raw)
          }
        
        out.Permissions = sliceV
      } else {
        return fmt.Errorf("unexpected value for field Permissions: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Attrs != nil {
    raw := in.Attrs
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Attrs = &[]string{plainV}
      } else if sliceOk {
        
        out.Attrs = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Attrs: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Type != nil {
    raw := in.Type
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Type = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Type = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Type: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Type: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Memberof != nil {
    raw := in.Memberof
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Memberof = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Memberof = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Memberof: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Memberof: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Filter != nil {
    raw := in.Filter
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Filter = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Filter = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Filter: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Filter: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Subtree != nil {
    raw := in.Subtree
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Subtree = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Subtree = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Subtree: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Subtree: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Targetgroup != nil {
    raw := in.Targetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Targetgroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Targetgroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Targetgroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Targetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Selfaci != nil {
    raw := in.Selfaci
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Selfaci = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Selfaci = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Selfaci: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Selfaci: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Aciprefix
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Aciprefix = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Aciprefix: %v; expected exactly one element", raw)
          }
          out.Aciprefix = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Aciprefix: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Aci
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Aci = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Aci: %v; expected exactly one element", raw)
          }
          out.Aci = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Aci: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Automember struct {
  
    /*
Automember Rule
Automember Rule
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*
Default (fallback) Group
Default group for entries to land
    */
    Automemberdefaultgroup *string `json:"automemberdefaultgroup,omitempty"`
  
    /*
Inclusive Regex
Inclusive Regex
    */
    Automemberinclusiveregex *[]string `json:"automemberinclusiveregex,omitempty"`
  
    /*
Exclusive Regex
Exclusive Regex
    */
    Automemberexclusiveregex *[]string `json:"automemberexclusiveregex,omitempty"`
  }

func (t *Automember) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Automember[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Automember%v", string(b))
}

type jsonAutomember struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    Automemberdefaultgroup interface{} `json:"automemberdefaultgroup"`
  
    Automemberinclusiveregex interface{} `json:"automemberinclusiveregex"`
  
    Automemberexclusiveregex interface{} `json:"automemberexclusiveregex"`
  }

func (out *Automember) UnmarshalJSON(data []byte) error {
  var in jsonAutomember
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Automemberdefaultgroup != nil {
    raw := in.Automemberdefaultgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Automemberdefaultgroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Automemberdefaultgroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Automemberdefaultgroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Automemberdefaultgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Automemberinclusiveregex != nil {
    raw := in.Automemberinclusiveregex
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Automemberinclusiveregex = &[]string{plainV}
      } else if sliceOk {
        
        out.Automemberinclusiveregex = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Automemberinclusiveregex: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Automemberexclusiveregex != nil {
    raw := in.Automemberexclusiveregex
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Automemberexclusiveregex = &[]string{plainV}
      } else if sliceOk {
        
        out.Automemberexclusiveregex = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Automemberexclusiveregex: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type AutomemberDefaultGroup struct {
  
    /*
Description
A description of this auto member rule
    */
    Description *string `json:"description,omitempty"`
  
    /*
Default (fallback) Group
Default group for entries to land
    */
    Automemberdefaultgroup *string `json:"automemberdefaultgroup,omitempty"`
  
    /*
Inclusive Regex
Inclusive Regex
    */
    Automemberinclusiveregex *[]string `json:"automemberinclusiveregex,omitempty"`
  
    /*
Exclusive Regex
Exclusive Regex
    */
    Automemberexclusiveregex *[]string `json:"automemberexclusiveregex,omitempty"`
  }

func (t *AutomemberDefaultGroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberDefaultGroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberDefaultGroup%v", string(b))
}

type jsonAutomemberDefaultGroup struct {
  
    Description interface{} `json:"description"`
  
    Automemberdefaultgroup interface{} `json:"automemberdefaultgroup"`
  
    Automemberinclusiveregex interface{} `json:"automemberinclusiveregex"`
  
    Automemberexclusiveregex interface{} `json:"automemberexclusiveregex"`
  }

func (out *AutomemberDefaultGroup) UnmarshalJSON(data []byte) error {
  var in jsonAutomemberDefaultGroup
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Automemberdefaultgroup != nil {
    raw := in.Automemberdefaultgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Automemberdefaultgroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Automemberdefaultgroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Automemberdefaultgroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Automemberdefaultgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Automemberinclusiveregex != nil {
    raw := in.Automemberinclusiveregex
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Automemberinclusiveregex = &[]string{plainV}
      } else if sliceOk {
        
        out.Automemberinclusiveregex = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Automemberinclusiveregex: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Automemberexclusiveregex != nil {
    raw := in.Automemberexclusiveregex
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Automemberexclusiveregex = &[]string{plainV}
      } else if sliceOk {
        
        out.Automemberexclusiveregex = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Automemberexclusiveregex: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type AutomemberTask struct {
  
    /*
Task DN
DN of the started task
    */
    Dn string `json:"dn,omitempty"`
  }

func (t *AutomemberTask) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("AutomemberTask[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("AutomemberTask%v", string(b))
}

type jsonAutomemberTask struct {
  
    Dn interface{} `json:"dn"`
  }

func (out *AutomemberTask) UnmarshalJSON(data []byte) error {
  var in jsonAutomemberTask
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Dn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Dn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Dn: %v; expected exactly one element", raw)
          }
          out.Dn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Dn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Automountkey struct {
  
    /*
Key
Automount key name.
    */
    Automountkey string `json:"automountkey,omitempty"`
  
    /*
Mount information

    */
    Automountinformation string `json:"automountinformation,omitempty"`
  
    /*
description

    */
    Description *string `json:"description,omitempty"`
  }

func (t *Automountkey) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Automountkey[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Automountkey%v", string(b))
}

type jsonAutomountkey struct {
  
    Automountkey interface{} `json:"automountkey"`
  
    Automountinformation interface{} `json:"automountinformation"`
  
    Description interface{} `json:"description"`
  }

func (out *Automountkey) UnmarshalJSON(data []byte) error {
  var in jsonAutomountkey
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Automountkey
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Automountkey = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Automountkey: %v; expected exactly one element", raw)
          }
          out.Automountkey = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Automountkey: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Automountinformation
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Automountinformation = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Automountinformation: %v; expected exactly one element", raw)
          }
          out.Automountinformation = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Automountinformation: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Automountlocation struct {
  
    /*
Location
Automount location name.
    */
    Cn string `json:"cn,omitempty"`
  }

func (t *Automountlocation) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Automountlocation[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Automountlocation%v", string(b))
}

type jsonAutomountlocation struct {
  
    Cn interface{} `json:"cn"`
  }

func (out *Automountlocation) UnmarshalJSON(data []byte) error {
  var in jsonAutomountlocation
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Automountmap struct {
  
    /*
Map
Automount map name.
    */
    Automountmapname string `json:"automountmapname,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  }

func (t *Automountmap) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Automountmap[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Automountmap%v", string(b))
}

type jsonAutomountmap struct {
  
    Automountmapname interface{} `json:"automountmapname"`
  
    Description interface{} `json:"description"`
  }

func (out *Automountmap) UnmarshalJSON(data []byte) error {
  var in jsonAutomountmap
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Automountmapname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Automountmapname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Automountmapname: %v; expected exactly one element", raw)
          }
          out.Automountmapname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Automountmapname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Ca struct {
  
    /*
Name
Name for referencing the CA
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
Description of the purpose of the CA
    */
    Description *string `json:"description,omitempty"`
  
    /*
Authority ID
Dogtag Authority ID
    */
    Ipacaid string `json:"ipacaid,omitempty"`
  
    /*
Subject DN
Subject Distinguished Name
    */
    Ipacasubjectdn string `json:"ipacasubjectdn,omitempty"`
  
    /*
Issuer DN
Issuer Distinguished Name
    */
    Ipacaissuerdn string `json:"ipacaissuerdn,omitempty"`
  
    /*
Certificate
Base-64 encoded certificate.
    */
    Certificate string `json:"certificate,omitempty"`
  
    /*
Certificate chain
X.509 certificate chain
    */
    CertificateChain *[]string `json:"certificate_chain,omitempty"`
  }

func (t *Ca) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Ca[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Ca%v", string(b))
}

type jsonCa struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    Ipacaid interface{} `json:"ipacaid"`
  
    Ipacasubjectdn interface{} `json:"ipacasubjectdn"`
  
    Ipacaissuerdn interface{} `json:"ipacaissuerdn"`
  
    Certificate interface{} `json:"certificate"`
  
    CertificateChain interface{} `json:"certificate_chain"`
  }

func (out *Ca) UnmarshalJSON(data []byte) error {
  var in jsonCa
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipacaid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacaid = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipacaid: %v; expected exactly one element", raw)
          }
          out.Ipacaid = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipacaid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipacasubjectdn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacasubjectdn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipacasubjectdn: %v; expected exactly one element", raw)
          }
          out.Ipacasubjectdn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipacasubjectdn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipacaissuerdn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacaissuerdn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipacaissuerdn: %v; expected exactly one element", raw)
          }
          out.Ipacaissuerdn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipacaissuerdn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Certificate
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Certificate = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Certificate: %v; expected exactly one element", raw)
          }
          out.Certificate = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Certificate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CertificateChain != nil {
    raw := in.CertificateChain
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CertificateChain = &[]string{plainV}
      } else if sliceOk {
        
        out.CertificateChain = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field CertificateChain: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Caacl struct {
  
    /*
ACL name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
CA category
CA category the ACL applies to
    */
    Ipacacategory *string `json:"ipacacategory,omitempty"`
  
    /*
Profile category
Profile category the ACL applies to
    */
    Ipacertprofilecategory *string `json:"ipacertprofilecategory,omitempty"`
  
    /*
User category
User category the ACL applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the ACL applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Service category
Service category the ACL applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*
CAs

    */
    IpamembercaCa *string `json:"ipamemberca_ca,omitempty"`
  
    /*
Profiles

    */
    IpamembercertprofileCertprofile *string `json:"ipamembercertprofile_certprofile,omitempty"`
  
    /*
Users

    */
    MemberuserUser *[]string `json:"memberuser_user,omitempty"`
  
    /*
User Groups

    */
    MemberuserGroup *[]string `json:"memberuser_group,omitempty"`
  
    /*
Hosts

    */
    MemberhostHost *[]string `json:"memberhost_host,omitempty"`
  
    /*
Host Groups

    */
    MemberhostHostgroup *[]string `json:"memberhost_hostgroup,omitempty"`
  
    /*
Services

    */
    MemberserviceService *string `json:"memberservice_service,omitempty"`
  }

func (t *Caacl) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Caacl[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Caacl%v", string(b))
}

type jsonCaacl struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    Ipaenabledflag interface{} `json:"ipaenabledflag"`
  
    Ipacacategory interface{} `json:"ipacacategory"`
  
    Ipacertprofilecategory interface{} `json:"ipacertprofilecategory"`
  
    Usercategory interface{} `json:"usercategory"`
  
    Hostcategory interface{} `json:"hostcategory"`
  
    Servicecategory interface{} `json:"servicecategory"`
  
    IpamembercaCa interface{} `json:"ipamemberca_ca"`
  
    IpamembercertprofileCertprofile interface{} `json:"ipamembercertprofile_certprofile"`
  
    MemberuserUser interface{} `json:"memberuser_user"`
  
    MemberuserGroup interface{} `json:"memberuser_group"`
  
    MemberhostHost interface{} `json:"memberhost_host"`
  
    MemberhostHostgroup interface{} `json:"memberhost_hostgroup"`
  
    MemberserviceService interface{} `json:"memberservice_service"`
  }

func (out *Caacl) UnmarshalJSON(data []byte) error {
  var in jsonCaacl
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipaenabledflag != nil {
    raw := in.Ipaenabledflag
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaenabledflag = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipaenabledflag = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipaenabledflag: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaenabledflag: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipacacategory != nil {
    raw := in.Ipacacategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacacategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipacacategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipacacategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipacacategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipacertprofilecategory != nil {
    raw := in.Ipacertprofilecategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacertprofilecategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipacertprofilecategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipacertprofilecategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipacertprofilecategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Usercategory != nil {
    raw := in.Usercategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Usercategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Usercategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Usercategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Usercategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Hostcategory != nil {
    raw := in.Hostcategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Hostcategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Hostcategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Hostcategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Hostcategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Servicecategory != nil {
    raw := in.Servicecategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Servicecategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Servicecategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Servicecategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Servicecategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpamembercaCa != nil {
    raw := in.IpamembercaCa
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpamembercaCa = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.IpamembercaCa = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field IpamembercaCa: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field IpamembercaCa: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpamembercertprofileCertprofile != nil {
    raw := in.IpamembercertprofileCertprofile
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpamembercertprofileCertprofile = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.IpamembercertprofileCertprofile = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field IpamembercertprofileCertprofile: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field IpamembercertprofileCertprofile: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberuserUser != nil {
    raw := in.MemberuserUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberuserUser = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberuserUser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberuserUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberuserGroup != nil {
    raw := in.MemberuserGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberuserGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberuserGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberuserGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberhostHost != nil {
    raw := in.MemberhostHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberhostHost = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberhostHost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberhostHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberhostHostgroup != nil {
    raw := in.MemberhostHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberhostHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberhostHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberhostHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberserviceService != nil {
    raw := in.MemberserviceService
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberserviceService = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.MemberserviceService = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field MemberserviceService: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field MemberserviceService: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Cert struct {
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  
    /*
Certificate
Base-64 encoded certificate.
    */
    Certificate interface{} `json:"certificate,omitempty"`
  
    /*
Certificate chain
X.509 certificate chain
    */
    CertificateChain *[]string `json:"certificate_chain,omitempty"`
  
    /*
Subject

    */
    Subject string `json:"subject,omitempty"`
  
    /*
Subject email address

    */
    SanRfc822name *[]string `json:"san_rfc822name,omitempty"`
  
    /*
Subject DNS name

    */
    SanDnsname *[]interface{} `json:"san_dnsname,omitempty"`
  
    /*
Subject X.400 address

    */
    SanX400address *[]string `json:"san_x400address,omitempty"`
  
    /*
Subject directory name

    */
    SanDirectoryname *[]string `json:"san_directoryname,omitempty"`
  
    /*
Subject EDI Party name

    */
    SanEdipartyname *[]string `json:"san_edipartyname,omitempty"`
  
    /*
Subject URI

    */
    SanURI *[]string `json:"san_uri,omitempty"`
  
    /*
Subject IP Address

    */
    SanIpaddress *[]string `json:"san_ipaddress,omitempty"`
  
    /*
Subject OID

    */
    SanOid *[]string `json:"san_oid,omitempty"`
  
    /*
Subject UPN

    */
    SanOtherUpn *[]string `json:"san_other_upn,omitempty"`
  
    /*
Subject Kerberos principal name

    */
    SanOtherKpn *[]string `json:"san_other_kpn,omitempty"`
  
    /*
Subject Other Name

    */
    SanOther *[]string `json:"san_other,omitempty"`
  
    /*
Issuer
Issuer DN
    */
    Issuer string `json:"issuer,omitempty"`
  
    /*
Not Before

    */
    ValidNotBefore time.Time `json:"valid_not_before,omitempty"`
  
    /*
Not After

    */
    ValidNotAfter time.Time `json:"valid_not_after,omitempty"`
  
    /*
Fingerprint (SHA1)

    */
    Sha1Fingerprint string `json:"sha1_fingerprint,omitempty"`
  
    /*
Fingerprint (SHA256)

    */
    Sha256Fingerprint string `json:"sha256_fingerprint,omitempty"`
  
    /*
Serial number
Serial number in decimal or if prefixed with 0x in hexadecimal
    */
    SerialNumber int `json:"serial_number,omitempty"`
  
    /*
Serial number (hex)

    */
    SerialNumberHex string `json:"serial_number_hex,omitempty"`
  
    /*
Status

    */
    Status string `json:"status,omitempty"`
  
    /*
Revoked

    */
    Revoked *bool `json:"revoked,omitempty"`
  
    /*
Revocation reason
Reason for revoking the certificate (0-10). Type "ipa help cert" for revocation reason details. 
    */
    RevocationReason int `json:"revocation_reason,omitempty"`
  
    /*
Owner user

    */
    OwnerUser *[]string `json:"owner_user,omitempty"`
  
    /*
Owner host

    */
    OwnerHost *[]string `json:"owner_host,omitempty"`
  
    /*
Owner service
Service principal alias
    */
    OwnerService *[]string `json:"owner_service,omitempty"`
  }

func (t *Cert) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Cert[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Cert%v", string(b))
}

type jsonCert struct {
  
    Cacn interface{} `json:"cacn"`
  
    Certificate interface{} `json:"certificate"`
  
    CertificateChain interface{} `json:"certificate_chain"`
  
    Subject interface{} `json:"subject"`
  
    SanRfc822name interface{} `json:"san_rfc822name"`
  
    SanDnsname interface{} `json:"san_dnsname"`
  
    SanX400address interface{} `json:"san_x400address"`
  
    SanDirectoryname interface{} `json:"san_directoryname"`
  
    SanEdipartyname interface{} `json:"san_edipartyname"`
  
    SanURI interface{} `json:"san_uri"`
  
    SanIpaddress interface{} `json:"san_ipaddress"`
  
    SanOid interface{} `json:"san_oid"`
  
    SanOtherUpn interface{} `json:"san_other_upn"`
  
    SanOtherKpn interface{} `json:"san_other_kpn"`
  
    SanOther interface{} `json:"san_other"`
  
    Issuer interface{} `json:"issuer"`
  
    ValidNotBefore interface{} `json:"valid_not_before"`
  
    ValidNotAfter interface{} `json:"valid_not_after"`
  
    Sha1Fingerprint interface{} `json:"sha1_fingerprint"`
  
    Sha256Fingerprint interface{} `json:"sha256_fingerprint"`
  
    SerialNumber interface{} `json:"serial_number"`
  
    SerialNumberHex interface{} `json:"serial_number_hex"`
  
    Status interface{} `json:"status"`
  
    Revoked interface{} `json:"revoked"`
  
    RevocationReason interface{} `json:"revocation_reason"`
  
    OwnerUser interface{} `json:"owner_user"`
  
    OwnerHost interface{} `json:"owner_host"`
  
    OwnerService interface{} `json:"owner_service"`
  }

func (out *Cert) UnmarshalJSON(data []byte) error {
  var in jsonCert
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.Cacn != nil {
    raw := in.Cacn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cacn = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Cacn = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Cacn: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Cacn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Certificate
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Certificate = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Certificate: %v; expected exactly one element", raw)
          }
          out.Certificate = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Certificate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CertificateChain != nil {
    raw := in.CertificateChain
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CertificateChain = &[]string{plainV}
      } else if sliceOk {
        
        out.CertificateChain = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field CertificateChain: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Subject
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Subject = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Subject: %v; expected exactly one element", raw)
          }
          out.Subject = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Subject: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanRfc822name != nil {
    raw := in.SanRfc822name
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanRfc822name = &[]string{plainV}
      } else if sliceOk {
        
        out.SanRfc822name = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanRfc822name: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanDnsname != nil {
    raw := in.SanDnsname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanDnsname = &[]interface{}{plainV}
      } else if sliceOk {
        
        out.SanDnsname = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanDnsname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanX400address != nil {
    raw := in.SanX400address
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanX400address = &[]string{plainV}
      } else if sliceOk {
        
        out.SanX400address = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanX400address: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanDirectoryname != nil {
    raw := in.SanDirectoryname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanDirectoryname = &[]string{plainV}
      } else if sliceOk {
        
        out.SanDirectoryname = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanDirectoryname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanEdipartyname != nil {
    raw := in.SanEdipartyname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanEdipartyname = &[]string{plainV}
      } else if sliceOk {
        
        out.SanEdipartyname = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanEdipartyname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanURI != nil {
    raw := in.SanURI
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanURI = &[]string{plainV}
      } else if sliceOk {
        
        out.SanURI = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanURI: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanIpaddress != nil {
    raw := in.SanIpaddress
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanIpaddress = &[]string{plainV}
      } else if sliceOk {
        
        out.SanIpaddress = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanIpaddress: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanOid != nil {
    raw := in.SanOid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanOid = &[]string{plainV}
      } else if sliceOk {
        
        out.SanOid = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanOid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanOtherUpn != nil {
    raw := in.SanOtherUpn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanOtherUpn = &[]string{plainV}
      } else if sliceOk {
        
        out.SanOtherUpn = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanOtherUpn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanOtherKpn != nil {
    raw := in.SanOtherKpn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanOtherKpn = &[]string{plainV}
      } else if sliceOk {
        
        out.SanOtherKpn = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanOtherKpn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanOther != nil {
    raw := in.SanOther
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanOther = &[]string{plainV}
      } else if sliceOk {
        
        out.SanOther = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanOther: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Issuer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Issuer = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Issuer: %v; expected exactly one element", raw)
          }
          out.Issuer = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Issuer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.ValidNotBefore
    plainV, plainOk := raw.(time.Time)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []time.Time
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(time.Time)
        
        if !itemOk {
          
          // See https://github.com/ccin2p3/go-freeipa/issues/1
          mapV, mapVOk := rawItem.(map[string]interface{})
          if mapVOk {
            timeV, err := tryParseFreeIPADatetimeMap(mapV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = timeV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ValidNotBefore = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field ValidNotBefore: %v; expected exactly one element", raw)
          }
          out.ValidNotBefore = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field ValidNotBefore: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.ValidNotAfter
    plainV, plainOk := raw.(time.Time)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []time.Time
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(time.Time)
        
        if !itemOk {
          
          // See https://github.com/ccin2p3/go-freeipa/issues/1
          mapV, mapVOk := rawItem.(map[string]interface{})
          if mapVOk {
            timeV, err := tryParseFreeIPADatetimeMap(mapV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = timeV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ValidNotAfter = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field ValidNotAfter: %v; expected exactly one element", raw)
          }
          out.ValidNotAfter = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field ValidNotAfter: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Sha1Fingerprint
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sha1Fingerprint = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Sha1Fingerprint: %v; expected exactly one element", raw)
          }
          out.Sha1Fingerprint = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Sha1Fingerprint: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Sha256Fingerprint
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sha256Fingerprint = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Sha256Fingerprint: %v; expected exactly one element", raw)
          }
          out.Sha256Fingerprint = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Sha256Fingerprint: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.SerialNumber
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field SerialNumber: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.SerialNumber = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field SerialNumber: %v; expected exactly one element", raw)
          }
          out.SerialNumber = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field SerialNumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.SerialNumberHex
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SerialNumberHex = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field SerialNumberHex: %v; expected exactly one element", raw)
          }
          out.SerialNumberHex = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field SerialNumberHex: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Status
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Status = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Status: %v; expected exactly one element", raw)
          }
          out.Status = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Status: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Revoked != nil {
    raw := in.Revoked
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Revoked = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Revoked = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Revoked: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Revoked: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.RevocationReason
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field RevocationReason: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.RevocationReason = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field RevocationReason: %v; expected exactly one element", raw)
          }
          out.RevocationReason = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field RevocationReason: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.OwnerUser != nil {
    raw := in.OwnerUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.OwnerUser = &[]string{plainV}
      } else if sliceOk {
        
        out.OwnerUser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field OwnerUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.OwnerHost != nil {
    raw := in.OwnerHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.OwnerHost = &[]string{plainV}
      } else if sliceOk {
        
        out.OwnerHost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field OwnerHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.OwnerService != nil {
    raw := in.OwnerService
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.OwnerService = &[]string{plainV}
      } else if sliceOk {
        
        out.OwnerService = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field OwnerService: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Certmap struct {
  
    /*
Domain

    */
    Domain interface{} `json:"domain,omitempty"`
  
    /*
User logins

    */
    UID *[]string `json:"uid,omitempty"`
  }

func (t *Certmap) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Certmap[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Certmap%v", string(b))
}

type jsonCertmap struct {
  
    Domain interface{} `json:"domain"`
  
    UID interface{} `json:"uid"`
  }

func (out *Certmap) UnmarshalJSON(data []byte) error {
  var in jsonCertmap
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Domain
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Domain = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Domain: %v; expected exactly one element", raw)
          }
          out.Domain = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Domain: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.UID != nil {
    raw := in.UID
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.UID = &[]string{plainV}
      } else if sliceOk {
        
        out.UID = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field UID: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Certmapconfig struct {
  
    /*
Prompt for the username
Prompt for the username when multiple identities are mapped to a certificate
    */
    Ipacertmappromptusername *bool `json:"ipacertmappromptusername,omitempty"`
  }

func (t *Certmapconfig) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Certmapconfig[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Certmapconfig%v", string(b))
}

type jsonCertmapconfig struct {
  
    Ipacertmappromptusername interface{} `json:"ipacertmappromptusername"`
  }

func (out *Certmapconfig) UnmarshalJSON(data []byte) error {
  var in jsonCertmapconfig
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.Ipacertmappromptusername != nil {
    raw := in.Ipacertmappromptusername
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacertmappromptusername = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipacertmappromptusername = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipacertmappromptusername: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipacertmappromptusername: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Certmaprule struct {
  
    /*
Rule name
Certificate Identity Mapping Rule name
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
Certificate Identity Mapping Rule description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Mapping rule
Rule used to map the certificate with a user entry
    */
    Ipacertmapmaprule *string `json:"ipacertmapmaprule,omitempty"`
  
    /*
Matching rule
Rule used to check if a certificate can be used for authentication
    */
    Ipacertmapmatchrule *string `json:"ipacertmapmatchrule,omitempty"`
  
    /*
Domain name
Domain where the user entry will be searched
    */
    Associateddomain *[]interface{} `json:"associateddomain,omitempty"`
  
    /*
Priority
Priority of the rule (higher number means lower priority
    */
    Ipacertmappriority *int `json:"ipacertmappriority,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  }

func (t *Certmaprule) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Certmaprule[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Certmaprule%v", string(b))
}

type jsonCertmaprule struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    Ipacertmapmaprule interface{} `json:"ipacertmapmaprule"`
  
    Ipacertmapmatchrule interface{} `json:"ipacertmapmatchrule"`
  
    Associateddomain interface{} `json:"associateddomain"`
  
    Ipacertmappriority interface{} `json:"ipacertmappriority"`
  
    Ipaenabledflag interface{} `json:"ipaenabledflag"`
  }

func (out *Certmaprule) UnmarshalJSON(data []byte) error {
  var in jsonCertmaprule
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipacertmapmaprule != nil {
    raw := in.Ipacertmapmaprule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacertmapmaprule = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipacertmapmaprule = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipacertmapmaprule: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipacertmapmaprule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipacertmapmatchrule != nil {
    raw := in.Ipacertmapmatchrule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacertmapmatchrule = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipacertmapmatchrule = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipacertmapmatchrule: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipacertmapmatchrule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Associateddomain != nil {
    raw := in.Associateddomain
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Associateddomain = &[]interface{}{plainV}
      } else if sliceOk {
        
        out.Associateddomain = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Associateddomain: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipacertmappriority != nil {
    raw := in.Ipacertmappriority
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipacertmappriority: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipacertmappriority = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipacertmappriority = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipacertmappriority: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipacertmappriority: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipaenabledflag != nil {
    raw := in.Ipaenabledflag
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaenabledflag = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipaenabledflag = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipaenabledflag: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaenabledflag: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Certprofile struct {
  
    /*
Profile ID
Profile ID for referring to this profile
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Profile configuration

    */
    Config string `json:"config,omitempty"`
  
    /*
Profile description
Brief description of this profile
    */
    Description string `json:"description,omitempty"`
  
    /*
Store issued certificates
Whether to store certs issued using this profile
    */
    Ipacertprofilestoreissued *bool `json:"ipacertprofilestoreissued,omitempty"`
  }

func (t *Certprofile) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Certprofile[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Certprofile%v", string(b))
}

type jsonCertprofile struct {
  
    Cn interface{} `json:"cn"`
  
    Config interface{} `json:"config"`
  
    Description interface{} `json:"description"`
  
    Ipacertprofilestoreissued interface{} `json:"ipacertprofilestoreissued"`
  }

func (out *Certprofile) UnmarshalJSON(data []byte) error {
  var in jsonCertprofile
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Config
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Config = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Config: %v; expected exactly one element", raw)
          }
          out.Config = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Config: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected exactly one element", raw)
          }
          out.Description = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipacertprofilestoreissued != nil {
    raw := in.Ipacertprofilestoreissued
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacertprofilestoreissued = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipacertprofilestoreissued = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipacertprofilestoreissued: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipacertprofilestoreissued: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Certreq struct {
  
    /*
Issuing CA
Name of issuing CA
    */
    Cacn *string `json:"cacn,omitempty"`
  
    /*
Certificate
Base-64 encoded certificate.
    */
    Certificate interface{} `json:"certificate,omitempty"`
  
    /*
Certificate chain
X.509 certificate chain
    */
    CertificateChain *[]string `json:"certificate_chain,omitempty"`
  
    /*
Subject

    */
    Subject string `json:"subject,omitempty"`
  
    /*
Subject email address

    */
    SanRfc822name *[]string `json:"san_rfc822name,omitempty"`
  
    /*
Subject DNS name

    */
    SanDnsname *[]interface{} `json:"san_dnsname,omitempty"`
  
    /*
Subject X.400 address

    */
    SanX400address *[]string `json:"san_x400address,omitempty"`
  
    /*
Subject directory name

    */
    SanDirectoryname *[]string `json:"san_directoryname,omitempty"`
  
    /*
Subject EDI Party name

    */
    SanEdipartyname *[]string `json:"san_edipartyname,omitempty"`
  
    /*
Subject URI

    */
    SanURI *[]string `json:"san_uri,omitempty"`
  
    /*
Subject IP Address

    */
    SanIpaddress *[]string `json:"san_ipaddress,omitempty"`
  
    /*
Subject OID

    */
    SanOid *[]string `json:"san_oid,omitempty"`
  
    /*
Subject UPN

    */
    SanOtherUpn *[]string `json:"san_other_upn,omitempty"`
  
    /*
Subject Kerberos principal name

    */
    SanOtherKpn *[]string `json:"san_other_kpn,omitempty"`
  
    /*
Subject Other Name

    */
    SanOther *[]string `json:"san_other,omitempty"`
  
    /*
Issuer
Issuer DN
    */
    Issuer string `json:"issuer,omitempty"`
  
    /*
Not Before

    */
    ValidNotBefore time.Time `json:"valid_not_before,omitempty"`
  
    /*
Not After

    */
    ValidNotAfter time.Time `json:"valid_not_after,omitempty"`
  
    /*
Fingerprint (SHA1)

    */
    Sha1Fingerprint string `json:"sha1_fingerprint,omitempty"`
  
    /*
Fingerprint (SHA256)

    */
    Sha256Fingerprint string `json:"sha256_fingerprint,omitempty"`
  
    /*
Serial number
Serial number in decimal or if prefixed with 0x in hexadecimal
    */
    SerialNumber int `json:"serial_number,omitempty"`
  
    /*
Serial number (hex)

    */
    SerialNumberHex string `json:"serial_number_hex,omitempty"`
  
    /*


    */
    RequestType string `json:"request_type,omitempty"`
  
    /*
Profile ID
Certificate Profile to use
    */
    ProfileID *string `json:"profile_id,omitempty"`
  
    /*
Request status

    */
    CertRequestStatus string `json:"cert_request_status,omitempty"`
  
    /*
Request id

    */
    RequestID int `json:"request_id,omitempty"`
  }

func (t *Certreq) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Certreq[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Certreq%v", string(b))
}

type jsonCertreq struct {
  
    Cacn interface{} `json:"cacn"`
  
    Certificate interface{} `json:"certificate"`
  
    CertificateChain interface{} `json:"certificate_chain"`
  
    Subject interface{} `json:"subject"`
  
    SanRfc822name interface{} `json:"san_rfc822name"`
  
    SanDnsname interface{} `json:"san_dnsname"`
  
    SanX400address interface{} `json:"san_x400address"`
  
    SanDirectoryname interface{} `json:"san_directoryname"`
  
    SanEdipartyname interface{} `json:"san_edipartyname"`
  
    SanURI interface{} `json:"san_uri"`
  
    SanIpaddress interface{} `json:"san_ipaddress"`
  
    SanOid interface{} `json:"san_oid"`
  
    SanOtherUpn interface{} `json:"san_other_upn"`
  
    SanOtherKpn interface{} `json:"san_other_kpn"`
  
    SanOther interface{} `json:"san_other"`
  
    Issuer interface{} `json:"issuer"`
  
    ValidNotBefore interface{} `json:"valid_not_before"`
  
    ValidNotAfter interface{} `json:"valid_not_after"`
  
    Sha1Fingerprint interface{} `json:"sha1_fingerprint"`
  
    Sha256Fingerprint interface{} `json:"sha256_fingerprint"`
  
    SerialNumber interface{} `json:"serial_number"`
  
    SerialNumberHex interface{} `json:"serial_number_hex"`
  
    RequestType interface{} `json:"request_type"`
  
    ProfileID interface{} `json:"profile_id"`
  
    CertRequestStatus interface{} `json:"cert_request_status"`
  
    RequestID interface{} `json:"request_id"`
  }

func (out *Certreq) UnmarshalJSON(data []byte) error {
  var in jsonCertreq
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.Cacn != nil {
    raw := in.Cacn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cacn = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Cacn = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Cacn: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Cacn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Certificate
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Certificate = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Certificate: %v; expected exactly one element", raw)
          }
          out.Certificate = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Certificate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CertificateChain != nil {
    raw := in.CertificateChain
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CertificateChain = &[]string{plainV}
      } else if sliceOk {
        
        out.CertificateChain = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field CertificateChain: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Subject
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Subject = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Subject: %v; expected exactly one element", raw)
          }
          out.Subject = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Subject: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanRfc822name != nil {
    raw := in.SanRfc822name
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanRfc822name = &[]string{plainV}
      } else if sliceOk {
        
        out.SanRfc822name = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanRfc822name: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanDnsname != nil {
    raw := in.SanDnsname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanDnsname = &[]interface{}{plainV}
      } else if sliceOk {
        
        out.SanDnsname = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanDnsname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanX400address != nil {
    raw := in.SanX400address
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanX400address = &[]string{plainV}
      } else if sliceOk {
        
        out.SanX400address = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanX400address: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanDirectoryname != nil {
    raw := in.SanDirectoryname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanDirectoryname = &[]string{plainV}
      } else if sliceOk {
        
        out.SanDirectoryname = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanDirectoryname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanEdipartyname != nil {
    raw := in.SanEdipartyname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanEdipartyname = &[]string{plainV}
      } else if sliceOk {
        
        out.SanEdipartyname = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanEdipartyname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanURI != nil {
    raw := in.SanURI
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanURI = &[]string{plainV}
      } else if sliceOk {
        
        out.SanURI = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanURI: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanIpaddress != nil {
    raw := in.SanIpaddress
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanIpaddress = &[]string{plainV}
      } else if sliceOk {
        
        out.SanIpaddress = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanIpaddress: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanOid != nil {
    raw := in.SanOid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanOid = &[]string{plainV}
      } else if sliceOk {
        
        out.SanOid = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanOid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanOtherUpn != nil {
    raw := in.SanOtherUpn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanOtherUpn = &[]string{plainV}
      } else if sliceOk {
        
        out.SanOtherUpn = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanOtherUpn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanOtherKpn != nil {
    raw := in.SanOtherKpn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanOtherKpn = &[]string{plainV}
      } else if sliceOk {
        
        out.SanOtherKpn = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanOtherKpn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SanOther != nil {
    raw := in.SanOther
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SanOther = &[]string{plainV}
      } else if sliceOk {
        
        out.SanOther = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field SanOther: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Issuer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Issuer = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Issuer: %v; expected exactly one element", raw)
          }
          out.Issuer = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Issuer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.ValidNotBefore
    plainV, plainOk := raw.(time.Time)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []time.Time
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(time.Time)
        
        if !itemOk {
          
          // See https://github.com/ccin2p3/go-freeipa/issues/1
          mapV, mapVOk := rawItem.(map[string]interface{})
          if mapVOk {
            timeV, err := tryParseFreeIPADatetimeMap(mapV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = timeV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ValidNotBefore = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field ValidNotBefore: %v; expected exactly one element", raw)
          }
          out.ValidNotBefore = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field ValidNotBefore: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.ValidNotAfter
    plainV, plainOk := raw.(time.Time)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []time.Time
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(time.Time)
        
        if !itemOk {
          
          // See https://github.com/ccin2p3/go-freeipa/issues/1
          mapV, mapVOk := rawItem.(map[string]interface{})
          if mapVOk {
            timeV, err := tryParseFreeIPADatetimeMap(mapV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = timeV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ValidNotAfter = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field ValidNotAfter: %v; expected exactly one element", raw)
          }
          out.ValidNotAfter = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field ValidNotAfter: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Sha1Fingerprint
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sha1Fingerprint = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Sha1Fingerprint: %v; expected exactly one element", raw)
          }
          out.Sha1Fingerprint = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Sha1Fingerprint: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Sha256Fingerprint
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sha256Fingerprint = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Sha256Fingerprint: %v; expected exactly one element", raw)
          }
          out.Sha256Fingerprint = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Sha256Fingerprint: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.SerialNumber
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field SerialNumber: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.SerialNumber = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field SerialNumber: %v; expected exactly one element", raw)
          }
          out.SerialNumber = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field SerialNumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.SerialNumberHex
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SerialNumberHex = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field SerialNumberHex: %v; expected exactly one element", raw)
          }
          out.SerialNumberHex = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field SerialNumberHex: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.RequestType
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.RequestType = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field RequestType: %v; expected exactly one element", raw)
          }
          out.RequestType = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field RequestType: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.ProfileID != nil {
    raw := in.ProfileID
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ProfileID = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.ProfileID = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field ProfileID: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field ProfileID: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.CertRequestStatus
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CertRequestStatus = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field CertRequestStatus: %v; expected exactly one element", raw)
          }
          out.CertRequestStatus = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field CertRequestStatus: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.RequestID
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field RequestID: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.RequestID = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field RequestID: %v; expected exactly one element", raw)
          }
          out.RequestID = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field RequestID: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Class struct {
  
    /*
Name

    */
    Name string `json:"name,omitempty"`
  
    /*
Version

    */
    Version string `json:"version,omitempty"`
  
    /*
Full name

    */
    FullName string `json:"full_name,omitempty"`
  
    /*
Documentation

    */
    Doc *string `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]string `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]string `json:"include,omitempty"`
  
    /*
Help topic

    */
    TopicTopic *string `json:"topic_topic,omitempty"`
  
    /*
Parameters

    */
    ParamsParam *[]string `json:"params_param,omitempty"`
  }

func (t *Class) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Class[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Class%v", string(b))
}

type jsonClass struct {
  
    Name interface{} `json:"name"`
  
    Version interface{} `json:"version"`
  
    FullName interface{} `json:"full_name"`
  
    Doc interface{} `json:"doc"`
  
    Exclude interface{} `json:"exclude"`
  
    Include interface{} `json:"include"`
  
    TopicTopic interface{} `json:"topic_topic"`
  
    ParamsParam interface{} `json:"params_param"`
  }

func (out *Class) UnmarshalJSON(data []byte) error {
  var in jsonClass
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Name
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Name = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Name: %v; expected exactly one element", raw)
          }
          out.Name = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Name: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Version
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Version = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Version: %v; expected exactly one element", raw)
          }
          out.Version = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Version: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.FullName
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.FullName = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field FullName: %v; expected exactly one element", raw)
          }
          out.FullName = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field FullName: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Doc != nil {
    raw := in.Doc
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Doc = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Doc = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Doc: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Doc: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Exclude != nil {
    raw := in.Exclude
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Exclude = &[]string{plainV}
      } else if sliceOk {
        
        out.Exclude = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Exclude: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Include != nil {
    raw := in.Include
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Include = &[]string{plainV}
      } else if sliceOk {
        
        out.Include = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Include: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.TopicTopic != nil {
    raw := in.TopicTopic
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.TopicTopic = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.TopicTopic = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field TopicTopic: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field TopicTopic: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.ParamsParam != nil {
    raw := in.ParamsParam
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ParamsParam = &[]string{plainV}
      } else if sliceOk {
        
        out.ParamsParam = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field ParamsParam: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Command struct {
  
    /*
Name

    */
    Name string `json:"name,omitempty"`
  
    /*
Version

    */
    Version string `json:"version,omitempty"`
  
    /*
Full name

    */
    FullName string `json:"full_name,omitempty"`
  
    /*
Documentation

    */
    Doc *string `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]string `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]string `json:"include,omitempty"`
  
    /*
Help topic

    */
    TopicTopic *string `json:"topic_topic,omitempty"`
  
    /*
Parameters

    */
    ParamsParam *[]string `json:"params_param,omitempty"`
  
    /*
Method of

    */
    ObjClass *string `json:"obj_class,omitempty"`
  
    /*
Method name

    */
    AttrName *string `json:"attr_name,omitempty"`
  }

func (t *Command) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Command[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Command%v", string(b))
}

type jsonCommand struct {
  
    Name interface{} `json:"name"`
  
    Version interface{} `json:"version"`
  
    FullName interface{} `json:"full_name"`
  
    Doc interface{} `json:"doc"`
  
    Exclude interface{} `json:"exclude"`
  
    Include interface{} `json:"include"`
  
    TopicTopic interface{} `json:"topic_topic"`
  
    ParamsParam interface{} `json:"params_param"`
  
    ObjClass interface{} `json:"obj_class"`
  
    AttrName interface{} `json:"attr_name"`
  }

func (out *Command) UnmarshalJSON(data []byte) error {
  var in jsonCommand
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Name
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Name = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Name: %v; expected exactly one element", raw)
          }
          out.Name = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Name: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Version
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Version = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Version: %v; expected exactly one element", raw)
          }
          out.Version = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Version: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.FullName
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.FullName = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field FullName: %v; expected exactly one element", raw)
          }
          out.FullName = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field FullName: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Doc != nil {
    raw := in.Doc
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Doc = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Doc = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Doc: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Doc: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Exclude != nil {
    raw := in.Exclude
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Exclude = &[]string{plainV}
      } else if sliceOk {
        
        out.Exclude = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Exclude: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Include != nil {
    raw := in.Include
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Include = &[]string{plainV}
      } else if sliceOk {
        
        out.Include = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Include: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.TopicTopic != nil {
    raw := in.TopicTopic
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.TopicTopic = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.TopicTopic = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field TopicTopic: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field TopicTopic: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.ParamsParam != nil {
    raw := in.ParamsParam
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ParamsParam = &[]string{plainV}
      } else if sliceOk {
        
        out.ParamsParam = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field ParamsParam: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.ObjClass != nil {
    raw := in.ObjClass
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ObjClass = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.ObjClass = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field ObjClass: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field ObjClass: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.AttrName != nil {
    raw := in.AttrName
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.AttrName = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.AttrName = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field AttrName: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field AttrName: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Config struct {
  
    /*
Maximum username length

    */
    Ipamaxusernamelength int `json:"ipamaxusernamelength,omitempty"`
  
    /*
Home directory base
Default location of home directories
    */
    Ipahomesrootdir string `json:"ipahomesrootdir,omitempty"`
  
    /*
Default shell
Default shell for new users
    */
    Ipadefaultloginshell string `json:"ipadefaultloginshell,omitempty"`
  
    /*
Default users group
Default group for new users
    */
    Ipadefaultprimarygroup string `json:"ipadefaultprimarygroup,omitempty"`
  
    /*
Default e-mail domain
Default e-mail domain
    */
    Ipadefaultemaildomain *string `json:"ipadefaultemaildomain,omitempty"`
  
    /*
Search time limit
Maximum amount of time (seconds) for a search (-1 or 0 is unlimited)
    */
    Ipasearchtimelimit int `json:"ipasearchtimelimit,omitempty"`
  
    /*
Search size limit
Maximum number of records to search (-1 or 0 is unlimited)
    */
    Ipasearchrecordslimit int `json:"ipasearchrecordslimit,omitempty"`
  
    /*
User search fields
A comma-separated list of fields to search in when searching for users
    */
    Ipausersearchfields string `json:"ipausersearchfields,omitempty"`
  
    /*
Group search fields
A comma-separated list of fields to search in when searching for groups
    */
    Ipagroupsearchfields string `json:"ipagroupsearchfields,omitempty"`
  
    /*
Enable migration mode
Enable migration mode
    */
    Ipamigrationenabled *bool `json:"ipamigrationenabled,omitempty"`
  
    /*
Certificate Subject base
Base for certificate subjects (OU=Test,O=Example)
    */
    Ipacertificatesubjectbase string `json:"ipacertificatesubjectbase,omitempty"`
  
    /*
Default group objectclasses
Default group objectclasses (comma-separated list)
    */
    Ipagroupobjectclasses []string `json:"ipagroupobjectclasses,omitempty"`
  
    /*
Default user objectclasses
Default user objectclasses (comma-separated list)
    */
    Ipauserobjectclasses []string `json:"ipauserobjectclasses,omitempty"`
  
    /*
Password Expiration Notification (days)
Number of days's notice of impending password expiration
    */
    Ipapwdexpadvnotify int `json:"ipapwdexpadvnotify,omitempty"`
  
    /*
Password plugin features
Extra hashes to generate in password plug-in
    */
    Ipaconfigstring *[]string `json:"ipaconfigstring,omitempty"`
  
    /*
SELinux user map order
Order in increasing priority of SELinux users, delimited by $
    */
    Ipaselinuxusermaporder string `json:"ipaselinuxusermaporder,omitempty"`
  
    /*
Default SELinux user
Default SELinux user when no match is found in SELinux map rule
    */
    Ipaselinuxusermapdefault *string `json:"ipaselinuxusermapdefault,omitempty"`
  
    /*
Default PAC types
Default types of PAC supported for services
    */
    Ipakrbauthzdata *[]string `json:"ipakrbauthzdata,omitempty"`
  
    /*
Default user authentication types
Default types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
IPA masters
List of all IPA masters
    */
    IpaMasterServer *[]string `json:"ipa_master_server,omitempty"`
  
    /*
Hidden IPA masters
List of all hidden IPA masters
    */
    IpaMasterHiddenServer *[]string `json:"ipa_master_hidden_server,omitempty"`
  
    /*
IPA master capable of PKINIT
IPA master which can process PKINIT requests
    */
    PkinitServerServer *[]string `json:"pkinit_server_server,omitempty"`
  
    /*
IPA CA servers
IPA servers configured as certificate authority
    */
    CaServerServer *[]string `json:"ca_server_server,omitempty"`
  
    /*
IPA NTP servers
IPA servers with enabled NTP
    */
    NtpServerServer *[]string `json:"ntp_server_server,omitempty"`
  
    /*
Hidden IPA CA servers
Hidden IPA servers configured as certificate authority
    */
    CaServerHiddenServer *[]string `json:"ca_server_hidden_server,omitempty"`
  
    /*
IPA CA renewal master
Renewal master for IPA certificate authority
    */
    CaRenewalMasterServer *string `json:"ca_renewal_master_server,omitempty"`
  
    /*
IPA KRA servers
IPA servers configured as key recovery agent
    */
    KraServerServer *[]string `json:"kra_server_server,omitempty"`
  
    /*
Hidden IPA KRA servers
Hidden IPA servers configured as key recovery agent
    */
    KraServerHiddenServer *[]string `json:"kra_server_hidden_server,omitempty"`
  
    /*
Domain resolution order
colon-separated list of domains used for short name qualification
    */
    Ipadomainresolutionorder *string `json:"ipadomainresolutionorder,omitempty"`
  
    /*
IPA DNS servers
IPA servers configured as domain name server
    */
    DNSServerServer *[]string `json:"dns_server_server,omitempty"`
  
    /*
Hidden IPA DNS servers
Hidden IPA servers configured as domain name server
    */
    DNSServerHiddenServer *[]string `json:"dns_server_hidden_server,omitempty"`
  
    /*
IPA DNSSec key master
DNSec key master
    */
    DnssecKeyMasterServer *string `json:"dnssec_key_master_server,omitempty"`
  }

func (t *Config) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Config[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Config%v", string(b))
}

type jsonConfig struct {
  
    Ipamaxusernamelength interface{} `json:"ipamaxusernamelength"`
  
    Ipahomesrootdir interface{} `json:"ipahomesrootdir"`
  
    Ipadefaultloginshell interface{} `json:"ipadefaultloginshell"`
  
    Ipadefaultprimarygroup interface{} `json:"ipadefaultprimarygroup"`
  
    Ipadefaultemaildomain interface{} `json:"ipadefaultemaildomain"`
  
    Ipasearchtimelimit interface{} `json:"ipasearchtimelimit"`
  
    Ipasearchrecordslimit interface{} `json:"ipasearchrecordslimit"`
  
    Ipausersearchfields interface{} `json:"ipausersearchfields"`
  
    Ipagroupsearchfields interface{} `json:"ipagroupsearchfields"`
  
    Ipamigrationenabled interface{} `json:"ipamigrationenabled"`
  
    Ipacertificatesubjectbase interface{} `json:"ipacertificatesubjectbase"`
  
    Ipagroupobjectclasses interface{} `json:"ipagroupobjectclasses"`
  
    Ipauserobjectclasses interface{} `json:"ipauserobjectclasses"`
  
    Ipapwdexpadvnotify interface{} `json:"ipapwdexpadvnotify"`
  
    Ipaconfigstring interface{} `json:"ipaconfigstring"`
  
    Ipaselinuxusermaporder interface{} `json:"ipaselinuxusermaporder"`
  
    Ipaselinuxusermapdefault interface{} `json:"ipaselinuxusermapdefault"`
  
    Ipakrbauthzdata interface{} `json:"ipakrbauthzdata"`
  
    Ipauserauthtype interface{} `json:"ipauserauthtype"`
  
    IpaMasterServer interface{} `json:"ipa_master_server"`
  
    IpaMasterHiddenServer interface{} `json:"ipa_master_hidden_server"`
  
    PkinitServerServer interface{} `json:"pkinit_server_server"`
  
    CaServerServer interface{} `json:"ca_server_server"`
  
    NtpServerServer interface{} `json:"ntp_server_server"`
  
    CaServerHiddenServer interface{} `json:"ca_server_hidden_server"`
  
    CaRenewalMasterServer interface{} `json:"ca_renewal_master_server"`
  
    KraServerServer interface{} `json:"kra_server_server"`
  
    KraServerHiddenServer interface{} `json:"kra_server_hidden_server"`
  
    Ipadomainresolutionorder interface{} `json:"ipadomainresolutionorder"`
  
    DNSServerServer interface{} `json:"dns_server_server"`
  
    DNSServerHiddenServer interface{} `json:"dns_server_hidden_server"`
  
    DnssecKeyMasterServer interface{} `json:"dnssec_key_master_server"`
  }

func (out *Config) UnmarshalJSON(data []byte) error {
  var in jsonConfig
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Ipamaxusernamelength
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipamaxusernamelength: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipamaxusernamelength = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipamaxusernamelength: %v; expected exactly one element", raw)
          }
          out.Ipamaxusernamelength = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipamaxusernamelength: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipahomesrootdir
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipahomesrootdir = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipahomesrootdir: %v; expected exactly one element", raw)
          }
          out.Ipahomesrootdir = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipahomesrootdir: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipadefaultloginshell
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipadefaultloginshell = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipadefaultloginshell: %v; expected exactly one element", raw)
          }
          out.Ipadefaultloginshell = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipadefaultloginshell: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipadefaultprimarygroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipadefaultprimarygroup = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipadefaultprimarygroup: %v; expected exactly one element", raw)
          }
          out.Ipadefaultprimarygroup = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipadefaultprimarygroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipadefaultemaildomain != nil {
    raw := in.Ipadefaultemaildomain
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipadefaultemaildomain = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipadefaultemaildomain = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipadefaultemaildomain: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipadefaultemaildomain: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipasearchtimelimit
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipasearchtimelimit: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipasearchtimelimit = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipasearchtimelimit: %v; expected exactly one element", raw)
          }
          out.Ipasearchtimelimit = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipasearchtimelimit: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipasearchrecordslimit
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipasearchrecordslimit: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipasearchrecordslimit = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipasearchrecordslimit: %v; expected exactly one element", raw)
          }
          out.Ipasearchrecordslimit = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipasearchrecordslimit: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipausersearchfields
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipausersearchfields = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipausersearchfields: %v; expected exactly one element", raw)
          }
          out.Ipausersearchfields = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipausersearchfields: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipagroupsearchfields
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipagroupsearchfields = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipagroupsearchfields: %v; expected exactly one element", raw)
          }
          out.Ipagroupsearchfields = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipagroupsearchfields: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipamigrationenabled != nil {
    raw := in.Ipamigrationenabled
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipamigrationenabled = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipamigrationenabled = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipamigrationenabled: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipamigrationenabled: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipacertificatesubjectbase
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacertificatesubjectbase = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipacertificatesubjectbase: %v; expected exactly one element", raw)
          }
          out.Ipacertificatesubjectbase = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipacertificatesubjectbase: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipagroupobjectclasses
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipagroupobjectclasses = []string{plainV}
      } else if sliceOk {
        
          if len(sliceV) < 1 {
            return fmt.Errorf("unexpected value for field Ipagroupobjectclasses: %v; expected at least one element", raw)
          }
        
        out.Ipagroupobjectclasses = sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipagroupobjectclasses: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipauserobjectclasses
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipauserobjectclasses = []string{plainV}
      } else if sliceOk {
        
          if len(sliceV) < 1 {
            return fmt.Errorf("unexpected value for field Ipauserobjectclasses: %v; expected at least one element", raw)
          }
        
        out.Ipauserobjectclasses = sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipauserobjectclasses: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipapwdexpadvnotify
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipapwdexpadvnotify: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipapwdexpadvnotify = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipapwdexpadvnotify: %v; expected exactly one element", raw)
          }
          out.Ipapwdexpadvnotify = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipapwdexpadvnotify: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipaconfigstring != nil {
    raw := in.Ipaconfigstring
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaconfigstring = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipaconfigstring = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipaconfigstring: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipaselinuxusermaporder
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaselinuxusermaporder = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipaselinuxusermaporder: %v; expected exactly one element", raw)
          }
          out.Ipaselinuxusermaporder = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaselinuxusermaporder: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipaselinuxusermapdefault != nil {
    raw := in.Ipaselinuxusermapdefault
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaselinuxusermapdefault = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipaselinuxusermapdefault = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipaselinuxusermapdefault: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaselinuxusermapdefault: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipakrbauthzdata != nil {
    raw := in.Ipakrbauthzdata
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipakrbauthzdata = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipakrbauthzdata = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipakrbauthzdata: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipauserauthtype != nil {
    raw := in.Ipauserauthtype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipauserauthtype = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipauserauthtype = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipauserauthtype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpaMasterServer != nil {
    raw := in.IpaMasterServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaMasterServer = &[]string{plainV}
      } else if sliceOk {
        
        out.IpaMasterServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field IpaMasterServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpaMasterHiddenServer != nil {
    raw := in.IpaMasterHiddenServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaMasterHiddenServer = &[]string{plainV}
      } else if sliceOk {
        
        out.IpaMasterHiddenServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field IpaMasterHiddenServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.PkinitServerServer != nil {
    raw := in.PkinitServerServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.PkinitServerServer = &[]string{plainV}
      } else if sliceOk {
        
        out.PkinitServerServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field PkinitServerServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CaServerServer != nil {
    raw := in.CaServerServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CaServerServer = &[]string{plainV}
      } else if sliceOk {
        
        out.CaServerServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field CaServerServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.NtpServerServer != nil {
    raw := in.NtpServerServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.NtpServerServer = &[]string{plainV}
      } else if sliceOk {
        
        out.NtpServerServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field NtpServerServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CaServerHiddenServer != nil {
    raw := in.CaServerHiddenServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CaServerHiddenServer = &[]string{plainV}
      } else if sliceOk {
        
        out.CaServerHiddenServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field CaServerHiddenServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CaRenewalMasterServer != nil {
    raw := in.CaRenewalMasterServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CaRenewalMasterServer = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.CaRenewalMasterServer = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field CaRenewalMasterServer: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field CaRenewalMasterServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.KraServerServer != nil {
    raw := in.KraServerServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.KraServerServer = &[]string{plainV}
      } else if sliceOk {
        
        out.KraServerServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field KraServerServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.KraServerHiddenServer != nil {
    raw := in.KraServerHiddenServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.KraServerHiddenServer = &[]string{plainV}
      } else if sliceOk {
        
        out.KraServerHiddenServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field KraServerHiddenServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipadomainresolutionorder != nil {
    raw := in.Ipadomainresolutionorder
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipadomainresolutionorder = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipadomainresolutionorder = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipadomainresolutionorder: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipadomainresolutionorder: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DNSServerServer != nil {
    raw := in.DNSServerServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DNSServerServer = &[]string{plainV}
      } else if sliceOk {
        
        out.DNSServerServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field DNSServerServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DNSServerHiddenServer != nil {
    raw := in.DNSServerHiddenServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DNSServerHiddenServer = &[]string{plainV}
      } else if sliceOk {
        
        out.DNSServerHiddenServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field DNSServerHiddenServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DnssecKeyMasterServer != nil {
    raw := in.DnssecKeyMasterServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DnssecKeyMasterServer = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DnssecKeyMasterServer = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DnssecKeyMasterServer: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DnssecKeyMasterServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Cosentry struct {
  
    /*


    */
    Cn string `json:"cn,omitempty"`
  
    /*


    */
    Krbpwdpolicyreference string `json:"krbpwdpolicyreference,omitempty"`
  
    /*


    */
    Cospriority int `json:"cospriority,omitempty"`
  }

func (t *Cosentry) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Cosentry[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Cosentry%v", string(b))
}

type jsonCosentry struct {
  
    Cn interface{} `json:"cn"`
  
    Krbpwdpolicyreference interface{} `json:"krbpwdpolicyreference"`
  
    Cospriority interface{} `json:"cospriority"`
  }

func (out *Cosentry) UnmarshalJSON(data []byte) error {
  var in jsonCosentry
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Krbpwdpolicyreference
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbpwdpolicyreference = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Krbpwdpolicyreference: %v; expected exactly one element", raw)
          }
          out.Krbpwdpolicyreference = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Krbpwdpolicyreference: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Cospriority
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Cospriority: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Cospriority = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cospriority: %v; expected exactly one element", raw)
          }
          out.Cospriority = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cospriority: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Delegation struct {
  
    /*
Delegation name
Delegation name
    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the delegation applies
    */
    Attrs []string `json:"attrs,omitempty"`
  
    /*
Member user group
User group to apply delegation to
    */
    Memberof string `json:"memberof,omitempty"`
  
    /*
User group
User group ACI grants access to
    */
    Group string `json:"group,omitempty"`
  
    /*
ACI

    */
    Aci string `json:"aci,omitempty"`
  }

func (t *Delegation) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Delegation[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Delegation%v", string(b))
}

type jsonDelegation struct {
  
    Aciname interface{} `json:"aciname"`
  
    Permissions interface{} `json:"permissions"`
  
    Attrs interface{} `json:"attrs"`
  
    Memberof interface{} `json:"memberof"`
  
    Group interface{} `json:"group"`
  
    Aci interface{} `json:"aci"`
  }

func (out *Delegation) UnmarshalJSON(data []byte) error {
  var in jsonDelegation
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Aciname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Aciname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Aciname: %v; expected exactly one element", raw)
          }
          out.Aciname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Aciname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Permissions != nil {
    raw := in.Permissions
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Permissions = &[]string{plainV}
      } else if sliceOk {
        
        out.Permissions = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Permissions: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Attrs
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Attrs = []string{plainV}
      } else if sliceOk {
        
          if len(sliceV) < 1 {
            return fmt.Errorf("unexpected value for field Attrs: %v; expected at least one element", raw)
          }
        
        out.Attrs = sliceV
      } else {
        return fmt.Errorf("unexpected value for field Attrs: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Memberof
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Memberof = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Memberof: %v; expected exactly one element", raw)
          }
          out.Memberof = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Memberof: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Group
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Group = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Group: %v; expected exactly one element", raw)
          }
          out.Group = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Group: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Aci
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Aci = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Aci: %v; expected exactly one element", raw)
          }
          out.Aci = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Aci: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type DNSSystemRecords struct {
  
    /*
IPA DNS records

    */
    IpaRecords *[]string `json:"ipa_records,omitempty"`
  
    /*
IPA location records

    */
    LocationRecords *[]string `json:"location_records,omitempty"`
  }

func (t *DNSSystemRecords) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("DNSSystemRecords[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("DNSSystemRecords%v", string(b))
}

type jsonDNSSystemRecords struct {
  
    IpaRecords interface{} `json:"ipa_records"`
  
    LocationRecords interface{} `json:"location_records"`
  }

func (out *DNSSystemRecords) UnmarshalJSON(data []byte) error {
  var in jsonDNSSystemRecords
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.IpaRecords != nil {
    raw := in.IpaRecords
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaRecords = &[]string{plainV}
      } else if sliceOk {
        
        out.IpaRecords = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field IpaRecords: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocationRecords != nil {
    raw := in.LocationRecords
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LocationRecords = &[]string{plainV}
      } else if sliceOk {
        
        out.LocationRecords = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field LocationRecords: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsa6record struct {
  
    /*
Record data

    */
    Data string `json:"data,omitempty"`
  }

func (t *Dnsa6record) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsa6record[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsa6record%v", string(b))
}

type jsonDnsa6record struct {
  
    Data interface{} `json:"data"`
  }

func (out *Dnsa6record) UnmarshalJSON(data []byte) error {
  var in jsonDnsa6record
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Data
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Data = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Data: %v; expected exactly one element", raw)
          }
          out.Data = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Data: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsaaaarecord struct {
  
    /*
IP Address

    */
    IPAddress string `json:"ip_address,omitempty"`
  }

func (t *Dnsaaaarecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsaaaarecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsaaaarecord%v", string(b))
}

type jsonDnsaaaarecord struct {
  
    IPAddress interface{} `json:"ip_address"`
  }

func (out *Dnsaaaarecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsaaaarecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.IPAddress
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IPAddress = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IPAddress: %v; expected exactly one element", raw)
          }
          out.IPAddress = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IPAddress: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsafsdbrecord struct {
  
    /*
Subtype

    */
    Subtype *int `json:"subtype,omitempty"`
  
    /*
Hostname

    */
    Hostname interface{} `json:"hostname,omitempty"`
  }

func (t *Dnsafsdbrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsafsdbrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsafsdbrecord%v", string(b))
}

type jsonDnsafsdbrecord struct {
  
    Subtype interface{} `json:"subtype"`
  
    Hostname interface{} `json:"hostname"`
  }

func (out *Dnsafsdbrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsafsdbrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.Subtype != nil {
    raw := in.Subtype
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Subtype: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Subtype = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Subtype = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Subtype: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Subtype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Hostname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Hostname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Hostname: %v; expected exactly one element", raw)
          }
          out.Hostname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Hostname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsaplrecord struct {
  }

func (t *Dnsaplrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsaplrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsaplrecord%v", string(b))
}

type jsonDnsaplrecord struct {
  }

func (out *Dnsaplrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsaplrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  return nil
}

type Dnsarecord struct {
  
    /*
IP Address

    */
    IPAddress string `json:"ip_address,omitempty"`
  }

func (t *Dnsarecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsarecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsarecord%v", string(b))
}

type jsonDnsarecord struct {
  
    IPAddress interface{} `json:"ip_address"`
  }

func (out *Dnsarecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsarecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.IPAddress
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IPAddress = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IPAddress: %v; expected exactly one element", raw)
          }
          out.IPAddress = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IPAddress: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnscertrecord struct {
  
    /*
Certificate Type

    */
    Type int `json:"type,omitempty"`
  
    /*
Key Tag

    */
    KeyTag int `json:"key_tag,omitempty"`
  
    /*
Algorithm

    */
    Algorithm int `json:"algorithm,omitempty"`
  
    /*
Certificate/CRL

    */
    CertificateOrCrl string `json:"certificate_or_crl,omitempty"`
  }

func (t *Dnscertrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnscertrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnscertrecord%v", string(b))
}

type jsonDnscertrecord struct {
  
    Type interface{} `json:"type"`
  
    KeyTag interface{} `json:"key_tag"`
  
    Algorithm interface{} `json:"algorithm"`
  
    CertificateOrCrl interface{} `json:"certificate_or_crl"`
  }

func (out *Dnscertrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnscertrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Type
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Type: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Type = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Type: %v; expected exactly one element", raw)
          }
          out.Type = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Type: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.KeyTag
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field KeyTag: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.KeyTag = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field KeyTag: %v; expected exactly one element", raw)
          }
          out.KeyTag = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field KeyTag: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Algorithm
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Algorithm: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Algorithm = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Algorithm: %v; expected exactly one element", raw)
          }
          out.Algorithm = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Algorithm: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.CertificateOrCrl
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CertificateOrCrl = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field CertificateOrCrl: %v; expected exactly one element", raw)
          }
          out.CertificateOrCrl = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field CertificateOrCrl: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnscnamerecord struct {
  
    /*
Hostname
A hostname which this alias hostname points to
    */
    Hostname interface{} `json:"hostname,omitempty"`
  }

func (t *Dnscnamerecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnscnamerecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnscnamerecord%v", string(b))
}

type jsonDnscnamerecord struct {
  
    Hostname interface{} `json:"hostname"`
  }

func (out *Dnscnamerecord) UnmarshalJSON(data []byte) error {
  var in jsonDnscnamerecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Hostname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Hostname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Hostname: %v; expected exactly one element", raw)
          }
          out.Hostname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Hostname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsconfig struct {
  
    /*
Global forwarders
Global forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Global forwarding policy. Set to "none" to disable any configured global forwarders.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records
    */
    Idnsallowsyncptr *bool `json:"idnsallowsyncptr,omitempty"`
  
    /*
Zone refresh interval
An interval between regular polls of the name server for new DNS zones
    */
    Idnszonerefresh *int `json:"idnszonerefresh,omitempty"`
  
    /*
IPA DNS version

    */
    Ipadnsversion *int `json:"ipadnsversion,omitempty"`
  
    /*
IPA DNS servers
List of IPA masters configured as DNS servers
    */
    DNSServerServer *[]string `json:"dns_server_server,omitempty"`
  
    /*
IPA DNSSec key master
IPA server configured as DNSSec key master
    */
    DnssecKeyMasterServer *string `json:"dnssec_key_master_server,omitempty"`
  }

func (t *Dnsconfig) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsconfig[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsconfig%v", string(b))
}

type jsonDnsconfig struct {
  
    Idnsforwarders interface{} `json:"idnsforwarders"`
  
    Idnsforwardpolicy interface{} `json:"idnsforwardpolicy"`
  
    Idnsallowsyncptr interface{} `json:"idnsallowsyncptr"`
  
    Idnszonerefresh interface{} `json:"idnszonerefresh"`
  
    Ipadnsversion interface{} `json:"ipadnsversion"`
  
    DNSServerServer interface{} `json:"dns_server_server"`
  
    DnssecKeyMasterServer interface{} `json:"dnssec_key_master_server"`
  }

func (out *Dnsconfig) UnmarshalJSON(data []byte) error {
  var in jsonDnsconfig
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.Idnsforwarders != nil {
    raw := in.Idnsforwarders
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsforwarders = &[]string{plainV}
      } else if sliceOk {
        
        out.Idnsforwarders = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Idnsforwarders: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsforwardpolicy != nil {
    raw := in.Idnsforwardpolicy
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsforwardpolicy = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnsforwardpolicy = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnsforwardpolicy: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsforwardpolicy: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsallowsyncptr != nil {
    raw := in.Idnsallowsyncptr
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsallowsyncptr = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnsallowsyncptr = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnsallowsyncptr: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsallowsyncptr: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnszonerefresh != nil {
    raw := in.Idnszonerefresh
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Idnszonerefresh: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Idnszonerefresh = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnszonerefresh = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnszonerefresh: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnszonerefresh: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipadnsversion != nil {
    raw := in.Ipadnsversion
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipadnsversion: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipadnsversion = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipadnsversion = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipadnsversion: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipadnsversion: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DNSServerServer != nil {
    raw := in.DNSServerServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DNSServerServer = &[]string{plainV}
      } else if sliceOk {
        
        out.DNSServerServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field DNSServerServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DnssecKeyMasterServer != nil {
    raw := in.DnssecKeyMasterServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DnssecKeyMasterServer = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DnssecKeyMasterServer = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DnssecKeyMasterServer: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DnssecKeyMasterServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsdhcidrecord struct {
  }

func (t *Dnsdhcidrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsdhcidrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsdhcidrecord%v", string(b))
}

type jsonDnsdhcidrecord struct {
  }

func (out *Dnsdhcidrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsdhcidrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  return nil
}

type Dnsdlvrecord struct {
  
    /*
Key Tag

    */
    KeyTag int `json:"key_tag,omitempty"`
  
    /*
Algorithm

    */
    Algorithm int `json:"algorithm,omitempty"`
  
    /*
Digest Type

    */
    DigestType int `json:"digest_type,omitempty"`
  
    /*
Digest

    */
    Digest string `json:"digest,omitempty"`
  }

func (t *Dnsdlvrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsdlvrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsdlvrecord%v", string(b))
}

type jsonDnsdlvrecord struct {
  
    KeyTag interface{} `json:"key_tag"`
  
    Algorithm interface{} `json:"algorithm"`
  
    DigestType interface{} `json:"digest_type"`
  
    Digest interface{} `json:"digest"`
  }

func (out *Dnsdlvrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsdlvrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.KeyTag
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field KeyTag: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.KeyTag = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field KeyTag: %v; expected exactly one element", raw)
          }
          out.KeyTag = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field KeyTag: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Algorithm
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Algorithm: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Algorithm = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Algorithm: %v; expected exactly one element", raw)
          }
          out.Algorithm = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Algorithm: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.DigestType
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field DigestType: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.DigestType = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field DigestType: %v; expected exactly one element", raw)
          }
          out.DigestType = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field DigestType: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Digest
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Digest = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Digest: %v; expected exactly one element", raw)
          }
          out.Digest = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Digest: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsdnamerecord struct {
  
    /*
Target

    */
    Target interface{} `json:"target,omitempty"`
  }

func (t *Dnsdnamerecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsdnamerecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsdnamerecord%v", string(b))
}

type jsonDnsdnamerecord struct {
  
    Target interface{} `json:"target"`
  }

func (out *Dnsdnamerecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsdnamerecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Target
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Target = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Target: %v; expected exactly one element", raw)
          }
          out.Target = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Target: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsdsrecord struct {
  
    /*
Key Tag

    */
    KeyTag int `json:"key_tag,omitempty"`
  
    /*
Algorithm

    */
    Algorithm int `json:"algorithm,omitempty"`
  
    /*
Digest Type

    */
    DigestType int `json:"digest_type,omitempty"`
  
    /*
Digest

    */
    Digest string `json:"digest,omitempty"`
  }

func (t *Dnsdsrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsdsrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsdsrecord%v", string(b))
}

type jsonDnsdsrecord struct {
  
    KeyTag interface{} `json:"key_tag"`
  
    Algorithm interface{} `json:"algorithm"`
  
    DigestType interface{} `json:"digest_type"`
  
    Digest interface{} `json:"digest"`
  }

func (out *Dnsdsrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsdsrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.KeyTag
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field KeyTag: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.KeyTag = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field KeyTag: %v; expected exactly one element", raw)
          }
          out.KeyTag = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field KeyTag: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Algorithm
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Algorithm: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Algorithm = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Algorithm: %v; expected exactly one element", raw)
          }
          out.Algorithm = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Algorithm: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.DigestType
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field DigestType: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.DigestType = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field DigestType: %v; expected exactly one element", raw)
          }
          out.DigestType = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field DigestType: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Digest
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Digest = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Digest: %v; expected exactly one element", raw)
          }
          out.Digest = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Digest: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsforwardzone struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname interface{} `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Active zone
Is zone active?
    */
    Idnszoneactive *bool `json:"idnszoneactive,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Managedby permission

    */
    Managedby string `json:"managedby,omitempty"`
  }

func (t *Dnsforwardzone) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsforwardzone[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsforwardzone%v", string(b))
}

type jsonDnsforwardzone struct {
  
    Idnsname interface{} `json:"idnsname"`
  
    NameFromIP interface{} `json:"name_from_ip"`
  
    Idnszoneactive interface{} `json:"idnszoneactive"`
  
    Idnsforwarders interface{} `json:"idnsforwarders"`
  
    Idnsforwardpolicy interface{} `json:"idnsforwardpolicy"`
  
    Managedby interface{} `json:"managedby"`
  }

func (out *Dnsforwardzone) UnmarshalJSON(data []byte) error {
  var in jsonDnsforwardzone
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Idnsname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Idnsname: %v; expected exactly one element", raw)
          }
          out.Idnsname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.NameFromIP != nil {
    raw := in.NameFromIP
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.NameFromIP = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.NameFromIP = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field NameFromIP: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field NameFromIP: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnszoneactive != nil {
    raw := in.Idnszoneactive
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnszoneactive = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnszoneactive = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnszoneactive: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnszoneactive: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsforwarders != nil {
    raw := in.Idnsforwarders
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsforwarders = &[]string{plainV}
      } else if sliceOk {
        
        out.Idnsforwarders = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Idnsforwarders: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsforwardpolicy != nil {
    raw := in.Idnsforwardpolicy
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsforwardpolicy = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnsforwardpolicy = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnsforwardpolicy: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsforwardpolicy: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Managedby
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Managedby = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Managedby: %v; expected exactly one element", raw)
          }
          out.Managedby = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Managedby: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnshiprecord struct {
  }

func (t *Dnshiprecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnshiprecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnshiprecord%v", string(b))
}

type jsonDnshiprecord struct {
  }

func (out *Dnshiprecord) UnmarshalJSON(data []byte) error {
  var in jsonDnshiprecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  return nil
}

type Dnsipseckeyrecord struct {
  }

func (t *Dnsipseckeyrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsipseckeyrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsipseckeyrecord%v", string(b))
}

type jsonDnsipseckeyrecord struct {
  }

func (out *Dnsipseckeyrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsipseckeyrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  return nil
}

type Dnskeyrecord struct {
  }

func (t *Dnskeyrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnskeyrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnskeyrecord%v", string(b))
}

type jsonDnskeyrecord struct {
  }

func (out *Dnskeyrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnskeyrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  return nil
}

type Dnskxrecord struct {
  
    /*
Preference
Preference given to this exchanger. Lower values are more preferred
    */
    Preference int `json:"preference,omitempty"`
  
    /*
Exchanger
A host willing to act as a key exchanger
    */
    Exchanger interface{} `json:"exchanger,omitempty"`
  }

func (t *Dnskxrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnskxrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnskxrecord%v", string(b))
}

type jsonDnskxrecord struct {
  
    Preference interface{} `json:"preference"`
  
    Exchanger interface{} `json:"exchanger"`
  }

func (out *Dnskxrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnskxrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Preference
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Preference: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Preference = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Preference: %v; expected exactly one element", raw)
          }
          out.Preference = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Preference: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Exchanger
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Exchanger = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Exchanger: %v; expected exactly one element", raw)
          }
          out.Exchanger = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Exchanger: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnslocrecord struct {
  
    /*
Degrees Latitude

    */
    LatDeg int `json:"lat_deg,omitempty"`
  
    /*
Minutes Latitude

    */
    LatMin *int `json:"lat_min,omitempty"`
  
    /*
Seconds Latitude

    */
    LatSec *float64 `json:"lat_sec,omitempty"`
  
    /*
Direction Latitude

    */
    LatDir string `json:"lat_dir,omitempty"`
  
    /*
Degrees Longitude

    */
    LonDeg int `json:"lon_deg,omitempty"`
  
    /*
Minutes Longitude

    */
    LonMin *int `json:"lon_min,omitempty"`
  
    /*
Seconds Longitude

    */
    LonSec *float64 `json:"lon_sec,omitempty"`
  
    /*
Direction Longitude

    */
    LonDir string `json:"lon_dir,omitempty"`
  
    /*
Altitude

    */
    Altitude float64 `json:"altitude,omitempty"`
  
    /*
Size

    */
    Size *float64 `json:"size,omitempty"`
  
    /*
Horizontal Precision

    */
    HPrecision *float64 `json:"h_precision,omitempty"`
  
    /*
Vertical Precision

    */
    VPrecision *float64 `json:"v_precision,omitempty"`
  }

func (t *Dnslocrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnslocrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnslocrecord%v", string(b))
}

type jsonDnslocrecord struct {
  
    LatDeg interface{} `json:"lat_deg"`
  
    LatMin interface{} `json:"lat_min"`
  
    LatSec interface{} `json:"lat_sec"`
  
    LatDir interface{} `json:"lat_dir"`
  
    LonDeg interface{} `json:"lon_deg"`
  
    LonMin interface{} `json:"lon_min"`
  
    LonSec interface{} `json:"lon_sec"`
  
    LonDir interface{} `json:"lon_dir"`
  
    Altitude interface{} `json:"altitude"`
  
    Size interface{} `json:"size"`
  
    HPrecision interface{} `json:"h_precision"`
  
    VPrecision interface{} `json:"v_precision"`
  }

func (out *Dnslocrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnslocrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.LatDeg
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field LatDeg: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.LatDeg = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field LatDeg: %v; expected exactly one element", raw)
          }
          out.LatDeg = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field LatDeg: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LatMin != nil {
    raw := in.LatMin
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field LatMin: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.LatMin = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LatMin = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LatMin: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LatMin: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LatSec != nil {
    raw := in.LatSec
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LatSec = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LatSec = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LatSec: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LatSec: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.LatDir
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LatDir = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field LatDir: %v; expected exactly one element", raw)
          }
          out.LatDir = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field LatDir: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.LonDeg
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field LonDeg: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.LonDeg = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field LonDeg: %v; expected exactly one element", raw)
          }
          out.LonDeg = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field LonDeg: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LonMin != nil {
    raw := in.LonMin
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field LonMin: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.LonMin = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LonMin = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LonMin: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LonMin: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LonSec != nil {
    raw := in.LonSec
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LonSec = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LonSec = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LonSec: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LonSec: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.LonDir
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LonDir = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field LonDir: %v; expected exactly one element", raw)
          }
          out.LonDir = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field LonDir: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Altitude
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Altitude = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Altitude: %v; expected exactly one element", raw)
          }
          out.Altitude = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Altitude: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Size != nil {
    raw := in.Size
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Size = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Size = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Size: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Size: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.HPrecision != nil {
    raw := in.HPrecision
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.HPrecision = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.HPrecision = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field HPrecision: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field HPrecision: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.VPrecision != nil {
    raw := in.VPrecision
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.VPrecision = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.VPrecision = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field VPrecision: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field VPrecision: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsmxrecord struct {
  
    /*
Preference
Preference given to this exchanger. Lower values are more preferred
    */
    Preference int `json:"preference,omitempty"`
  
    /*
Exchanger
A host willing to act as a mail exchanger
    */
    Exchanger interface{} `json:"exchanger,omitempty"`
  }

func (t *Dnsmxrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsmxrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsmxrecord%v", string(b))
}

type jsonDnsmxrecord struct {
  
    Preference interface{} `json:"preference"`
  
    Exchanger interface{} `json:"exchanger"`
  }

func (out *Dnsmxrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsmxrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Preference
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Preference: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Preference = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Preference: %v; expected exactly one element", raw)
          }
          out.Preference = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Preference: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Exchanger
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Exchanger = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Exchanger: %v; expected exactly one element", raw)
          }
          out.Exchanger = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Exchanger: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsnaptrrecord struct {
  
    /*
Order

    */
    Order int `json:"order,omitempty"`
  
    /*
Preference

    */
    Preference int `json:"preference,omitempty"`
  
    /*
Flags

    */
    Flags string `json:"flags,omitempty"`
  
    /*
Service

    */
    Service string `json:"service,omitempty"`
  
    /*
Regular Expression

    */
    Regexp string `json:"regexp,omitempty"`
  
    /*
Replacement

    */
    Replacement string `json:"replacement,omitempty"`
  }

func (t *Dnsnaptrrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsnaptrrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsnaptrrecord%v", string(b))
}

type jsonDnsnaptrrecord struct {
  
    Order interface{} `json:"order"`
  
    Preference interface{} `json:"preference"`
  
    Flags interface{} `json:"flags"`
  
    Service interface{} `json:"service"`
  
    Regexp interface{} `json:"regexp"`
  
    Replacement interface{} `json:"replacement"`
  }

func (out *Dnsnaptrrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsnaptrrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Order
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Order: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Order = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Order: %v; expected exactly one element", raw)
          }
          out.Order = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Order: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Preference
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Preference: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Preference = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Preference: %v; expected exactly one element", raw)
          }
          out.Preference = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Preference: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Flags
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Flags = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Flags: %v; expected exactly one element", raw)
          }
          out.Flags = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Flags: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Service
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Service = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Service: %v; expected exactly one element", raw)
          }
          out.Service = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Service: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Regexp
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Regexp = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Regexp: %v; expected exactly one element", raw)
          }
          out.Regexp = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Regexp: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Replacement
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Replacement = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Replacement: %v; expected exactly one element", raw)
          }
          out.Replacement = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Replacement: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsnsecrecord struct {
  }

func (t *Dnsnsecrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsnsecrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsnsecrecord%v", string(b))
}

type jsonDnsnsecrecord struct {
  }

func (out *Dnsnsecrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsnsecrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  return nil
}

type Dnsnsrecord struct {
  
    /*
Hostname

    */
    Hostname interface{} `json:"hostname,omitempty"`
  }

func (t *Dnsnsrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsnsrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsnsrecord%v", string(b))
}

type jsonDnsnsrecord struct {
  
    Hostname interface{} `json:"hostname"`
  }

func (out *Dnsnsrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsnsrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Hostname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Hostname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Hostname: %v; expected exactly one element", raw)
          }
          out.Hostname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Hostname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsptrrecord struct {
  
    /*
Hostname
The hostname this reverse record points to
    */
    Hostname interface{} `json:"hostname,omitempty"`
  }

func (t *Dnsptrrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsptrrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsptrrecord%v", string(b))
}

type jsonDnsptrrecord struct {
  
    Hostname interface{} `json:"hostname"`
  }

func (out *Dnsptrrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsptrrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Hostname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Hostname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Hostname: %v; expected exactly one element", raw)
          }
          out.Hostname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Hostname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsrecord struct {
  
    /*
Record name
Record name
    */
    Idnsname interface{} `json:"idnsname,omitempty"`
  
    /*
Time to live
Time to live
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
Records

    */
    Dnsrecords *interface{} `json:"dnsrecords,omitempty"`
  
    /*
Record type

    */
    Dnstype *string `json:"dnstype,omitempty"`
  
    /*
Record data

    */
    Dnsdata *string `json:"dnsdata,omitempty"`
  
    /*
A record
Raw A records
    */
    Arecord *[]string `json:"arecord,omitempty"`
  
    /*
A IP Address

    */
    APartIPAddress *string `json:"a_part_ip_address,omitempty"`
  
    /*
A Create reverse
Create reverse record for this IP Address
    */
    AExtraCreateReverse *bool `json:"a_extra_create_reverse,omitempty"`
  
    /*
AAAA record
Raw AAAA records
    */
    Aaaarecord *[]string `json:"aaaarecord,omitempty"`
  
    /*
AAAA IP Address

    */
    AaaaPartIPAddress *string `json:"aaaa_part_ip_address,omitempty"`
  
    /*
AAAA Create reverse
Create reverse record for this IP Address
    */
    AaaaExtraCreateReverse *bool `json:"aaaa_extra_create_reverse,omitempty"`
  
    /*
A6 record
Raw A6 records
    */
    A6record *[]string `json:"a6record,omitempty"`
  
    /*
A6 Record data

    */
    A6PartData *string `json:"a6_part_data,omitempty"`
  
    /*
AFSDB record
Raw AFSDB records
    */
    Afsdbrecord *[]string `json:"afsdbrecord,omitempty"`
  
    /*
AFSDB Subtype

    */
    AfsdbPartSubtype *int `json:"afsdb_part_subtype,omitempty"`
  
    /*
AFSDB Hostname

    */
    AfsdbPartHostname *interface{} `json:"afsdb_part_hostname,omitempty"`
  
    /*
APL record
Raw APL records
    */
    Aplrecord *[]string `json:"aplrecord,omitempty"`
  
    /*
CERT record
Raw CERT records
    */
    Certrecord *[]string `json:"certrecord,omitempty"`
  
    /*
CERT Certificate Type

    */
    CertPartType *int `json:"cert_part_type,omitempty"`
  
    /*
CERT Key Tag

    */
    CertPartKeyTag *int `json:"cert_part_key_tag,omitempty"`
  
    /*
CERT Algorithm

    */
    CertPartAlgorithm *int `json:"cert_part_algorithm,omitempty"`
  
    /*
CERT Certificate/CRL

    */
    CertPartCertificateOrCrl *string `json:"cert_part_certificate_or_crl,omitempty"`
  
    /*
CNAME record
Raw CNAME records
    */
    Cnamerecord *[]string `json:"cnamerecord,omitempty"`
  
    /*
CNAME Hostname
A hostname which this alias hostname points to
    */
    CnamePartHostname *interface{} `json:"cname_part_hostname,omitempty"`
  
    /*
DHCID record
Raw DHCID records
    */
    Dhcidrecord *[]string `json:"dhcidrecord,omitempty"`
  
    /*
DLV record
Raw DLV records
    */
    Dlvrecord *[]string `json:"dlvrecord,omitempty"`
  
    /*
DLV Key Tag

    */
    DlvPartKeyTag *int `json:"dlv_part_key_tag,omitempty"`
  
    /*
DLV Algorithm

    */
    DlvPartAlgorithm *int `json:"dlv_part_algorithm,omitempty"`
  
    /*
DLV Digest Type

    */
    DlvPartDigestType *int `json:"dlv_part_digest_type,omitempty"`
  
    /*
DLV Digest

    */
    DlvPartDigest *string `json:"dlv_part_digest,omitempty"`
  
    /*
DNAME record
Raw DNAME records
    */
    Dnamerecord *[]string `json:"dnamerecord,omitempty"`
  
    /*
DNAME Target

    */
    DnamePartTarget *interface{} `json:"dname_part_target,omitempty"`
  
    /*
DS record
Raw DS records
    */
    Dsrecord *[]string `json:"dsrecord,omitempty"`
  
    /*
DS Key Tag

    */
    DsPartKeyTag *int `json:"ds_part_key_tag,omitempty"`
  
    /*
DS Algorithm

    */
    DsPartAlgorithm *int `json:"ds_part_algorithm,omitempty"`
  
    /*
DS Digest Type

    */
    DsPartDigestType *int `json:"ds_part_digest_type,omitempty"`
  
    /*
DS Digest

    */
    DsPartDigest *string `json:"ds_part_digest,omitempty"`
  
    /*
HIP record
Raw HIP records
    */
    Hiprecord *[]string `json:"hiprecord,omitempty"`
  
    /*
IPSECKEY record
Raw IPSECKEY records
    */
    Ipseckeyrecord *[]string `json:"ipseckeyrecord,omitempty"`
  
    /*
KEY record
Raw KEY records
    */
    Keyrecord *[]string `json:"keyrecord,omitempty"`
  
    /*
KX record
Raw KX records
    */
    Kxrecord *[]string `json:"kxrecord,omitempty"`
  
    /*
KX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    KxPartPreference *int `json:"kx_part_preference,omitempty"`
  
    /*
KX Exchanger
A host willing to act as a key exchanger
    */
    KxPartExchanger *interface{} `json:"kx_part_exchanger,omitempty"`
  
    /*
LOC record
Raw LOC records
    */
    Locrecord *[]string `json:"locrecord,omitempty"`
  
    /*
LOC Degrees Latitude

    */
    LocPartLatDeg *int `json:"loc_part_lat_deg,omitempty"`
  
    /*
LOC Minutes Latitude

    */
    LocPartLatMin *int `json:"loc_part_lat_min,omitempty"`
  
    /*
LOC Seconds Latitude

    */
    LocPartLatSec *float64 `json:"loc_part_lat_sec,omitempty"`
  
    /*
LOC Direction Latitude

    */
    LocPartLatDir *string `json:"loc_part_lat_dir,omitempty"`
  
    /*
LOC Degrees Longitude

    */
    LocPartLonDeg *int `json:"loc_part_lon_deg,omitempty"`
  
    /*
LOC Minutes Longitude

    */
    LocPartLonMin *int `json:"loc_part_lon_min,omitempty"`
  
    /*
LOC Seconds Longitude

    */
    LocPartLonSec *float64 `json:"loc_part_lon_sec,omitempty"`
  
    /*
LOC Direction Longitude

    */
    LocPartLonDir *string `json:"loc_part_lon_dir,omitempty"`
  
    /*
LOC Altitude

    */
    LocPartAltitude *float64 `json:"loc_part_altitude,omitempty"`
  
    /*
LOC Size

    */
    LocPartSize *float64 `json:"loc_part_size,omitempty"`
  
    /*
LOC Horizontal Precision

    */
    LocPartHPrecision *float64 `json:"loc_part_h_precision,omitempty"`
  
    /*
LOC Vertical Precision

    */
    LocPartVPrecision *float64 `json:"loc_part_v_precision,omitempty"`
  
    /*
MX record
Raw MX records
    */
    Mxrecord *[]string `json:"mxrecord,omitempty"`
  
    /*
MX Preference
Preference given to this exchanger. Lower values are more preferred
    */
    MxPartPreference *int `json:"mx_part_preference,omitempty"`
  
    /*
MX Exchanger
A host willing to act as a mail exchanger
    */
    MxPartExchanger *interface{} `json:"mx_part_exchanger,omitempty"`
  
    /*
NAPTR record
Raw NAPTR records
    */
    Naptrrecord *[]string `json:"naptrrecord,omitempty"`
  
    /*
NAPTR Order

    */
    NaptrPartOrder *int `json:"naptr_part_order,omitempty"`
  
    /*
NAPTR Preference

    */
    NaptrPartPreference *int `json:"naptr_part_preference,omitempty"`
  
    /*
NAPTR Flags

    */
    NaptrPartFlags *string `json:"naptr_part_flags,omitempty"`
  
    /*
NAPTR Service

    */
    NaptrPartService *string `json:"naptr_part_service,omitempty"`
  
    /*
NAPTR Regular Expression

    */
    NaptrPartRegexp *string `json:"naptr_part_regexp,omitempty"`
  
    /*
NAPTR Replacement

    */
    NaptrPartReplacement *string `json:"naptr_part_replacement,omitempty"`
  
    /*
NS record
Raw NS records
    */
    Nsrecord *[]string `json:"nsrecord,omitempty"`
  
    /*
NS Hostname

    */
    NsPartHostname *interface{} `json:"ns_part_hostname,omitempty"`
  
    /*
NSEC record
Raw NSEC records
    */
    Nsecrecord *[]string `json:"nsecrecord,omitempty"`
  
    /*
PTR record
Raw PTR records
    */
    Ptrrecord *[]string `json:"ptrrecord,omitempty"`
  
    /*
PTR Hostname
The hostname this reverse record points to
    */
    PtrPartHostname *interface{} `json:"ptr_part_hostname,omitempty"`
  
    /*
RRSIG record
Raw RRSIG records
    */
    Rrsigrecord *[]string `json:"rrsigrecord,omitempty"`
  
    /*
RP record
Raw RP records
    */
    Rprecord *[]string `json:"rprecord,omitempty"`
  
    /*
SIG record
Raw SIG records
    */
    Sigrecord *[]string `json:"sigrecord,omitempty"`
  
    /*
SPF record
Raw SPF records
    */
    Spfrecord *[]string `json:"spfrecord,omitempty"`
  
    /*
SRV record
Raw SRV records
    */
    Srvrecord *[]string `json:"srvrecord,omitempty"`
  
    /*
SRV Priority (order)
Lower number means higher priority. Clients will attempt to contact the server with the lowest-numbered priority they can reach.
    */
    SrvPartPriority *int `json:"srv_part_priority,omitempty"`
  
    /*
SRV Weight
Relative weight for entries with the same priority.
    */
    SrvPartWeight *int `json:"srv_part_weight,omitempty"`
  
    /*
SRV Port

    */
    SrvPartPort *int `json:"srv_part_port,omitempty"`
  
    /*
SRV Target
The domain name of the target host or '.' if the service is decidedly not available at this domain
    */
    SrvPartTarget *interface{} `json:"srv_part_target,omitempty"`
  
    /*
SSHFP record
Raw SSHFP records
    */
    Sshfprecord *[]string `json:"sshfprecord,omitempty"`
  
    /*
SSHFP Algorithm

    */
    SshfpPartAlgorithm *int `json:"sshfp_part_algorithm,omitempty"`
  
    /*
SSHFP Fingerprint Type

    */
    SshfpPartFpType *int `json:"sshfp_part_fp_type,omitempty"`
  
    /*
SSHFP Fingerprint

    */
    SshfpPartFingerprint *string `json:"sshfp_part_fingerprint,omitempty"`
  
    /*
TLSA record
Raw TLSA records
    */
    Tlsarecord *[]string `json:"tlsarecord,omitempty"`
  
    /*
TLSA Certificate Usage

    */
    TlsaPartCertUsage *int `json:"tlsa_part_cert_usage,omitempty"`
  
    /*
TLSA Selector

    */
    TlsaPartSelector *int `json:"tlsa_part_selector,omitempty"`
  
    /*
TLSA Matching Type

    */
    TlsaPartMatchingType *int `json:"tlsa_part_matching_type,omitempty"`
  
    /*
TLSA Certificate Association Data

    */
    TlsaPartCertAssociationData *string `json:"tlsa_part_cert_association_data,omitempty"`
  
    /*
TXT record
Raw TXT records
    */
    Txtrecord *[]string `json:"txtrecord,omitempty"`
  
    /*
TXT Text Data

    */
    TxtPartData *string `json:"txt_part_data,omitempty"`
  
    /*
URI record
Raw URI records
    */
    Urirecord *[]string `json:"urirecord,omitempty"`
  
    /*
URI Priority (order)
Lower number means higher priority. Clients will attempt to contact the URI with the lowest-numbered priority they can reach.
    */
    URIPartPriority *int `json:"uri_part_priority,omitempty"`
  
    /*
URI Weight
Relative weight for entries with the same priority.
    */
    URIPartWeight *int `json:"uri_part_weight,omitempty"`
  
    /*
URI Target Uniform Resource Identifier
Target Uniform Resource Identifier according to RFC 3986
    */
    URIPartTarget *string `json:"uri_part_target,omitempty"`
  }

func (t *Dnsrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsrecord%v", string(b))
}

type jsonDnsrecord struct {
  
    Idnsname interface{} `json:"idnsname"`
  
    Dnsttl interface{} `json:"dnsttl"`
  
    Dnsclass interface{} `json:"dnsclass"`
  
    Dnsrecords interface{} `json:"dnsrecords"`
  
    Dnstype interface{} `json:"dnstype"`
  
    Dnsdata interface{} `json:"dnsdata"`
  
    Arecord interface{} `json:"arecord"`
  
    APartIPAddress interface{} `json:"a_part_ip_address"`
  
    AExtraCreateReverse interface{} `json:"a_extra_create_reverse"`
  
    Aaaarecord interface{} `json:"aaaarecord"`
  
    AaaaPartIPAddress interface{} `json:"aaaa_part_ip_address"`
  
    AaaaExtraCreateReverse interface{} `json:"aaaa_extra_create_reverse"`
  
    A6record interface{} `json:"a6record"`
  
    A6PartData interface{} `json:"a6_part_data"`
  
    Afsdbrecord interface{} `json:"afsdbrecord"`
  
    AfsdbPartSubtype interface{} `json:"afsdb_part_subtype"`
  
    AfsdbPartHostname interface{} `json:"afsdb_part_hostname"`
  
    Aplrecord interface{} `json:"aplrecord"`
  
    Certrecord interface{} `json:"certrecord"`
  
    CertPartType interface{} `json:"cert_part_type"`
  
    CertPartKeyTag interface{} `json:"cert_part_key_tag"`
  
    CertPartAlgorithm interface{} `json:"cert_part_algorithm"`
  
    CertPartCertificateOrCrl interface{} `json:"cert_part_certificate_or_crl"`
  
    Cnamerecord interface{} `json:"cnamerecord"`
  
    CnamePartHostname interface{} `json:"cname_part_hostname"`
  
    Dhcidrecord interface{} `json:"dhcidrecord"`
  
    Dlvrecord interface{} `json:"dlvrecord"`
  
    DlvPartKeyTag interface{} `json:"dlv_part_key_tag"`
  
    DlvPartAlgorithm interface{} `json:"dlv_part_algorithm"`
  
    DlvPartDigestType interface{} `json:"dlv_part_digest_type"`
  
    DlvPartDigest interface{} `json:"dlv_part_digest"`
  
    Dnamerecord interface{} `json:"dnamerecord"`
  
    DnamePartTarget interface{} `json:"dname_part_target"`
  
    Dsrecord interface{} `json:"dsrecord"`
  
    DsPartKeyTag interface{} `json:"ds_part_key_tag"`
  
    DsPartAlgorithm interface{} `json:"ds_part_algorithm"`
  
    DsPartDigestType interface{} `json:"ds_part_digest_type"`
  
    DsPartDigest interface{} `json:"ds_part_digest"`
  
    Hiprecord interface{} `json:"hiprecord"`
  
    Ipseckeyrecord interface{} `json:"ipseckeyrecord"`
  
    Keyrecord interface{} `json:"keyrecord"`
  
    Kxrecord interface{} `json:"kxrecord"`
  
    KxPartPreference interface{} `json:"kx_part_preference"`
  
    KxPartExchanger interface{} `json:"kx_part_exchanger"`
  
    Locrecord interface{} `json:"locrecord"`
  
    LocPartLatDeg interface{} `json:"loc_part_lat_deg"`
  
    LocPartLatMin interface{} `json:"loc_part_lat_min"`
  
    LocPartLatSec interface{} `json:"loc_part_lat_sec"`
  
    LocPartLatDir interface{} `json:"loc_part_lat_dir"`
  
    LocPartLonDeg interface{} `json:"loc_part_lon_deg"`
  
    LocPartLonMin interface{} `json:"loc_part_lon_min"`
  
    LocPartLonSec interface{} `json:"loc_part_lon_sec"`
  
    LocPartLonDir interface{} `json:"loc_part_lon_dir"`
  
    LocPartAltitude interface{} `json:"loc_part_altitude"`
  
    LocPartSize interface{} `json:"loc_part_size"`
  
    LocPartHPrecision interface{} `json:"loc_part_h_precision"`
  
    LocPartVPrecision interface{} `json:"loc_part_v_precision"`
  
    Mxrecord interface{} `json:"mxrecord"`
  
    MxPartPreference interface{} `json:"mx_part_preference"`
  
    MxPartExchanger interface{} `json:"mx_part_exchanger"`
  
    Naptrrecord interface{} `json:"naptrrecord"`
  
    NaptrPartOrder interface{} `json:"naptr_part_order"`
  
    NaptrPartPreference interface{} `json:"naptr_part_preference"`
  
    NaptrPartFlags interface{} `json:"naptr_part_flags"`
  
    NaptrPartService interface{} `json:"naptr_part_service"`
  
    NaptrPartRegexp interface{} `json:"naptr_part_regexp"`
  
    NaptrPartReplacement interface{} `json:"naptr_part_replacement"`
  
    Nsrecord interface{} `json:"nsrecord"`
  
    NsPartHostname interface{} `json:"ns_part_hostname"`
  
    Nsecrecord interface{} `json:"nsecrecord"`
  
    Ptrrecord interface{} `json:"ptrrecord"`
  
    PtrPartHostname interface{} `json:"ptr_part_hostname"`
  
    Rrsigrecord interface{} `json:"rrsigrecord"`
  
    Rprecord interface{} `json:"rprecord"`
  
    Sigrecord interface{} `json:"sigrecord"`
  
    Spfrecord interface{} `json:"spfrecord"`
  
    Srvrecord interface{} `json:"srvrecord"`
  
    SrvPartPriority interface{} `json:"srv_part_priority"`
  
    SrvPartWeight interface{} `json:"srv_part_weight"`
  
    SrvPartPort interface{} `json:"srv_part_port"`
  
    SrvPartTarget interface{} `json:"srv_part_target"`
  
    Sshfprecord interface{} `json:"sshfprecord"`
  
    SshfpPartAlgorithm interface{} `json:"sshfp_part_algorithm"`
  
    SshfpPartFpType interface{} `json:"sshfp_part_fp_type"`
  
    SshfpPartFingerprint interface{} `json:"sshfp_part_fingerprint"`
  
    Tlsarecord interface{} `json:"tlsarecord"`
  
    TlsaPartCertUsage interface{} `json:"tlsa_part_cert_usage"`
  
    TlsaPartSelector interface{} `json:"tlsa_part_selector"`
  
    TlsaPartMatchingType interface{} `json:"tlsa_part_matching_type"`
  
    TlsaPartCertAssociationData interface{} `json:"tlsa_part_cert_association_data"`
  
    Txtrecord interface{} `json:"txtrecord"`
  
    TxtPartData interface{} `json:"txt_part_data"`
  
    Urirecord interface{} `json:"urirecord"`
  
    URIPartPriority interface{} `json:"uri_part_priority"`
  
    URIPartWeight interface{} `json:"uri_part_weight"`
  
    URIPartTarget interface{} `json:"uri_part_target"`
  }

func (out *Dnsrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Idnsname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Idnsname: %v; expected exactly one element", raw)
          }
          out.Idnsname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dnsttl != nil {
    raw := in.Dnsttl
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Dnsttl: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Dnsttl = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Dnsttl = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Dnsttl: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Dnsttl: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dnsclass != nil {
    raw := in.Dnsclass
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Dnsclass = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Dnsclass = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Dnsclass: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Dnsclass: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dnsrecords != nil {
    raw := in.Dnsrecords
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Dnsrecords = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Dnsrecords = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Dnsrecords: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Dnsrecords: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dnstype != nil {
    raw := in.Dnstype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Dnstype = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Dnstype = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Dnstype: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Dnstype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dnsdata != nil {
    raw := in.Dnsdata
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Dnsdata = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Dnsdata = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Dnsdata: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Dnsdata: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Arecord != nil {
    raw := in.Arecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Arecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Arecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Arecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.APartIPAddress != nil {
    raw := in.APartIPAddress
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.APartIPAddress = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.APartIPAddress = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field APartIPAddress: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field APartIPAddress: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.AExtraCreateReverse != nil {
    raw := in.AExtraCreateReverse
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.AExtraCreateReverse = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.AExtraCreateReverse = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field AExtraCreateReverse: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field AExtraCreateReverse: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Aaaarecord != nil {
    raw := in.Aaaarecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Aaaarecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Aaaarecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Aaaarecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.AaaaPartIPAddress != nil {
    raw := in.AaaaPartIPAddress
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.AaaaPartIPAddress = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.AaaaPartIPAddress = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field AaaaPartIPAddress: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field AaaaPartIPAddress: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.AaaaExtraCreateReverse != nil {
    raw := in.AaaaExtraCreateReverse
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.AaaaExtraCreateReverse = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.AaaaExtraCreateReverse = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field AaaaExtraCreateReverse: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field AaaaExtraCreateReverse: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.A6record != nil {
    raw := in.A6record
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.A6record = &[]string{plainV}
      } else if sliceOk {
        
        out.A6record = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field A6record: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.A6PartData != nil {
    raw := in.A6PartData
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.A6PartData = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.A6PartData = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field A6PartData: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field A6PartData: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Afsdbrecord != nil {
    raw := in.Afsdbrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Afsdbrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Afsdbrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Afsdbrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.AfsdbPartSubtype != nil {
    raw := in.AfsdbPartSubtype
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field AfsdbPartSubtype: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.AfsdbPartSubtype = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.AfsdbPartSubtype = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field AfsdbPartSubtype: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field AfsdbPartSubtype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.AfsdbPartHostname != nil {
    raw := in.AfsdbPartHostname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.AfsdbPartHostname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.AfsdbPartHostname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field AfsdbPartHostname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field AfsdbPartHostname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Aplrecord != nil {
    raw := in.Aplrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Aplrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Aplrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Aplrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Certrecord != nil {
    raw := in.Certrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Certrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Certrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Certrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CertPartType != nil {
    raw := in.CertPartType
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field CertPartType: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.CertPartType = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.CertPartType = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field CertPartType: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field CertPartType: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CertPartKeyTag != nil {
    raw := in.CertPartKeyTag
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field CertPartKeyTag: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.CertPartKeyTag = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.CertPartKeyTag = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field CertPartKeyTag: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field CertPartKeyTag: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CertPartAlgorithm != nil {
    raw := in.CertPartAlgorithm
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field CertPartAlgorithm: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.CertPartAlgorithm = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.CertPartAlgorithm = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field CertPartAlgorithm: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field CertPartAlgorithm: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CertPartCertificateOrCrl != nil {
    raw := in.CertPartCertificateOrCrl
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CertPartCertificateOrCrl = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.CertPartCertificateOrCrl = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field CertPartCertificateOrCrl: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field CertPartCertificateOrCrl: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Cnamerecord != nil {
    raw := in.Cnamerecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cnamerecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Cnamerecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Cnamerecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CnamePartHostname != nil {
    raw := in.CnamePartHostname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CnamePartHostname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.CnamePartHostname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field CnamePartHostname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field CnamePartHostname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dhcidrecord != nil {
    raw := in.Dhcidrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Dhcidrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Dhcidrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Dhcidrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dlvrecord != nil {
    raw := in.Dlvrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Dlvrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Dlvrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Dlvrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DlvPartKeyTag != nil {
    raw := in.DlvPartKeyTag
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field DlvPartKeyTag: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.DlvPartKeyTag = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DlvPartKeyTag = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DlvPartKeyTag: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DlvPartKeyTag: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DlvPartAlgorithm != nil {
    raw := in.DlvPartAlgorithm
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field DlvPartAlgorithm: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.DlvPartAlgorithm = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DlvPartAlgorithm = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DlvPartAlgorithm: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DlvPartAlgorithm: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DlvPartDigestType != nil {
    raw := in.DlvPartDigestType
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field DlvPartDigestType: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.DlvPartDigestType = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DlvPartDigestType = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DlvPartDigestType: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DlvPartDigestType: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DlvPartDigest != nil {
    raw := in.DlvPartDigest
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DlvPartDigest = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DlvPartDigest = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DlvPartDigest: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DlvPartDigest: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dnamerecord != nil {
    raw := in.Dnamerecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Dnamerecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Dnamerecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Dnamerecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DnamePartTarget != nil {
    raw := in.DnamePartTarget
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DnamePartTarget = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DnamePartTarget = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DnamePartTarget: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DnamePartTarget: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dsrecord != nil {
    raw := in.Dsrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Dsrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Dsrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Dsrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DsPartKeyTag != nil {
    raw := in.DsPartKeyTag
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field DsPartKeyTag: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.DsPartKeyTag = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DsPartKeyTag = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DsPartKeyTag: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DsPartKeyTag: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DsPartAlgorithm != nil {
    raw := in.DsPartAlgorithm
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field DsPartAlgorithm: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.DsPartAlgorithm = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DsPartAlgorithm = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DsPartAlgorithm: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DsPartAlgorithm: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DsPartDigestType != nil {
    raw := in.DsPartDigestType
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field DsPartDigestType: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.DsPartDigestType = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DsPartDigestType = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DsPartDigestType: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DsPartDigestType: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DsPartDigest != nil {
    raw := in.DsPartDigest
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DsPartDigest = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DsPartDigest = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DsPartDigest: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DsPartDigest: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Hiprecord != nil {
    raw := in.Hiprecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Hiprecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Hiprecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Hiprecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipseckeyrecord != nil {
    raw := in.Ipseckeyrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipseckeyrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipseckeyrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipseckeyrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Keyrecord != nil {
    raw := in.Keyrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Keyrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Keyrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Keyrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Kxrecord != nil {
    raw := in.Kxrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Kxrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Kxrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Kxrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.KxPartPreference != nil {
    raw := in.KxPartPreference
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field KxPartPreference: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.KxPartPreference = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.KxPartPreference = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field KxPartPreference: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field KxPartPreference: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.KxPartExchanger != nil {
    raw := in.KxPartExchanger
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.KxPartExchanger = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.KxPartExchanger = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field KxPartExchanger: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field KxPartExchanger: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Locrecord != nil {
    raw := in.Locrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Locrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Locrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Locrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartLatDeg != nil {
    raw := in.LocPartLatDeg
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field LocPartLatDeg: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.LocPartLatDeg = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartLatDeg = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartLatDeg: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartLatDeg: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartLatMin != nil {
    raw := in.LocPartLatMin
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field LocPartLatMin: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.LocPartLatMin = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartLatMin = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartLatMin: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartLatMin: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartLatSec != nil {
    raw := in.LocPartLatSec
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LocPartLatSec = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartLatSec = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartLatSec: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartLatSec: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartLatDir != nil {
    raw := in.LocPartLatDir
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LocPartLatDir = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartLatDir = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartLatDir: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartLatDir: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartLonDeg != nil {
    raw := in.LocPartLonDeg
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field LocPartLonDeg: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.LocPartLonDeg = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartLonDeg = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartLonDeg: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartLonDeg: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartLonMin != nil {
    raw := in.LocPartLonMin
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field LocPartLonMin: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.LocPartLonMin = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartLonMin = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartLonMin: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartLonMin: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartLonSec != nil {
    raw := in.LocPartLonSec
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LocPartLonSec = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartLonSec = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartLonSec: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartLonSec: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartLonDir != nil {
    raw := in.LocPartLonDir
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LocPartLonDir = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartLonDir = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartLonDir: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartLonDir: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartAltitude != nil {
    raw := in.LocPartAltitude
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LocPartAltitude = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartAltitude = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartAltitude: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartAltitude: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartSize != nil {
    raw := in.LocPartSize
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LocPartSize = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartSize = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartSize: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartSize: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartHPrecision != nil {
    raw := in.LocPartHPrecision
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LocPartHPrecision = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartHPrecision = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartHPrecision: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartHPrecision: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.LocPartVPrecision != nil {
    raw := in.LocPartVPrecision
    plainV, plainOk := raw.(float64)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []float64
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(float64)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.LocPartVPrecision = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.LocPartVPrecision = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field LocPartVPrecision: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field LocPartVPrecision: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Mxrecord != nil {
    raw := in.Mxrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Mxrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Mxrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Mxrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MxPartPreference != nil {
    raw := in.MxPartPreference
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field MxPartPreference: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.MxPartPreference = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.MxPartPreference = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field MxPartPreference: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field MxPartPreference: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MxPartExchanger != nil {
    raw := in.MxPartExchanger
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MxPartExchanger = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.MxPartExchanger = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field MxPartExchanger: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field MxPartExchanger: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Naptrrecord != nil {
    raw := in.Naptrrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Naptrrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Naptrrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Naptrrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.NaptrPartOrder != nil {
    raw := in.NaptrPartOrder
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field NaptrPartOrder: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.NaptrPartOrder = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.NaptrPartOrder = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field NaptrPartOrder: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field NaptrPartOrder: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.NaptrPartPreference != nil {
    raw := in.NaptrPartPreference
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field NaptrPartPreference: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.NaptrPartPreference = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.NaptrPartPreference = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field NaptrPartPreference: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field NaptrPartPreference: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.NaptrPartFlags != nil {
    raw := in.NaptrPartFlags
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.NaptrPartFlags = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.NaptrPartFlags = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field NaptrPartFlags: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field NaptrPartFlags: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.NaptrPartService != nil {
    raw := in.NaptrPartService
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.NaptrPartService = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.NaptrPartService = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field NaptrPartService: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field NaptrPartService: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.NaptrPartRegexp != nil {
    raw := in.NaptrPartRegexp
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.NaptrPartRegexp = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.NaptrPartRegexp = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field NaptrPartRegexp: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field NaptrPartRegexp: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.NaptrPartReplacement != nil {
    raw := in.NaptrPartReplacement
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.NaptrPartReplacement = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.NaptrPartReplacement = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field NaptrPartReplacement: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field NaptrPartReplacement: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nsrecord != nil {
    raw := in.Nsrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nsrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Nsrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Nsrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.NsPartHostname != nil {
    raw := in.NsPartHostname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.NsPartHostname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.NsPartHostname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field NsPartHostname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field NsPartHostname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nsecrecord != nil {
    raw := in.Nsecrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nsecrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Nsecrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Nsecrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ptrrecord != nil {
    raw := in.Ptrrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ptrrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Ptrrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ptrrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.PtrPartHostname != nil {
    raw := in.PtrPartHostname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.PtrPartHostname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.PtrPartHostname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field PtrPartHostname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field PtrPartHostname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Rrsigrecord != nil {
    raw := in.Rrsigrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Rrsigrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Rrsigrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Rrsigrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Rprecord != nil {
    raw := in.Rprecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Rprecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Rprecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Rprecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Sigrecord != nil {
    raw := in.Sigrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sigrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Sigrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Sigrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Spfrecord != nil {
    raw := in.Spfrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Spfrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Spfrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Spfrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Srvrecord != nil {
    raw := in.Srvrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Srvrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Srvrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Srvrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SrvPartPriority != nil {
    raw := in.SrvPartPriority
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field SrvPartPriority: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.SrvPartPriority = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.SrvPartPriority = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field SrvPartPriority: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field SrvPartPriority: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SrvPartWeight != nil {
    raw := in.SrvPartWeight
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field SrvPartWeight: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.SrvPartWeight = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.SrvPartWeight = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field SrvPartWeight: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field SrvPartWeight: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SrvPartPort != nil {
    raw := in.SrvPartPort
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field SrvPartPort: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.SrvPartPort = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.SrvPartPort = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field SrvPartPort: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field SrvPartPort: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SrvPartTarget != nil {
    raw := in.SrvPartTarget
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SrvPartTarget = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.SrvPartTarget = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field SrvPartTarget: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field SrvPartTarget: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Sshfprecord != nil {
    raw := in.Sshfprecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sshfprecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Sshfprecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Sshfprecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SshfpPartAlgorithm != nil {
    raw := in.SshfpPartAlgorithm
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field SshfpPartAlgorithm: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.SshfpPartAlgorithm = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.SshfpPartAlgorithm = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field SshfpPartAlgorithm: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field SshfpPartAlgorithm: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SshfpPartFpType != nil {
    raw := in.SshfpPartFpType
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field SshfpPartFpType: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.SshfpPartFpType = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.SshfpPartFpType = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field SshfpPartFpType: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field SshfpPartFpType: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SshfpPartFingerprint != nil {
    raw := in.SshfpPartFingerprint
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SshfpPartFingerprint = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.SshfpPartFingerprint = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field SshfpPartFingerprint: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field SshfpPartFingerprint: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Tlsarecord != nil {
    raw := in.Tlsarecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Tlsarecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Tlsarecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Tlsarecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.TlsaPartCertUsage != nil {
    raw := in.TlsaPartCertUsage
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field TlsaPartCertUsage: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.TlsaPartCertUsage = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.TlsaPartCertUsage = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field TlsaPartCertUsage: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field TlsaPartCertUsage: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.TlsaPartSelector != nil {
    raw := in.TlsaPartSelector
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field TlsaPartSelector: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.TlsaPartSelector = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.TlsaPartSelector = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field TlsaPartSelector: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field TlsaPartSelector: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.TlsaPartMatchingType != nil {
    raw := in.TlsaPartMatchingType
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field TlsaPartMatchingType: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.TlsaPartMatchingType = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.TlsaPartMatchingType = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field TlsaPartMatchingType: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field TlsaPartMatchingType: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.TlsaPartCertAssociationData != nil {
    raw := in.TlsaPartCertAssociationData
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.TlsaPartCertAssociationData = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.TlsaPartCertAssociationData = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field TlsaPartCertAssociationData: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field TlsaPartCertAssociationData: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Txtrecord != nil {
    raw := in.Txtrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Txtrecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Txtrecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Txtrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.TxtPartData != nil {
    raw := in.TxtPartData
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.TxtPartData = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.TxtPartData = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field TxtPartData: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field TxtPartData: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Urirecord != nil {
    raw := in.Urirecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Urirecord = &[]string{plainV}
      } else if sliceOk {
        
        out.Urirecord = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Urirecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.URIPartPriority != nil {
    raw := in.URIPartPriority
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field URIPartPriority: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.URIPartPriority = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.URIPartPriority = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field URIPartPriority: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field URIPartPriority: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.URIPartWeight != nil {
    raw := in.URIPartWeight
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field URIPartWeight: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.URIPartWeight = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.URIPartWeight = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field URIPartWeight: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field URIPartWeight: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.URIPartTarget != nil {
    raw := in.URIPartTarget
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.URIPartTarget = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.URIPartTarget = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field URIPartTarget: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field URIPartTarget: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsrprecord struct {
  }

func (t *Dnsrprecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsrprecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsrprecord%v", string(b))
}

type jsonDnsrprecord struct {
  }

func (out *Dnsrprecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsrprecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  return nil
}

type Dnsrrsigrecord struct {
  }

func (t *Dnsrrsigrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsrrsigrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsrrsigrecord%v", string(b))
}

type jsonDnsrrsigrecord struct {
  }

func (out *Dnsrrsigrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsrrsigrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  return nil
}

type Dnsserver struct {
  
    /*
Server name
DNS Server name
    */
    Idnsserverid string `json:"idnsserverid,omitempty"`
  
    /*
SOA mname override
SOA mname (authoritative server) override
    */
    Idnssoamname *interface{} `json:"idnssoamname,omitempty"`
  
    /*
Forwarders
Per-server forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-server conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  }

func (t *Dnsserver) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsserver[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsserver%v", string(b))
}

type jsonDnsserver struct {
  
    Idnsserverid interface{} `json:"idnsserverid"`
  
    Idnssoamname interface{} `json:"idnssoamname"`
  
    Idnsforwarders interface{} `json:"idnsforwarders"`
  
    Idnsforwardpolicy interface{} `json:"idnsforwardpolicy"`
  }

func (out *Dnsserver) UnmarshalJSON(data []byte) error {
  var in jsonDnsserver
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Idnsserverid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsserverid = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Idnsserverid: %v; expected exactly one element", raw)
          }
          out.Idnsserverid = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsserverid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnssoamname != nil {
    raw := in.Idnssoamname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnssoamname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnssoamname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnssoamname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnssoamname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsforwarders != nil {
    raw := in.Idnsforwarders
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsforwarders = &[]string{plainV}
      } else if sliceOk {
        
        out.Idnsforwarders = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Idnsforwarders: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsforwardpolicy != nil {
    raw := in.Idnsforwardpolicy
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsforwardpolicy = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnsforwardpolicy = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnsforwardpolicy: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsforwardpolicy: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnssigrecord struct {
  }

func (t *Dnssigrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnssigrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnssigrecord%v", string(b))
}

type jsonDnssigrecord struct {
  }

func (out *Dnssigrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnssigrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  return nil
}

type Dnsspfrecord struct {
  }

func (t *Dnsspfrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsspfrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsspfrecord%v", string(b))
}

type jsonDnsspfrecord struct {
  }

func (out *Dnsspfrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsspfrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  return nil
}

type Dnssrvrecord struct {
  
    /*
Priority (order)
Lower number means higher priority. Clients will attempt to contact the server with the lowest-numbered priority they can reach.
    */
    Priority int `json:"priority,omitempty"`
  
    /*
Weight
Relative weight for entries with the same priority.
    */
    Weight int `json:"weight,omitempty"`
  
    /*
Port

    */
    Port int `json:"port,omitempty"`
  
    /*
Target
The domain name of the target host or '.' if the service is decidedly not available at this domain
    */
    Target interface{} `json:"target,omitempty"`
  }

func (t *Dnssrvrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnssrvrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnssrvrecord%v", string(b))
}

type jsonDnssrvrecord struct {
  
    Priority interface{} `json:"priority"`
  
    Weight interface{} `json:"weight"`
  
    Port interface{} `json:"port"`
  
    Target interface{} `json:"target"`
  }

func (out *Dnssrvrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnssrvrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Priority
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Priority: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Priority = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Priority: %v; expected exactly one element", raw)
          }
          out.Priority = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Priority: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Weight
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Weight: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Weight = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Weight: %v; expected exactly one element", raw)
          }
          out.Weight = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Weight: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Port
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Port: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Port = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Port: %v; expected exactly one element", raw)
          }
          out.Port = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Port: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Target
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Target = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Target: %v; expected exactly one element", raw)
          }
          out.Target = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Target: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnssshfprecord struct {
  
    /*
Algorithm

    */
    Algorithm int `json:"algorithm,omitempty"`
  
    /*
Fingerprint Type

    */
    FpType int `json:"fp_type,omitempty"`
  
    /*
Fingerprint

    */
    Fingerprint string `json:"fingerprint,omitempty"`
  }

func (t *Dnssshfprecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnssshfprecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnssshfprecord%v", string(b))
}

type jsonDnssshfprecord struct {
  
    Algorithm interface{} `json:"algorithm"`
  
    FpType interface{} `json:"fp_type"`
  
    Fingerprint interface{} `json:"fingerprint"`
  }

func (out *Dnssshfprecord) UnmarshalJSON(data []byte) error {
  var in jsonDnssshfprecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Algorithm
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Algorithm: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Algorithm = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Algorithm: %v; expected exactly one element", raw)
          }
          out.Algorithm = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Algorithm: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.FpType
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field FpType: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.FpType = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field FpType: %v; expected exactly one element", raw)
          }
          out.FpType = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field FpType: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Fingerprint
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Fingerprint = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Fingerprint: %v; expected exactly one element", raw)
          }
          out.Fingerprint = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Fingerprint: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnstlsarecord struct {
  
    /*
Certificate Usage

    */
    CertUsage int `json:"cert_usage,omitempty"`
  
    /*
Selector

    */
    Selector int `json:"selector,omitempty"`
  
    /*
Matching Type

    */
    MatchingType int `json:"matching_type,omitempty"`
  
    /*
Certificate Association Data

    */
    CertAssociationData string `json:"cert_association_data,omitempty"`
  }

func (t *Dnstlsarecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnstlsarecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnstlsarecord%v", string(b))
}

type jsonDnstlsarecord struct {
  
    CertUsage interface{} `json:"cert_usage"`
  
    Selector interface{} `json:"selector"`
  
    MatchingType interface{} `json:"matching_type"`
  
    CertAssociationData interface{} `json:"cert_association_data"`
  }

func (out *Dnstlsarecord) UnmarshalJSON(data []byte) error {
  var in jsonDnstlsarecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.CertUsage
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field CertUsage: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.CertUsage = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field CertUsage: %v; expected exactly one element", raw)
          }
          out.CertUsage = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field CertUsage: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Selector
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Selector: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Selector = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Selector: %v; expected exactly one element", raw)
          }
          out.Selector = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Selector: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.MatchingType
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field MatchingType: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.MatchingType = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field MatchingType: %v; expected exactly one element", raw)
          }
          out.MatchingType = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field MatchingType: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.CertAssociationData
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CertAssociationData = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field CertAssociationData: %v; expected exactly one element", raw)
          }
          out.CertAssociationData = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field CertAssociationData: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnstxtrecord struct {
  
    /*
Text Data

    */
    Data string `json:"data,omitempty"`
  }

func (t *Dnstxtrecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnstxtrecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnstxtrecord%v", string(b))
}

type jsonDnstxtrecord struct {
  
    Data interface{} `json:"data"`
  }

func (out *Dnstxtrecord) UnmarshalJSON(data []byte) error {
  var in jsonDnstxtrecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Data
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Data = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Data: %v; expected exactly one element", raw)
          }
          out.Data = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Data: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnsurirecord struct {
  
    /*
Priority (order)
Lower number means higher priority. Clients will attempt to contact the URI with the lowest-numbered priority they can reach.
    */
    Priority int `json:"priority,omitempty"`
  
    /*
Weight
Relative weight for entries with the same priority.
    */
    Weight int `json:"weight,omitempty"`
  
    /*
Target Uniform Resource Identifier
Target Uniform Resource Identifier according to RFC 3986
    */
    Target string `json:"target,omitempty"`
  }

func (t *Dnsurirecord) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnsurirecord[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnsurirecord%v", string(b))
}

type jsonDnsurirecord struct {
  
    Priority interface{} `json:"priority"`
  
    Weight interface{} `json:"weight"`
  
    Target interface{} `json:"target"`
  }

func (out *Dnsurirecord) UnmarshalJSON(data []byte) error {
  var in jsonDnsurirecord
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Priority
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Priority: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Priority = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Priority: %v; expected exactly one element", raw)
          }
          out.Priority = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Priority: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Weight
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Weight: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Weight = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Weight: %v; expected exactly one element", raw)
          }
          out.Weight = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Weight: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Target
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Target = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Target: %v; expected exactly one element", raw)
          }
          out.Target = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Target: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Dnszone struct {
  
    /*
Zone name
Zone name (FQDN)
    */
    Idnsname interface{} `json:"idnsname,omitempty"`
  
    /*
Reverse zone IP network
IP network to create reverse zone name from
    */
    NameFromIP *string `json:"name_from_ip,omitempty"`
  
    /*
Active zone
Is zone active?
    */
    Idnszoneactive *bool `json:"idnszoneactive,omitempty"`
  
    /*
Zone forwarders
Per-zone forwarders. A custom port can be specified for each forwarder using a standard format "IP_ADDRESS port PORT"
    */
    Idnsforwarders *[]string `json:"idnsforwarders,omitempty"`
  
    /*
Forward policy
Per-zone conditional forwarding policy. Set to "none" to disable forwarding to global forwarder for this zone. In that case, conditional zone forwarders are disregarded.
    */
    Idnsforwardpolicy *string `json:"idnsforwardpolicy,omitempty"`
  
    /*
Managedby permission

    */
    Managedby string `json:"managedby,omitempty"`
  
    /*
Authoritative nameserver
Authoritative nameserver domain name
    */
    Idnssoamname *interface{} `json:"idnssoamname,omitempty"`
  
    /*
Administrator e-mail address
Administrator e-mail address
    */
    Idnssoarname interface{} `json:"idnssoarname,omitempty"`
  
    /*
SOA serial
SOA record serial number
    */
    Idnssoaserial int `json:"idnssoaserial,omitempty"`
  
    /*
SOA refresh
SOA record refresh time
    */
    Idnssoarefresh int `json:"idnssoarefresh,omitempty"`
  
    /*
SOA retry
SOA record retry time
    */
    Idnssoaretry int `json:"idnssoaretry,omitempty"`
  
    /*
SOA expire
SOA record expire time
    */
    Idnssoaexpire int `json:"idnssoaexpire,omitempty"`
  
    /*
SOA minimum
How long should negative responses be cached
    */
    Idnssoaminimum int `json:"idnssoaminimum,omitempty"`
  
    /*
Time to live
Time to live for records at zone apex
    */
    Dnsttl *int `json:"dnsttl,omitempty"`
  
    /*
Default time to live
Time to live for records without explicit TTL definition
    */
    Dnsdefaultttl *int `json:"dnsdefaultttl,omitempty"`
  
    /*


    */
    Dnsclass *string `json:"dnsclass,omitempty"`
  
    /*
BIND update policy
BIND update policy
    */
    Idnsupdatepolicy *string `json:"idnsupdatepolicy,omitempty"`
  
    /*
Dynamic update
Allow dynamic updates.
    */
    Idnsallowdynupdate *bool `json:"idnsallowdynupdate,omitempty"`
  
    /*
Allow query
Semicolon separated list of IP addresses or networks which are allowed to issue queries
    */
    Idnsallowquery *string `json:"idnsallowquery,omitempty"`
  
    /*
Allow transfer
Semicolon separated list of IP addresses or networks which are allowed to transfer the zone
    */
    Idnsallowtransfer *string `json:"idnsallowtransfer,omitempty"`
  
    /*
Allow PTR sync
Allow synchronization of forward (A, AAAA) and reverse (PTR) records in the zone
    */
    Idnsallowsyncptr *bool `json:"idnsallowsyncptr,omitempty"`
  
    /*
Allow in-line DNSSEC signing
Allow inline DNSSEC signing of records in the zone
    */
    Idnssecinlinesigning *bool `json:"idnssecinlinesigning,omitempty"`
  
    /*
NSEC3PARAM record
NSEC3PARAM record for zone in format: hash_algorithm flags iterations salt
    */
    Nsec3paramrecord *string `json:"nsec3paramrecord,omitempty"`
  }

func (t *Dnszone) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Dnszone[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Dnszone%v", string(b))
}

type jsonDnszone struct {
  
    Idnsname interface{} `json:"idnsname"`
  
    NameFromIP interface{} `json:"name_from_ip"`
  
    Idnszoneactive interface{} `json:"idnszoneactive"`
  
    Idnsforwarders interface{} `json:"idnsforwarders"`
  
    Idnsforwardpolicy interface{} `json:"idnsforwardpolicy"`
  
    Managedby interface{} `json:"managedby"`
  
    Idnssoamname interface{} `json:"idnssoamname"`
  
    Idnssoarname interface{} `json:"idnssoarname"`
  
    Idnssoaserial interface{} `json:"idnssoaserial"`
  
    Idnssoarefresh interface{} `json:"idnssoarefresh"`
  
    Idnssoaretry interface{} `json:"idnssoaretry"`
  
    Idnssoaexpire interface{} `json:"idnssoaexpire"`
  
    Idnssoaminimum interface{} `json:"idnssoaminimum"`
  
    Dnsttl interface{} `json:"dnsttl"`
  
    Dnsdefaultttl interface{} `json:"dnsdefaultttl"`
  
    Dnsclass interface{} `json:"dnsclass"`
  
    Idnsupdatepolicy interface{} `json:"idnsupdatepolicy"`
  
    Idnsallowdynupdate interface{} `json:"idnsallowdynupdate"`
  
    Idnsallowquery interface{} `json:"idnsallowquery"`
  
    Idnsallowtransfer interface{} `json:"idnsallowtransfer"`
  
    Idnsallowsyncptr interface{} `json:"idnsallowsyncptr"`
  
    Idnssecinlinesigning interface{} `json:"idnssecinlinesigning"`
  
    Nsec3paramrecord interface{} `json:"nsec3paramrecord"`
  }

func (out *Dnszone) UnmarshalJSON(data []byte) error {
  var in jsonDnszone
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Idnsname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Idnsname: %v; expected exactly one element", raw)
          }
          out.Idnsname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.NameFromIP != nil {
    raw := in.NameFromIP
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.NameFromIP = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.NameFromIP = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field NameFromIP: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field NameFromIP: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnszoneactive != nil {
    raw := in.Idnszoneactive
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnszoneactive = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnszoneactive = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnszoneactive: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnszoneactive: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsforwarders != nil {
    raw := in.Idnsforwarders
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsforwarders = &[]string{plainV}
      } else if sliceOk {
        
        out.Idnsforwarders = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Idnsforwarders: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsforwardpolicy != nil {
    raw := in.Idnsforwardpolicy
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsforwardpolicy = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnsforwardpolicy = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnsforwardpolicy: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsforwardpolicy: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Managedby
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Managedby = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Managedby: %v; expected exactly one element", raw)
          }
          out.Managedby = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Managedby: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnssoamname != nil {
    raw := in.Idnssoamname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnssoamname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnssoamname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnssoamname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnssoamname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Idnssoarname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnssoarname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Idnssoarname: %v; expected exactly one element", raw)
          }
          out.Idnssoarname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Idnssoarname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Idnssoaserial
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Idnssoaserial: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Idnssoaserial = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Idnssoaserial: %v; expected exactly one element", raw)
          }
          out.Idnssoaserial = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Idnssoaserial: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Idnssoarefresh
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Idnssoarefresh: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Idnssoarefresh = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Idnssoarefresh: %v; expected exactly one element", raw)
          }
          out.Idnssoarefresh = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Idnssoarefresh: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Idnssoaretry
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Idnssoaretry: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Idnssoaretry = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Idnssoaretry: %v; expected exactly one element", raw)
          }
          out.Idnssoaretry = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Idnssoaretry: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Idnssoaexpire
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Idnssoaexpire: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Idnssoaexpire = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Idnssoaexpire: %v; expected exactly one element", raw)
          }
          out.Idnssoaexpire = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Idnssoaexpire: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Idnssoaminimum
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Idnssoaminimum: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Idnssoaminimum = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Idnssoaminimum: %v; expected exactly one element", raw)
          }
          out.Idnssoaminimum = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Idnssoaminimum: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dnsttl != nil {
    raw := in.Dnsttl
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Dnsttl: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Dnsttl = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Dnsttl = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Dnsttl: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Dnsttl: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dnsdefaultttl != nil {
    raw := in.Dnsdefaultttl
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Dnsdefaultttl: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Dnsdefaultttl = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Dnsdefaultttl = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Dnsdefaultttl: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Dnsdefaultttl: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Dnsclass != nil {
    raw := in.Dnsclass
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Dnsclass = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Dnsclass = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Dnsclass: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Dnsclass: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsupdatepolicy != nil {
    raw := in.Idnsupdatepolicy
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsupdatepolicy = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnsupdatepolicy = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnsupdatepolicy: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsupdatepolicy: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsallowdynupdate != nil {
    raw := in.Idnsallowdynupdate
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsallowdynupdate = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnsallowdynupdate = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnsallowdynupdate: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsallowdynupdate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsallowquery != nil {
    raw := in.Idnsallowquery
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsallowquery = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnsallowquery = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnsallowquery: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsallowquery: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsallowtransfer != nil {
    raw := in.Idnsallowtransfer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsallowtransfer = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnsallowtransfer = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnsallowtransfer: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsallowtransfer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnsallowsyncptr != nil {
    raw := in.Idnsallowsyncptr
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsallowsyncptr = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnsallowsyncptr = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnsallowsyncptr: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsallowsyncptr: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Idnssecinlinesigning != nil {
    raw := in.Idnssecinlinesigning
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnssecinlinesigning = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Idnssecinlinesigning = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Idnssecinlinesigning: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Idnssecinlinesigning: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nsec3paramrecord != nil {
    raw := in.Nsec3paramrecord
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nsec3paramrecord = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Nsec3paramrecord = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Nsec3paramrecord: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Nsec3paramrecord: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Group struct {
  
    /*
Group name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
GID
GID (use this option to set it manually)
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
External member
Members of a trusted domain in DOM\name or name@domain form
    */
    Ipaexternalmember *[]string `json:"ipaexternalmember,omitempty"`
  
    /*
Member users

    */
    MemberUser *[]string `json:"member_user,omitempty"`
  
    /*
Member groups

    */
    MemberGroup *[]string `json:"member_group,omitempty"`
  
    /*
Member of groups

    */
    MemberofGroup *[]string `json:"memberof_group,omitempty"`
  
    /*
Roles

    */
    MemberofRole *[]string `json:"memberof_role,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]string `json:"memberof_netgroup,omitempty"`
  
    /*
Member of Sudo rule

    */
    MemberofSudorule *[]string `json:"memberof_sudorule,omitempty"`
  
    /*
Member of HBAC rule

    */
    MemberofHbacrule *[]string `json:"memberof_hbacrule,omitempty"`
  
    /*
Indirect Member users

    */
    MemberindirectUser *[]string `json:"memberindirect_user,omitempty"`
  
    /*
Indirect Member groups

    */
    MemberindirectGroup *[]string `json:"memberindirect_group,omitempty"`
  
    /*
Indirect Member of group

    */
    MemberofindirectGroup *[]string `json:"memberofindirect_group,omitempty"`
  
    /*
Indirect Member of netgroup

    */
    MemberofindirectNetgroup *[]string `json:"memberofindirect_netgroup,omitempty"`
  
    /*
Indirect Member of role

    */
    MemberofindirectRole *[]string `json:"memberofindirect_role,omitempty"`
  
    /*
Indirect Member of Sudo rule

    */
    MemberofindirectSudorule *[]string `json:"memberofindirect_sudorule,omitempty"`
  
    /*
Indirect Member of HBAC rule

    */
    MemberofindirectHbacrule *[]string `json:"memberofindirect_hbacrule,omitempty"`
  }

func (t *Group) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Group[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Group%v", string(b))
}

type jsonGroup struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    Gidnumber interface{} `json:"gidnumber"`
  
    Ipaexternalmember interface{} `json:"ipaexternalmember"`
  
    MemberUser interface{} `json:"member_user"`
  
    MemberGroup interface{} `json:"member_group"`
  
    MemberofGroup interface{} `json:"memberof_group"`
  
    MemberofRole interface{} `json:"memberof_role"`
  
    MemberofNetgroup interface{} `json:"memberof_netgroup"`
  
    MemberofSudorule interface{} `json:"memberof_sudorule"`
  
    MemberofHbacrule interface{} `json:"memberof_hbacrule"`
  
    MemberindirectUser interface{} `json:"memberindirect_user"`
  
    MemberindirectGroup interface{} `json:"memberindirect_group"`
  
    MemberofindirectGroup interface{} `json:"memberofindirect_group"`
  
    MemberofindirectNetgroup interface{} `json:"memberofindirect_netgroup"`
  
    MemberofindirectRole interface{} `json:"memberofindirect_role"`
  
    MemberofindirectSudorule interface{} `json:"memberofindirect_sudorule"`
  
    MemberofindirectHbacrule interface{} `json:"memberofindirect_hbacrule"`
  }

func (out *Group) UnmarshalJSON(data []byte) error {
  var in jsonGroup
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Gidnumber != nil {
    raw := in.Gidnumber
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Gidnumber: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Gidnumber = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Gidnumber = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Gidnumber: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Gidnumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipaexternalmember != nil {
    raw := in.Ipaexternalmember
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaexternalmember = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipaexternalmember = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipaexternalmember: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberUser != nil {
    raw := in.MemberUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberUser = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberUser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberGroup != nil {
    raw := in.MemberGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofGroup != nil {
    raw := in.MemberofGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofRole != nil {
    raw := in.MemberofRole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofRole = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofRole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofRole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofNetgroup != nil {
    raw := in.MemberofNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofSudorule != nil {
    raw := in.MemberofSudorule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofSudorule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofSudorule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofSudorule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofHbacrule != nil {
    raw := in.MemberofHbacrule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofHbacrule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofHbacrule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofHbacrule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberindirectUser != nil {
    raw := in.MemberindirectUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberindirectUser = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberindirectUser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberindirectUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberindirectGroup != nil {
    raw := in.MemberindirectGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberindirectGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberindirectGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberindirectGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectGroup != nil {
    raw := in.MemberofindirectGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectNetgroup != nil {
    raw := in.MemberofindirectNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectRole != nil {
    raw := in.MemberofindirectRole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectRole = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectRole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectRole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectSudorule != nil {
    raw := in.MemberofindirectSudorule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectSudorule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectSudorule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectSudorule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectHbacrule != nil {
    raw := in.MemberofindirectHbacrule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectHbacrule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectHbacrule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectHbacrule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Hbacrule struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Rule type
Rule type (allow)
    */
    Accessruletype *string `json:"accessruletype,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Source host category
Source host category the rule applies to
    */
    Sourcehostcategory *string `json:"sourcehostcategory,omitempty"`
  
    /*
Service category
Service category the rule applies to
    */
    Servicecategory *string `json:"servicecategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
Users

    */
    MemberuserUser *[]string `json:"memberuser_user,omitempty"`
  
    /*
User Groups

    */
    MemberuserGroup *[]string `json:"memberuser_group,omitempty"`
  
    /*
Hosts

    */
    MemberhostHost *[]string `json:"memberhost_host,omitempty"`
  
    /*
Host Groups

    */
    MemberhostHostgroup *[]string `json:"memberhost_hostgroup,omitempty"`
  
    /*
Source Hosts

    */
    SourcehostHost *string `json:"sourcehost_host,omitempty"`
  
    /*
Source Host Groups

    */
    SourcehostHostgroup *string `json:"sourcehost_hostgroup,omitempty"`
  
    /*
Services

    */
    MemberserviceHbacsvc *[]string `json:"memberservice_hbacsvc,omitempty"`
  
    /*
Service Groups

    */
    MemberserviceHbacsvcgroup *[]string `json:"memberservice_hbacsvcgroup,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  }

func (t *Hbacrule) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Hbacrule[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Hbacrule%v", string(b))
}

type jsonHbacrule struct {
  
    Cn interface{} `json:"cn"`
  
    Accessruletype interface{} `json:"accessruletype"`
  
    Usercategory interface{} `json:"usercategory"`
  
    Hostcategory interface{} `json:"hostcategory"`
  
    Sourcehostcategory interface{} `json:"sourcehostcategory"`
  
    Servicecategory interface{} `json:"servicecategory"`
  
    Description interface{} `json:"description"`
  
    Ipaenabledflag interface{} `json:"ipaenabledflag"`
  
    MemberuserUser interface{} `json:"memberuser_user"`
  
    MemberuserGroup interface{} `json:"memberuser_group"`
  
    MemberhostHost interface{} `json:"memberhost_host"`
  
    MemberhostHostgroup interface{} `json:"memberhost_hostgroup"`
  
    SourcehostHost interface{} `json:"sourcehost_host"`
  
    SourcehostHostgroup interface{} `json:"sourcehost_hostgroup"`
  
    MemberserviceHbacsvc interface{} `json:"memberservice_hbacsvc"`
  
    MemberserviceHbacsvcgroup interface{} `json:"memberservice_hbacsvcgroup"`
  
    Externalhost interface{} `json:"externalhost"`
  }

func (out *Hbacrule) UnmarshalJSON(data []byte) error {
  var in jsonHbacrule
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Accessruletype != nil {
    raw := in.Accessruletype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Accessruletype = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Accessruletype = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Accessruletype: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Accessruletype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Usercategory != nil {
    raw := in.Usercategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Usercategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Usercategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Usercategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Usercategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Hostcategory != nil {
    raw := in.Hostcategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Hostcategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Hostcategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Hostcategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Hostcategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Sourcehostcategory != nil {
    raw := in.Sourcehostcategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sourcehostcategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Sourcehostcategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Sourcehostcategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Sourcehostcategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Servicecategory != nil {
    raw := in.Servicecategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Servicecategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Servicecategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Servicecategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Servicecategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipaenabledflag != nil {
    raw := in.Ipaenabledflag
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaenabledflag = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipaenabledflag = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipaenabledflag: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaenabledflag: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberuserUser != nil {
    raw := in.MemberuserUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberuserUser = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberuserUser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberuserUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberuserGroup != nil {
    raw := in.MemberuserGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberuserGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberuserGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberuserGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberhostHost != nil {
    raw := in.MemberhostHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberhostHost = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberhostHost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberhostHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberhostHostgroup != nil {
    raw := in.MemberhostHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberhostHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberhostHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberhostHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SourcehostHost != nil {
    raw := in.SourcehostHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SourcehostHost = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.SourcehostHost = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field SourcehostHost: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field SourcehostHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SourcehostHostgroup != nil {
    raw := in.SourcehostHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SourcehostHostgroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.SourcehostHostgroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field SourcehostHostgroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field SourcehostHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberserviceHbacsvc != nil {
    raw := in.MemberserviceHbacsvc
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberserviceHbacsvc = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberserviceHbacsvc = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberserviceHbacsvc: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberserviceHbacsvcgroup != nil {
    raw := in.MemberserviceHbacsvcgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberserviceHbacsvcgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberserviceHbacsvcgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberserviceHbacsvcgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Externalhost != nil {
    raw := in.Externalhost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Externalhost = &[]string{plainV}
      } else if sliceOk {
        
        out.Externalhost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Externalhost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Hbacsvc struct {
  
    /*
Service name
HBAC service
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
HBAC service description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Member of HBAC service groups

    */
    MemberofHbacsvcgroup *[]string `json:"memberof_hbacsvcgroup,omitempty"`
  }

func (t *Hbacsvc) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Hbacsvc[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Hbacsvc%v", string(b))
}

type jsonHbacsvc struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    MemberofHbacsvcgroup interface{} `json:"memberof_hbacsvcgroup"`
  }

func (out *Hbacsvc) UnmarshalJSON(data []byte) error {
  var in jsonHbacsvc
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofHbacsvcgroup != nil {
    raw := in.MemberofHbacsvcgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofHbacsvcgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofHbacsvcgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofHbacsvcgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Hbacsvcgroup struct {
  
    /*
Service group name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
HBAC service group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Member HBAC service

    */
    MemberHbacsvc *[]string `json:"member_hbacsvc,omitempty"`
  }

func (t *Hbacsvcgroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Hbacsvcgroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Hbacsvcgroup%v", string(b))
}

type jsonHbacsvcgroup struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    MemberHbacsvc interface{} `json:"member_hbacsvc"`
  }

func (out *Hbacsvcgroup) UnmarshalJSON(data []byte) error {
  var in jsonHbacsvcgroup
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberHbacsvc != nil {
    raw := in.MemberHbacsvc
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberHbacsvc = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberHbacsvc = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberHbacsvc: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Host struct {
  
    /*
Host name

    */
    Fqdn string `json:"fqdn,omitempty"`
  
    /*
Description
A description of this host
    */
    Description *string `json:"description,omitempty"`
  
    /*
Locality
Host locality (e.g. "Baltimore, MD")
    */
    L *string `json:"l,omitempty"`
  
    /*
Location
Host location (e.g. "Lab 2")
    */
    Nshostlocation *string `json:"nshostlocation,omitempty"`
  
    /*
Platform
Host hardware platform (e.g. "Lenovo T61")
    */
    Nshardwareplatform *string `json:"nshardwareplatform,omitempty"`
  
    /*
Operating system
Host operating system and version (e.g. "Fedora 9")
    */
    Nsosversion *string `json:"nsosversion,omitempty"`
  
    /*
User password
Password used in bulk enrollment
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random password to be used in bulk enrollment
    */
    Random *bool `json:"random,omitempty"`
  
    /*
Random password

    */
    Randompassword *string `json:"randompassword,omitempty"`
  
    /*
Certificate
Base-64 encoded host certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Subject

    */
    Subject *string `json:"subject,omitempty"`
  
    /*
Serial Number

    */
    SerialNumber *string `json:"serial_number,omitempty"`
  
    /*
Serial Number (hex)

    */
    SerialNumberHex *string `json:"serial_number_hex,omitempty"`
  
    /*
Issuer

    */
    Issuer *string `json:"issuer,omitempty"`
  
    /*
Not Before

    */
    ValidNotBefore *string `json:"valid_not_before,omitempty"`
  
    /*
Not After

    */
    ValidNotAfter *string `json:"valid_not_after,omitempty"`
  
    /*
Fingerprint (SHA1)

    */
    Sha1Fingerprint *string `json:"sha1_fingerprint,omitempty"`
  
    /*
Fingerprint (SHA256)

    */
    Sha256Fingerprint *string `json:"sha256_fingerprint,omitempty"`
  
    /*
Revocation reason

    */
    RevocationReason *string `json:"revocation_reason,omitempty"`
  
    /*
Principal name

    */
    Krbcanonicalname *string `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
MAC address
Hardware MAC address(es) on this host
    */
    Macaddress *[]string `json:"macaddress,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
SSH public key fingerprint

    */
    Sshpubkeyfp *[]string `json:"sshpubkeyfp,omitempty"`
  
    /*
Class
Host category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
Assigned ID View

    */
    Ipaassignedidview *string `json:"ipaassignedidview,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *bool `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *bool `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *bool `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*
Password

    */
    HasPassword *bool `json:"has_password,omitempty"`
  
    /*
Member of host-groups

    */
    MemberofHostgroup *[]string `json:"memberof_hostgroup,omitempty"`
  
    /*
Roles

    */
    MemberofRole *[]string `json:"memberof_role,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]string `json:"memberof_netgroup,omitempty"`
  
    /*
Member of Sudo rule

    */
    MemberofSudorule *[]string `json:"memberof_sudorule,omitempty"`
  
    /*
Member of HBAC rule

    */
    MemberofHbacrule *[]string `json:"memberof_hbacrule,omitempty"`
  
    /*
Indirect Member of netgroup

    */
    MemberofindirectNetgroup *[]string `json:"memberofindirect_netgroup,omitempty"`
  
    /*
Indirect Member of host-group

    */
    MemberofindirectHostgroup *[]string `json:"memberofindirect_hostgroup,omitempty"`
  
    /*
Indirect Member of role

    */
    MemberofindirectRole *[]string `json:"memberofindirect_role,omitempty"`
  
    /*
Indirect Member of Sudo rule

    */
    MemberofindirectSudorule *[]string `json:"memberofindirect_sudorule,omitempty"`
  
    /*
Indirect Member of HBAC rule

    */
    MemberofindirectHbacrule *[]string `json:"memberofindirect_hbacrule,omitempty"`
  
    /*
Keytab

    */
    HasKeytab *bool `json:"has_keytab,omitempty"`
  
    /*
Managed by

    */
    ManagedbyHost *string `json:"managedby_host,omitempty"`
  
    /*
Managing

    */
    ManagingHost *string `json:"managing_host,omitempty"`
  
    /*
Users allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysUser *string `json:"ipaallowedtoperform_read_keys_user,omitempty"`
  
    /*
Groups allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysGroup *string `json:"ipaallowedtoperform_read_keys_group,omitempty"`
  
    /*
Hosts allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysHost *string `json:"ipaallowedtoperform_read_keys_host,omitempty"`
  
    /*
Host Groups allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysHostgroup *string `json:"ipaallowedtoperform_read_keys_hostgroup,omitempty"`
  
    /*
Users allowed to create keytab

    */
    IpaallowedtoperformWriteKeysUser *string `json:"ipaallowedtoperform_write_keys_user,omitempty"`
  
    /*
Groups allowed to create keytab

    */
    IpaallowedtoperformWriteKeysGroup *string `json:"ipaallowedtoperform_write_keys_group,omitempty"`
  
    /*
Hosts allowed to create keytab

    */
    IpaallowedtoperformWriteKeysHost *string `json:"ipaallowedtoperform_write_keys_host,omitempty"`
  
    /*
Host Groups allowed to create keytab

    */
    IpaallowedtoperformWriteKeysHostgroup *string `json:"ipaallowedtoperform_write_keys_hostgroup,omitempty"`
  }

func (t *Host) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Host[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Host%v", string(b))
}

type jsonHost struct {
  
    Fqdn interface{} `json:"fqdn"`
  
    Description interface{} `json:"description"`
  
    L interface{} `json:"l"`
  
    Nshostlocation interface{} `json:"nshostlocation"`
  
    Nshardwareplatform interface{} `json:"nshardwareplatform"`
  
    Nsosversion interface{} `json:"nsosversion"`
  
    Userpassword interface{} `json:"userpassword"`
  
    Random interface{} `json:"random"`
  
    Randompassword interface{} `json:"randompassword"`
  
    Usercertificate interface{} `json:"usercertificate"`
  
    Subject interface{} `json:"subject"`
  
    SerialNumber interface{} `json:"serial_number"`
  
    SerialNumberHex interface{} `json:"serial_number_hex"`
  
    Issuer interface{} `json:"issuer"`
  
    ValidNotBefore interface{} `json:"valid_not_before"`
  
    ValidNotAfter interface{} `json:"valid_not_after"`
  
    Sha1Fingerprint interface{} `json:"sha1_fingerprint"`
  
    Sha256Fingerprint interface{} `json:"sha256_fingerprint"`
  
    RevocationReason interface{} `json:"revocation_reason"`
  
    Krbcanonicalname interface{} `json:"krbcanonicalname"`
  
    Krbprincipalname interface{} `json:"krbprincipalname"`
  
    Macaddress interface{} `json:"macaddress"`
  
    Ipasshpubkey interface{} `json:"ipasshpubkey"`
  
    Sshpubkeyfp interface{} `json:"sshpubkeyfp"`
  
    Userclass interface{} `json:"userclass"`
  
    Ipaassignedidview interface{} `json:"ipaassignedidview"`
  
    Krbprincipalauthind interface{} `json:"krbprincipalauthind"`
  
    Ipakrbrequirespreauth interface{} `json:"ipakrbrequirespreauth"`
  
    Ipakrbokasdelegate interface{} `json:"ipakrbokasdelegate"`
  
    Ipakrboktoauthasdelegate interface{} `json:"ipakrboktoauthasdelegate"`
  
    HasPassword interface{} `json:"has_password"`
  
    MemberofHostgroup interface{} `json:"memberof_hostgroup"`
  
    MemberofRole interface{} `json:"memberof_role"`
  
    MemberofNetgroup interface{} `json:"memberof_netgroup"`
  
    MemberofSudorule interface{} `json:"memberof_sudorule"`
  
    MemberofHbacrule interface{} `json:"memberof_hbacrule"`
  
    MemberofindirectNetgroup interface{} `json:"memberofindirect_netgroup"`
  
    MemberofindirectHostgroup interface{} `json:"memberofindirect_hostgroup"`
  
    MemberofindirectRole interface{} `json:"memberofindirect_role"`
  
    MemberofindirectSudorule interface{} `json:"memberofindirect_sudorule"`
  
    MemberofindirectHbacrule interface{} `json:"memberofindirect_hbacrule"`
  
    HasKeytab interface{} `json:"has_keytab"`
  
    ManagedbyHost interface{} `json:"managedby_host"`
  
    ManagingHost interface{} `json:"managing_host"`
  
    IpaallowedtoperformReadKeysUser interface{} `json:"ipaallowedtoperform_read_keys_user"`
  
    IpaallowedtoperformReadKeysGroup interface{} `json:"ipaallowedtoperform_read_keys_group"`
  
    IpaallowedtoperformReadKeysHost interface{} `json:"ipaallowedtoperform_read_keys_host"`
  
    IpaallowedtoperformReadKeysHostgroup interface{} `json:"ipaallowedtoperform_read_keys_hostgroup"`
  
    IpaallowedtoperformWriteKeysUser interface{} `json:"ipaallowedtoperform_write_keys_user"`
  
    IpaallowedtoperformWriteKeysGroup interface{} `json:"ipaallowedtoperform_write_keys_group"`
  
    IpaallowedtoperformWriteKeysHost interface{} `json:"ipaallowedtoperform_write_keys_host"`
  
    IpaallowedtoperformWriteKeysHostgroup interface{} `json:"ipaallowedtoperform_write_keys_hostgroup"`
  }

func (out *Host) UnmarshalJSON(data []byte) error {
  var in jsonHost
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Fqdn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Fqdn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Fqdn: %v; expected exactly one element", raw)
          }
          out.Fqdn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Fqdn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.L != nil {
    raw := in.L
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.L = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.L = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field L: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field L: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nshostlocation != nil {
    raw := in.Nshostlocation
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nshostlocation = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Nshostlocation = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Nshostlocation: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Nshostlocation: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nshardwareplatform != nil {
    raw := in.Nshardwareplatform
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nshardwareplatform = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Nshardwareplatform = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Nshardwareplatform: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Nshardwareplatform: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nsosversion != nil {
    raw := in.Nsosversion
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nsosversion = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Nsosversion = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Nsosversion: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Nsosversion: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Userpassword != nil {
    raw := in.Userpassword
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Userpassword = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Userpassword = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Userpassword: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Userpassword: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Random != nil {
    raw := in.Random
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Random = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Random = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Random: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Random: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Randompassword != nil {
    raw := in.Randompassword
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Randompassword = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Randompassword = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Randompassword: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Randompassword: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Usercertificate != nil {
    raw := in.Usercertificate
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Usercertificate = &[]interface{}{plainV}
      } else if sliceOk {
        
        out.Usercertificate = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Usercertificate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Subject != nil {
    raw := in.Subject
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Subject = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Subject = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Subject: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Subject: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SerialNumber != nil {
    raw := in.SerialNumber
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SerialNumber = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.SerialNumber = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field SerialNumber: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field SerialNumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.SerialNumberHex != nil {
    raw := in.SerialNumberHex
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SerialNumberHex = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.SerialNumberHex = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field SerialNumberHex: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field SerialNumberHex: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Issuer != nil {
    raw := in.Issuer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Issuer = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Issuer = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Issuer: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Issuer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.ValidNotBefore != nil {
    raw := in.ValidNotBefore
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ValidNotBefore = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.ValidNotBefore = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field ValidNotBefore: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field ValidNotBefore: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.ValidNotAfter != nil {
    raw := in.ValidNotAfter
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ValidNotAfter = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.ValidNotAfter = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field ValidNotAfter: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field ValidNotAfter: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Sha1Fingerprint != nil {
    raw := in.Sha1Fingerprint
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sha1Fingerprint = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Sha1Fingerprint = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Sha1Fingerprint: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Sha1Fingerprint: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Sha256Fingerprint != nil {
    raw := in.Sha256Fingerprint
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sha256Fingerprint = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Sha256Fingerprint = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Sha256Fingerprint: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Sha256Fingerprint: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.RevocationReason != nil {
    raw := in.RevocationReason
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.RevocationReason = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.RevocationReason = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field RevocationReason: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field RevocationReason: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbcanonicalname != nil {
    raw := in.Krbcanonicalname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbcanonicalname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbcanonicalname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbcanonicalname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbcanonicalname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbprincipalname != nil {
    raw := in.Krbprincipalname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbprincipalname = &[]string{plainV}
      } else if sliceOk {
        
        out.Krbprincipalname = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Krbprincipalname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Macaddress != nil {
    raw := in.Macaddress
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Macaddress = &[]string{plainV}
      } else if sliceOk {
        
        out.Macaddress = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Macaddress: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipasshpubkey != nil {
    raw := in.Ipasshpubkey
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipasshpubkey = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipasshpubkey = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipasshpubkey: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Sshpubkeyfp != nil {
    raw := in.Sshpubkeyfp
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sshpubkeyfp = &[]string{plainV}
      } else if sliceOk {
        
        out.Sshpubkeyfp = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Sshpubkeyfp: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Userclass != nil {
    raw := in.Userclass
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Userclass = &[]string{plainV}
      } else if sliceOk {
        
        out.Userclass = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Userclass: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipaassignedidview != nil {
    raw := in.Ipaassignedidview
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaassignedidview = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipaassignedidview = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipaassignedidview: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaassignedidview: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbprincipalauthind != nil {
    raw := in.Krbprincipalauthind
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbprincipalauthind = &[]string{plainV}
      } else if sliceOk {
        
        out.Krbprincipalauthind = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Krbprincipalauthind: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipakrbrequirespreauth != nil {
    raw := in.Ipakrbrequirespreauth
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipakrbrequirespreauth = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipakrbrequirespreauth = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipakrbrequirespreauth: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipakrbrequirespreauth: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipakrbokasdelegate != nil {
    raw := in.Ipakrbokasdelegate
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipakrbokasdelegate = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipakrbokasdelegate = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipakrbokasdelegate: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipakrbokasdelegate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipakrboktoauthasdelegate != nil {
    raw := in.Ipakrboktoauthasdelegate
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipakrboktoauthasdelegate = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipakrboktoauthasdelegate = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipakrboktoauthasdelegate: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipakrboktoauthasdelegate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.HasPassword != nil {
    raw := in.HasPassword
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.HasPassword = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.HasPassword = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field HasPassword: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field HasPassword: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofHostgroup != nil {
    raw := in.MemberofHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofRole != nil {
    raw := in.MemberofRole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofRole = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofRole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofRole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofNetgroup != nil {
    raw := in.MemberofNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofSudorule != nil {
    raw := in.MemberofSudorule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofSudorule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofSudorule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofSudorule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofHbacrule != nil {
    raw := in.MemberofHbacrule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofHbacrule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofHbacrule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofHbacrule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectNetgroup != nil {
    raw := in.MemberofindirectNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectHostgroup != nil {
    raw := in.MemberofindirectHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectRole != nil {
    raw := in.MemberofindirectRole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectRole = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectRole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectRole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectSudorule != nil {
    raw := in.MemberofindirectSudorule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectSudorule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectSudorule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectSudorule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectHbacrule != nil {
    raw := in.MemberofindirectHbacrule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectHbacrule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectHbacrule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectHbacrule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.HasKeytab != nil {
    raw := in.HasKeytab
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.HasKeytab = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.HasKeytab = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field HasKeytab: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field HasKeytab: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.ManagedbyHost != nil {
    raw := in.ManagedbyHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ManagedbyHost = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.ManagedbyHost = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field ManagedbyHost: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field ManagedbyHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.ManagingHost != nil {
    raw := in.ManagingHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ManagingHost = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.ManagingHost = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field ManagingHost: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field ManagingHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpaallowedtoperformReadKeysUser != nil {
    raw := in.IpaallowedtoperformReadKeysUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformReadKeysUser = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.IpaallowedtoperformReadKeysUser = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysUser: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpaallowedtoperformReadKeysGroup != nil {
    raw := in.IpaallowedtoperformReadKeysGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformReadKeysGroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.IpaallowedtoperformReadKeysGroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysGroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpaallowedtoperformReadKeysHost != nil {
    raw := in.IpaallowedtoperformReadKeysHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformReadKeysHost = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.IpaallowedtoperformReadKeysHost = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysHost: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpaallowedtoperformReadKeysHostgroup != nil {
    raw := in.IpaallowedtoperformReadKeysHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformReadKeysHostgroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.IpaallowedtoperformReadKeysHostgroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysHostgroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpaallowedtoperformWriteKeysUser != nil {
    raw := in.IpaallowedtoperformWriteKeysUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformWriteKeysUser = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.IpaallowedtoperformWriteKeysUser = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysUser: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpaallowedtoperformWriteKeysGroup != nil {
    raw := in.IpaallowedtoperformWriteKeysGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformWriteKeysGroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.IpaallowedtoperformWriteKeysGroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysGroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpaallowedtoperformWriteKeysHost != nil {
    raw := in.IpaallowedtoperformWriteKeysHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformWriteKeysHost = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.IpaallowedtoperformWriteKeysHost = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysHost: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpaallowedtoperformWriteKeysHostgroup != nil {
    raw := in.IpaallowedtoperformWriteKeysHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformWriteKeysHostgroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.IpaallowedtoperformWriteKeysHostgroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysHostgroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Hostgroup struct {
  
    /*
Host-group
Name of host-group
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
A description of this host-group
    */
    Description *string `json:"description,omitempty"`
  
    /*
Member hosts

    */
    MemberHost *[]string `json:"member_host,omitempty"`
  
    /*
Member host-groups

    */
    MemberHostgroup *[]string `json:"member_hostgroup,omitempty"`
  
    /*
Member of host-groups

    */
    MemberofHostgroup *[]string `json:"memberof_hostgroup,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]string `json:"memberof_netgroup,omitempty"`
  
    /*
Member of Sudo rule

    */
    MemberofSudorule *[]string `json:"memberof_sudorule,omitempty"`
  
    /*
Member of HBAC rule

    */
    MemberofHbacrule *[]string `json:"memberof_hbacrule,omitempty"`
  
    /*
Indirect Member hosts

    */
    MemberindirectHost *[]string `json:"memberindirect_host,omitempty"`
  
    /*
Indirect Member host-groups

    */
    MemberindirectHostgroup *[]string `json:"memberindirect_hostgroup,omitempty"`
  
    /*
Indirect Member of host-group

    */
    MemberofindirectHostgroup *[]string `json:"memberofindirect_hostgroup,omitempty"`
  
    /*
Indirect Member of Sudo rule

    */
    MemberofindirectSudorule *[]string `json:"memberofindirect_sudorule,omitempty"`
  
    /*
Indirect Member of HBAC rule

    */
    MemberofindirectHbacrule *[]string `json:"memberofindirect_hbacrule,omitempty"`
  }

func (t *Hostgroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Hostgroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Hostgroup%v", string(b))
}

type jsonHostgroup struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    MemberHost interface{} `json:"member_host"`
  
    MemberHostgroup interface{} `json:"member_hostgroup"`
  
    MemberofHostgroup interface{} `json:"memberof_hostgroup"`
  
    MemberofNetgroup interface{} `json:"memberof_netgroup"`
  
    MemberofSudorule interface{} `json:"memberof_sudorule"`
  
    MemberofHbacrule interface{} `json:"memberof_hbacrule"`
  
    MemberindirectHost interface{} `json:"memberindirect_host"`
  
    MemberindirectHostgroup interface{} `json:"memberindirect_hostgroup"`
  
    MemberofindirectHostgroup interface{} `json:"memberofindirect_hostgroup"`
  
    MemberofindirectSudorule interface{} `json:"memberofindirect_sudorule"`
  
    MemberofindirectHbacrule interface{} `json:"memberofindirect_hbacrule"`
  }

func (out *Hostgroup) UnmarshalJSON(data []byte) error {
  var in jsonHostgroup
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberHost != nil {
    raw := in.MemberHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberHost = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberHost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberHostgroup != nil {
    raw := in.MemberHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofHostgroup != nil {
    raw := in.MemberofHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofNetgroup != nil {
    raw := in.MemberofNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofSudorule != nil {
    raw := in.MemberofSudorule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofSudorule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofSudorule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofSudorule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofHbacrule != nil {
    raw := in.MemberofHbacrule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofHbacrule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofHbacrule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofHbacrule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberindirectHost != nil {
    raw := in.MemberindirectHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberindirectHost = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberindirectHost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberindirectHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberindirectHostgroup != nil {
    raw := in.MemberindirectHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberindirectHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberindirectHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberindirectHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectHostgroup != nil {
    raw := in.MemberofindirectHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectSudorule != nil {
    raw := in.MemberofindirectSudorule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectSudorule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectSudorule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectSudorule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectHbacrule != nil {
    raw := in.MemberofindirectHbacrule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectHbacrule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectHbacrule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectHbacrule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Idoverridegroup struct {
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Group name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  }

func (t *Idoverridegroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Idoverridegroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Idoverridegroup%v", string(b))
}

type jsonIdoverridegroup struct {
  
    Ipaanchoruuid interface{} `json:"ipaanchoruuid"`
  
    Description interface{} `json:"description"`
  
    Cn interface{} `json:"cn"`
  
    Gidnumber interface{} `json:"gidnumber"`
  }

func (out *Idoverridegroup) UnmarshalJSON(data []byte) error {
  var in jsonIdoverridegroup
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Ipaanchoruuid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaanchoruuid = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipaanchoruuid: %v; expected exactly one element", raw)
          }
          out.Ipaanchoruuid = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaanchoruuid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Cn != nil {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Cn = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Gidnumber != nil {
    raw := in.Gidnumber
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Gidnumber: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Gidnumber = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Gidnumber = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Gidnumber: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Gidnumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Idoverrideuser struct {
  
    /*
Anchor to override

    */
    Ipaanchoruuid string `json:"ipaanchoruuid,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
User login

    */
    UID *string `json:"uid,omitempty"`
  
    /*
UID
User ID Number
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*


    */
    Ipaoriginaluid *string `json:"ipaoriginaluid,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  }

func (t *Idoverrideuser) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Idoverrideuser[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Idoverrideuser%v", string(b))
}

type jsonIdoverrideuser struct {
  
    Ipaanchoruuid interface{} `json:"ipaanchoruuid"`
  
    Description interface{} `json:"description"`
  
    UID interface{} `json:"uid"`
  
    Uidnumber interface{} `json:"uidnumber"`
  
    Gecos interface{} `json:"gecos"`
  
    Gidnumber interface{} `json:"gidnumber"`
  
    Homedirectory interface{} `json:"homedirectory"`
  
    Loginshell interface{} `json:"loginshell"`
  
    Ipaoriginaluid interface{} `json:"ipaoriginaluid"`
  
    Ipasshpubkey interface{} `json:"ipasshpubkey"`
  
    Usercertificate interface{} `json:"usercertificate"`
  }

func (out *Idoverrideuser) UnmarshalJSON(data []byte) error {
  var in jsonIdoverrideuser
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Ipaanchoruuid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaanchoruuid = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipaanchoruuid: %v; expected exactly one element", raw)
          }
          out.Ipaanchoruuid = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaanchoruuid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.UID != nil {
    raw := in.UID
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.UID = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.UID = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field UID: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field UID: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Uidnumber != nil {
    raw := in.Uidnumber
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Uidnumber: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Uidnumber = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Uidnumber = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Uidnumber: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Uidnumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Gecos != nil {
    raw := in.Gecos
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Gecos = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Gecos = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Gecos: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Gecos: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Gidnumber != nil {
    raw := in.Gidnumber
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Gidnumber: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Gidnumber = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Gidnumber = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Gidnumber: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Gidnumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Homedirectory != nil {
    raw := in.Homedirectory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Homedirectory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Homedirectory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Homedirectory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Homedirectory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Loginshell != nil {
    raw := in.Loginshell
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Loginshell = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Loginshell = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Loginshell: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Loginshell: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipaoriginaluid != nil {
    raw := in.Ipaoriginaluid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaoriginaluid = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipaoriginaluid = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipaoriginaluid: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaoriginaluid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipasshpubkey != nil {
    raw := in.Ipasshpubkey
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipasshpubkey = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipasshpubkey = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipasshpubkey: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Usercertificate != nil {
    raw := in.Usercertificate
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Usercertificate = &[]interface{}{plainV}
      } else if sliceOk {
        
        out.Usercertificate = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Usercertificate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Idrange struct {
  
    /*
Range name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
First Posix ID of the range

    */
    Ipabaseid int `json:"ipabaseid,omitempty"`
  
    /*
Number of IDs in the range

    */
    Ipaidrangesize int `json:"ipaidrangesize,omitempty"`
  
    /*
First RID of the corresponding RID range

    */
    Ipabaserid *int `json:"ipabaserid,omitempty"`
  
    /*
First RID of the secondary RID range

    */
    Ipasecondarybaserid *int `json:"ipasecondarybaserid,omitempty"`
  
    /*
Domain SID of the trusted domain

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Name of the trusted domain

    */
    Ipanttrusteddomainname *string `json:"ipanttrusteddomainname,omitempty"`
  
    /*
Range type
ID range type, one of ipa-ad-trust, ipa-ad-trust-posix, ipa-local
    */
    Iparangetype *string `json:"iparangetype,omitempty"`
  }

func (t *Idrange) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Idrange[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Idrange%v", string(b))
}

type jsonIdrange struct {
  
    Cn interface{} `json:"cn"`
  
    Ipabaseid interface{} `json:"ipabaseid"`
  
    Ipaidrangesize interface{} `json:"ipaidrangesize"`
  
    Ipabaserid interface{} `json:"ipabaserid"`
  
    Ipasecondarybaserid interface{} `json:"ipasecondarybaserid"`
  
    Ipanttrusteddomainsid interface{} `json:"ipanttrusteddomainsid"`
  
    Ipanttrusteddomainname interface{} `json:"ipanttrusteddomainname"`
  
    Iparangetype interface{} `json:"iparangetype"`
  }

func (out *Idrange) UnmarshalJSON(data []byte) error {
  var in jsonIdrange
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipabaseid
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipabaseid: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipabaseid = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipabaseid: %v; expected exactly one element", raw)
          }
          out.Ipabaseid = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipabaseid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipaidrangesize
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipaidrangesize: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipaidrangesize = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipaidrangesize: %v; expected exactly one element", raw)
          }
          out.Ipaidrangesize = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaidrangesize: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipabaserid != nil {
    raw := in.Ipabaserid
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipabaserid: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipabaserid = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipabaserid = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipabaserid: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipabaserid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipasecondarybaserid != nil {
    raw := in.Ipasecondarybaserid
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipasecondarybaserid: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipasecondarybaserid = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipasecondarybaserid = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipasecondarybaserid: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipasecondarybaserid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipanttrusteddomainsid != nil {
    raw := in.Ipanttrusteddomainsid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipanttrusteddomainsid = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipanttrusteddomainsid = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipanttrusteddomainsid: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipanttrusteddomainsid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipanttrusteddomainname != nil {
    raw := in.Ipanttrusteddomainname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipanttrusteddomainname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipanttrusteddomainname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipanttrusteddomainname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipanttrusteddomainname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Iparangetype != nil {
    raw := in.Iparangetype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Iparangetype = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Iparangetype = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Iparangetype: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Iparangetype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Idview struct {
  
    /*
ID View Name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
User object overrides

    */
    Useroverrides string `json:"useroverrides,omitempty"`
  
    /*
Group object overrides

    */
    Groupoverrides string `json:"groupoverrides,omitempty"`
  
    /*
Hosts the view applies to

    */
    Appliedtohosts string `json:"appliedtohosts,omitempty"`
  
    /*
Domain resolution order
colon-separated list of domains used for short name qualification
    */
    Ipadomainresolutionorder *string `json:"ipadomainresolutionorder,omitempty"`
  }

func (t *Idview) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Idview[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Idview%v", string(b))
}

type jsonIdview struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    Useroverrides interface{} `json:"useroverrides"`
  
    Groupoverrides interface{} `json:"groupoverrides"`
  
    Appliedtohosts interface{} `json:"appliedtohosts"`
  
    Ipadomainresolutionorder interface{} `json:"ipadomainresolutionorder"`
  }

func (out *Idview) UnmarshalJSON(data []byte) error {
  var in jsonIdview
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Useroverrides
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Useroverrides = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Useroverrides: %v; expected exactly one element", raw)
          }
          out.Useroverrides = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Useroverrides: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Groupoverrides
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Groupoverrides = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Groupoverrides: %v; expected exactly one element", raw)
          }
          out.Groupoverrides = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Groupoverrides: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Appliedtohosts
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Appliedtohosts = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Appliedtohosts: %v; expected exactly one element", raw)
          }
          out.Appliedtohosts = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Appliedtohosts: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipadomainresolutionorder != nil {
    raw := in.Ipadomainresolutionorder
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipadomainresolutionorder = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipadomainresolutionorder = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipadomainresolutionorder: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipadomainresolutionorder: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Krbtpolicy struct {
  
    /*
User name
Manage ticket policy for specific user
    */
    UID *string `json:"uid,omitempty"`
  
    /*
Max life
Maximum ticket life (seconds)
    */
    Krbmaxticketlife *int `json:"krbmaxticketlife,omitempty"`
  
    /*
Max renew
Maximum renewable age (seconds)
    */
    Krbmaxrenewableage *int `json:"krbmaxrenewableage,omitempty"`
  }

func (t *Krbtpolicy) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Krbtpolicy[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Krbtpolicy%v", string(b))
}

type jsonKrbtpolicy struct {
  
    UID interface{} `json:"uid"`
  
    Krbmaxticketlife interface{} `json:"krbmaxticketlife"`
  
    Krbmaxrenewableage interface{} `json:"krbmaxrenewableage"`
  }

func (out *Krbtpolicy) UnmarshalJSON(data []byte) error {
  var in jsonKrbtpolicy
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.UID != nil {
    raw := in.UID
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.UID = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.UID = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field UID: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field UID: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbmaxticketlife != nil {
    raw := in.Krbmaxticketlife
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Krbmaxticketlife: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Krbmaxticketlife = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbmaxticketlife = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbmaxticketlife: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbmaxticketlife: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbmaxrenewableage != nil {
    raw := in.Krbmaxrenewableage
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Krbmaxrenewableage: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Krbmaxrenewableage = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbmaxrenewableage = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbmaxrenewableage: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbmaxrenewableage: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Location struct {
  
    /*
Location name
IPA location name
    */
    Idnsname interface{} `json:"idnsname,omitempty"`
  
    /*
Description
IPA Location description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Servers
Servers that belongs to the IPA location
    */
    ServersServer *[]string `json:"servers_server,omitempty"`
  
    /*
Advertised by servers
List of servers which advertise the given location
    */
    DNSServer *[]string `json:"dns_server,omitempty"`
  }

func (t *Location) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Location[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Location%v", string(b))
}

type jsonLocation struct {
  
    Idnsname interface{} `json:"idnsname"`
  
    Description interface{} `json:"description"`
  
    ServersServer interface{} `json:"servers_server"`
  
    DNSServer interface{} `json:"dns_server"`
  }

func (out *Location) UnmarshalJSON(data []byte) error {
  var in jsonLocation
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Idnsname
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Idnsname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Idnsname: %v; expected exactly one element", raw)
          }
          out.Idnsname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Idnsname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.ServersServer != nil {
    raw := in.ServersServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ServersServer = &[]string{plainV}
      } else if sliceOk {
        
        out.ServersServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field ServersServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DNSServer != nil {
    raw := in.DNSServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DNSServer = &[]string{plainV}
      } else if sliceOk {
        
        out.DNSServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field DNSServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Metaobject struct {
  
    /*
Name

    */
    Name string `json:"name,omitempty"`
  
    /*
Version

    */
    Version string `json:"version,omitempty"`
  
    /*
Full name

    */
    FullName string `json:"full_name,omitempty"`
  
    /*
Documentation

    */
    Doc *string `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]string `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]string `json:"include,omitempty"`
  
    /*
Help topic

    */
    TopicTopic *string `json:"topic_topic,omitempty"`
  
    /*
Parameters

    */
    ParamsParam *[]string `json:"params_param,omitempty"`
  }

func (t *Metaobject) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Metaobject[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Metaobject%v", string(b))
}

type jsonMetaobject struct {
  
    Name interface{} `json:"name"`
  
    Version interface{} `json:"version"`
  
    FullName interface{} `json:"full_name"`
  
    Doc interface{} `json:"doc"`
  
    Exclude interface{} `json:"exclude"`
  
    Include interface{} `json:"include"`
  
    TopicTopic interface{} `json:"topic_topic"`
  
    ParamsParam interface{} `json:"params_param"`
  }

func (out *Metaobject) UnmarshalJSON(data []byte) error {
  var in jsonMetaobject
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Name
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Name = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Name: %v; expected exactly one element", raw)
          }
          out.Name = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Name: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Version
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Version = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Version: %v; expected exactly one element", raw)
          }
          out.Version = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Version: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.FullName
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.FullName = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field FullName: %v; expected exactly one element", raw)
          }
          out.FullName = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field FullName: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Doc != nil {
    raw := in.Doc
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Doc = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Doc = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Doc: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Doc: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Exclude != nil {
    raw := in.Exclude
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Exclude = &[]string{plainV}
      } else if sliceOk {
        
        out.Exclude = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Exclude: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Include != nil {
    raw := in.Include
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Include = &[]string{plainV}
      } else if sliceOk {
        
        out.Include = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Include: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.TopicTopic != nil {
    raw := in.TopicTopic
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.TopicTopic = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.TopicTopic = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field TopicTopic: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field TopicTopic: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.ParamsParam != nil {
    raw := in.ParamsParam
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ParamsParam = &[]string{plainV}
      } else if sliceOk {
        
        out.ParamsParam = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field ParamsParam: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Netgroup struct {
  
    /*
Netgroup name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
Netgroup description
    */
    Description *string `json:"description,omitempty"`
  
    /*
NIS domain name

    */
    Nisdomainname *string `json:"nisdomainname,omitempty"`
  
    /*
IPA unique ID
IPA unique ID
    */
    Ipauniqueid *string `json:"ipauniqueid,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
Member netgroups

    */
    MemberNetgroup *[]string `json:"member_netgroup,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]string `json:"memberof_netgroup,omitempty"`
  
    /*
Indirect Member netgroups

    */
    MemberindirectNetgroup *[]string `json:"memberindirect_netgroup,omitempty"`
  
    /*
Member User

    */
    MemberuserUser *[]string `json:"memberuser_user,omitempty"`
  
    /*
Member Group

    */
    MemberuserGroup *[]string `json:"memberuser_group,omitempty"`
  
    /*
Member Host

    */
    MemberhostHost *[]string `json:"memberhost_host,omitempty"`
  
    /*
Member Hostgroup

    */
    MemberhostHostgroup *[]string `json:"memberhost_hostgroup,omitempty"`
  }

func (t *Netgroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Netgroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Netgroup%v", string(b))
}

type jsonNetgroup struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    Nisdomainname interface{} `json:"nisdomainname"`
  
    Ipauniqueid interface{} `json:"ipauniqueid"`
  
    Usercategory interface{} `json:"usercategory"`
  
    Hostcategory interface{} `json:"hostcategory"`
  
    Externalhost interface{} `json:"externalhost"`
  
    MemberNetgroup interface{} `json:"member_netgroup"`
  
    MemberofNetgroup interface{} `json:"memberof_netgroup"`
  
    MemberindirectNetgroup interface{} `json:"memberindirect_netgroup"`
  
    MemberuserUser interface{} `json:"memberuser_user"`
  
    MemberuserGroup interface{} `json:"memberuser_group"`
  
    MemberhostHost interface{} `json:"memberhost_host"`
  
    MemberhostHostgroup interface{} `json:"memberhost_hostgroup"`
  }

func (out *Netgroup) UnmarshalJSON(data []byte) error {
  var in jsonNetgroup
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nisdomainname != nil {
    raw := in.Nisdomainname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nisdomainname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Nisdomainname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Nisdomainname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Nisdomainname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipauniqueid != nil {
    raw := in.Ipauniqueid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipauniqueid = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipauniqueid = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipauniqueid: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipauniqueid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Usercategory != nil {
    raw := in.Usercategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Usercategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Usercategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Usercategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Usercategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Hostcategory != nil {
    raw := in.Hostcategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Hostcategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Hostcategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Hostcategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Hostcategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Externalhost != nil {
    raw := in.Externalhost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Externalhost = &[]string{plainV}
      } else if sliceOk {
        
        out.Externalhost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Externalhost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberNetgroup != nil {
    raw := in.MemberNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofNetgroup != nil {
    raw := in.MemberofNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberindirectNetgroup != nil {
    raw := in.MemberindirectNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberindirectNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberindirectNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberindirectNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberuserUser != nil {
    raw := in.MemberuserUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberuserUser = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberuserUser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberuserUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberuserGroup != nil {
    raw := in.MemberuserGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberuserGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberuserGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberuserGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberhostHost != nil {
    raw := in.MemberhostHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberhostHost = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberhostHost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberhostHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberhostHostgroup != nil {
    raw := in.MemberhostHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberhostHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberhostHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberhostHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Otpconfig struct {
  
    /*
TOTP authentication Window
TOTP authentication time variance (seconds)
    */
    Ipatokentotpauthwindow int `json:"ipatokentotpauthwindow,omitempty"`
  
    /*
TOTP Synchronization Window
TOTP synchronization time variance (seconds)
    */
    Ipatokentotpsyncwindow int `json:"ipatokentotpsyncwindow,omitempty"`
  
    /*
HOTP Authentication Window
HOTP authentication skip-ahead
    */
    Ipatokenhotpauthwindow int `json:"ipatokenhotpauthwindow,omitempty"`
  
    /*
HOTP Synchronization Window
HOTP synchronization skip-ahead
    */
    Ipatokenhotpsyncwindow int `json:"ipatokenhotpsyncwindow,omitempty"`
  }

func (t *Otpconfig) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Otpconfig[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Otpconfig%v", string(b))
}

type jsonOtpconfig struct {
  
    Ipatokentotpauthwindow interface{} `json:"ipatokentotpauthwindow"`
  
    Ipatokentotpsyncwindow interface{} `json:"ipatokentotpsyncwindow"`
  
    Ipatokenhotpauthwindow interface{} `json:"ipatokenhotpauthwindow"`
  
    Ipatokenhotpsyncwindow interface{} `json:"ipatokenhotpsyncwindow"`
  }

func (out *Otpconfig) UnmarshalJSON(data []byte) error {
  var in jsonOtpconfig
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Ipatokentotpauthwindow
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipatokentotpauthwindow: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipatokentotpauthwindow = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipatokentotpauthwindow: %v; expected exactly one element", raw)
          }
          out.Ipatokentotpauthwindow = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokentotpauthwindow: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipatokentotpsyncwindow
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipatokentotpsyncwindow: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipatokentotpsyncwindow = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipatokentotpsyncwindow: %v; expected exactly one element", raw)
          }
          out.Ipatokentotpsyncwindow = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokentotpsyncwindow: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipatokenhotpauthwindow
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipatokenhotpauthwindow: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenhotpauthwindow = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipatokenhotpauthwindow: %v; expected exactly one element", raw)
          }
          out.Ipatokenhotpauthwindow = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenhotpauthwindow: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipatokenhotpsyncwindow
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipatokenhotpsyncwindow: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenhotpsyncwindow = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipatokenhotpsyncwindow: %v; expected exactly one element", raw)
          }
          out.Ipatokenhotpsyncwindow = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenhotpsyncwindow: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Otptoken struct {
  
    /*
Unique ID

    */
    Ipatokenuniqueid string `json:"ipatokenuniqueid,omitempty"`
  
    /*
Type
Type of the token
    */
    Type *string `json:"type,omitempty"`
  
    /*
Description
Token description (informational only)
    */
    Description *string `json:"description,omitempty"`
  
    /*
Owner
Assigned user of the token (default: self)
    */
    Ipatokenowner *string `json:"ipatokenowner,omitempty"`
  
    /*
Manager
Assigned manager of the token (default: self)
    */
    ManagedbyUser *string `json:"managedby_user,omitempty"`
  
    /*
Disabled
Mark the token as disabled (default: false)
    */
    Ipatokendisabled *bool `json:"ipatokendisabled,omitempty"`
  
    /*
Validity start
First date/time the token can be used
    */
    Ipatokennotbefore *time.Time `json:"ipatokennotbefore,omitempty"`
  
    /*
Validity end
Last date/time the token can be used
    */
    Ipatokennotafter *time.Time `json:"ipatokennotafter,omitempty"`
  
    /*
Vendor
Token vendor name (informational only)
    */
    Ipatokenvendor *string `json:"ipatokenvendor,omitempty"`
  
    /*
Model
Token model (informational only)
    */
    Ipatokenmodel *string `json:"ipatokenmodel,omitempty"`
  
    /*
Serial
Token serial (informational only)
    */
    Ipatokenserial *string `json:"ipatokenserial,omitempty"`
  
    /*
Key
Token secret (Base32; default: random)
    */
    Ipatokenotpkey *string `json:"ipatokenotpkey,omitempty"`
  
    /*
Algorithm
Token hash algorithm
    */
    Ipatokenotpalgorithm *string `json:"ipatokenotpalgorithm,omitempty"`
  
    /*
Digits
Number of digits each token code will have
    */
    Ipatokenotpdigits *int `json:"ipatokenotpdigits,omitempty"`
  
    /*
Clock offset
TOTP token / FreeIPA server time difference
    */
    Ipatokentotpclockoffset *int `json:"ipatokentotpclockoffset,omitempty"`
  
    /*
Clock interval
Length of TOTP token code validity
    */
    Ipatokentotptimestep *int `json:"ipatokentotptimestep,omitempty"`
  
    /*
Counter
Initial counter for the HOTP token
    */
    Ipatokenhotpcounter *int `json:"ipatokenhotpcounter,omitempty"`
  
    /*
URI

    */
    URI *string `json:"uri,omitempty"`
  }

func (t *Otptoken) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Otptoken[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Otptoken%v", string(b))
}

type jsonOtptoken struct {
  
    Ipatokenuniqueid interface{} `json:"ipatokenuniqueid"`
  
    Type interface{} `json:"type"`
  
    Description interface{} `json:"description"`
  
    Ipatokenowner interface{} `json:"ipatokenowner"`
  
    ManagedbyUser interface{} `json:"managedby_user"`
  
    Ipatokendisabled interface{} `json:"ipatokendisabled"`
  
    Ipatokennotbefore interface{} `json:"ipatokennotbefore"`
  
    Ipatokennotafter interface{} `json:"ipatokennotafter"`
  
    Ipatokenvendor interface{} `json:"ipatokenvendor"`
  
    Ipatokenmodel interface{} `json:"ipatokenmodel"`
  
    Ipatokenserial interface{} `json:"ipatokenserial"`
  
    Ipatokenotpkey interface{} `json:"ipatokenotpkey"`
  
    Ipatokenotpalgorithm interface{} `json:"ipatokenotpalgorithm"`
  
    Ipatokenotpdigits interface{} `json:"ipatokenotpdigits"`
  
    Ipatokentotpclockoffset interface{} `json:"ipatokentotpclockoffset"`
  
    Ipatokentotptimestep interface{} `json:"ipatokentotptimestep"`
  
    Ipatokenhotpcounter interface{} `json:"ipatokenhotpcounter"`
  
    URI interface{} `json:"uri"`
  }

func (out *Otptoken) UnmarshalJSON(data []byte) error {
  var in jsonOtptoken
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Ipatokenuniqueid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenuniqueid = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipatokenuniqueid: %v; expected exactly one element", raw)
          }
          out.Ipatokenuniqueid = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenuniqueid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Type != nil {
    raw := in.Type
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Type = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Type = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Type: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Type: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenowner != nil {
    raw := in.Ipatokenowner
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenowner = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenowner = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenowner: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenowner: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.ManagedbyUser != nil {
    raw := in.ManagedbyUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ManagedbyUser = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.ManagedbyUser = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field ManagedbyUser: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field ManagedbyUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokendisabled != nil {
    raw := in.Ipatokendisabled
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokendisabled = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokendisabled = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokendisabled: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokendisabled: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokennotbefore != nil {
    raw := in.Ipatokennotbefore
    plainV, plainOk := raw.(time.Time)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []time.Time
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(time.Time)
        
        if !itemOk {
          
          // See https://github.com/ccin2p3/go-freeipa/issues/1
          mapV, mapVOk := rawItem.(map[string]interface{})
          if mapVOk {
            timeV, err := tryParseFreeIPADatetimeMap(mapV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = timeV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokennotbefore = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokennotbefore = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokennotbefore: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokennotbefore: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokennotafter != nil {
    raw := in.Ipatokennotafter
    plainV, plainOk := raw.(time.Time)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []time.Time
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(time.Time)
        
        if !itemOk {
          
          // See https://github.com/ccin2p3/go-freeipa/issues/1
          mapV, mapVOk := rawItem.(map[string]interface{})
          if mapVOk {
            timeV, err := tryParseFreeIPADatetimeMap(mapV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = timeV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokennotafter = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokennotafter = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokennotafter: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokennotafter: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenvendor != nil {
    raw := in.Ipatokenvendor
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenvendor = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenvendor = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenvendor: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenvendor: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenmodel != nil {
    raw := in.Ipatokenmodel
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenmodel = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenmodel = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenmodel: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenmodel: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenserial != nil {
    raw := in.Ipatokenserial
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenserial = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenserial = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenserial: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenserial: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenotpkey != nil {
    raw := in.Ipatokenotpkey
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenotpkey = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenotpkey = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenotpkey: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenotpkey: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenotpalgorithm != nil {
    raw := in.Ipatokenotpalgorithm
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenotpalgorithm = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenotpalgorithm = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenotpalgorithm: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenotpalgorithm: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenotpdigits != nil {
    raw := in.Ipatokenotpdigits
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipatokenotpdigits: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenotpdigits = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenotpdigits = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenotpdigits: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenotpdigits: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokentotpclockoffset != nil {
    raw := in.Ipatokentotpclockoffset
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipatokentotpclockoffset: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipatokentotpclockoffset = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokentotpclockoffset = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokentotpclockoffset: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokentotpclockoffset: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokentotptimestep != nil {
    raw := in.Ipatokentotptimestep
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipatokentotptimestep: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipatokentotptimestep = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokentotptimestep = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokentotptimestep: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokentotptimestep: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenhotpcounter != nil {
    raw := in.Ipatokenhotpcounter
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipatokenhotpcounter: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenhotpcounter = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenhotpcounter = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenhotpcounter: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenhotpcounter: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.URI != nil {
    raw := in.URI
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.URI = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.URI = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field URI: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field URI: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Output struct {
  
    /*
Name

    */
    Name string `json:"name,omitempty"`
  
    /*
Documentation

    */
    Doc *string `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]string `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]string `json:"include,omitempty"`
  
    /*
Type

    */
    Type *string `json:"type,omitempty"`
  
    /*
Required

    */
    Required *bool `json:"required,omitempty"`
  
    /*
Multi-value

    */
    Multivalue *bool `json:"multivalue,omitempty"`
  }

func (t *Output) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Output[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Output%v", string(b))
}

type jsonOutput struct {
  
    Name interface{} `json:"name"`
  
    Doc interface{} `json:"doc"`
  
    Exclude interface{} `json:"exclude"`
  
    Include interface{} `json:"include"`
  
    Type interface{} `json:"type"`
  
    Required interface{} `json:"required"`
  
    Multivalue interface{} `json:"multivalue"`
  }

func (out *Output) UnmarshalJSON(data []byte) error {
  var in jsonOutput
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Name
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Name = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Name: %v; expected exactly one element", raw)
          }
          out.Name = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Name: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Doc != nil {
    raw := in.Doc
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Doc = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Doc = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Doc: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Doc: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Exclude != nil {
    raw := in.Exclude
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Exclude = &[]string{plainV}
      } else if sliceOk {
        
        out.Exclude = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Exclude: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Include != nil {
    raw := in.Include
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Include = &[]string{plainV}
      } else if sliceOk {
        
        out.Include = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Include: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Type != nil {
    raw := in.Type
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Type = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Type = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Type: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Type: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Required != nil {
    raw := in.Required
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Required = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Required = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Required: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Required: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Multivalue != nil {
    raw := in.Multivalue
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Multivalue = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Multivalue = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Multivalue: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Multivalue: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Param struct {
  
    /*
Name

    */
    Name string `json:"name,omitempty"`
  
    /*
Documentation

    */
    Doc *string `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]string `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]string `json:"include,omitempty"`
  
    /*
Type

    */
    Type *string `json:"type,omitempty"`
  
    /*
Required

    */
    Required *bool `json:"required,omitempty"`
  
    /*
Multi-value

    */
    Multivalue *bool `json:"multivalue,omitempty"`
  
    /*
Always ask

    */
    Alwaysask *bool `json:"alwaysask,omitempty"`
  
    /*
CLI metavar

    */
    CliMetavar *string `json:"cli_metavar,omitempty"`
  
    /*
CLI name

    */
    CliName *string `json:"cli_name,omitempty"`
  
    /*
Confirm (password)

    */
    Confirm *bool `json:"confirm,omitempty"`
  
    /*
Default

    */
    Default *[]string `json:"default,omitempty"`
  
    /*
Default from

    */
    DefaultFromParam *[]string `json:"default_from_param,omitempty"`
  
    /*
Label

    */
    Label *string `json:"label,omitempty"`
  
    /*
Convert on server

    */
    NoConvert *bool `json:"no_convert,omitempty"`
  
    /*
Option group

    */
    OptionGroup *string `json:"option_group,omitempty"`
  
    /*
Sensitive

    */
    Sensitive *bool `json:"sensitive,omitempty"`
  
    /*
Positional argument

    */
    Positional *bool `json:"positional,omitempty"`
  }

func (t *Param) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Param[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Param%v", string(b))
}

type jsonParam struct {
  
    Name interface{} `json:"name"`
  
    Doc interface{} `json:"doc"`
  
    Exclude interface{} `json:"exclude"`
  
    Include interface{} `json:"include"`
  
    Type interface{} `json:"type"`
  
    Required interface{} `json:"required"`
  
    Multivalue interface{} `json:"multivalue"`
  
    Alwaysask interface{} `json:"alwaysask"`
  
    CliMetavar interface{} `json:"cli_metavar"`
  
    CliName interface{} `json:"cli_name"`
  
    Confirm interface{} `json:"confirm"`
  
    Default interface{} `json:"default"`
  
    DefaultFromParam interface{} `json:"default_from_param"`
  
    Label interface{} `json:"label"`
  
    NoConvert interface{} `json:"no_convert"`
  
    OptionGroup interface{} `json:"option_group"`
  
    Sensitive interface{} `json:"sensitive"`
  
    Positional interface{} `json:"positional"`
  }

func (out *Param) UnmarshalJSON(data []byte) error {
  var in jsonParam
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Name
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Name = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Name: %v; expected exactly one element", raw)
          }
          out.Name = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Name: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Doc != nil {
    raw := in.Doc
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Doc = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Doc = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Doc: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Doc: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Exclude != nil {
    raw := in.Exclude
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Exclude = &[]string{plainV}
      } else if sliceOk {
        
        out.Exclude = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Exclude: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Include != nil {
    raw := in.Include
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Include = &[]string{plainV}
      } else if sliceOk {
        
        out.Include = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Include: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Type != nil {
    raw := in.Type
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Type = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Type = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Type: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Type: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Required != nil {
    raw := in.Required
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Required = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Required = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Required: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Required: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Multivalue != nil {
    raw := in.Multivalue
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Multivalue = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Multivalue = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Multivalue: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Multivalue: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Alwaysask != nil {
    raw := in.Alwaysask
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Alwaysask = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Alwaysask = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Alwaysask: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Alwaysask: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CliMetavar != nil {
    raw := in.CliMetavar
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CliMetavar = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.CliMetavar = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field CliMetavar: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field CliMetavar: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.CliName != nil {
    raw := in.CliName
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.CliName = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.CliName = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field CliName: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field CliName: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Confirm != nil {
    raw := in.Confirm
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Confirm = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Confirm = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Confirm: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Confirm: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Default != nil {
    raw := in.Default
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Default = &[]string{plainV}
      } else if sliceOk {
        
        out.Default = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Default: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DefaultFromParam != nil {
    raw := in.DefaultFromParam
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DefaultFromParam = &[]string{plainV}
      } else if sliceOk {
        
        out.DefaultFromParam = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field DefaultFromParam: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Label != nil {
    raw := in.Label
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Label = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Label = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Label: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Label: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.NoConvert != nil {
    raw := in.NoConvert
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.NoConvert = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.NoConvert = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field NoConvert: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field NoConvert: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.OptionGroup != nil {
    raw := in.OptionGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.OptionGroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.OptionGroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field OptionGroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field OptionGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Sensitive != nil {
    raw := in.Sensitive
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sensitive = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Sensitive = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Sensitive: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Sensitive: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Positional != nil {
    raw := in.Positional
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Positional = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Positional = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Positional: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Positional: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Permission struct {
  
    /*
Permission name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Granted rights
Rights to grant (read, search, compare, write, add, delete, all)
    */
    Ipapermright *[]string `json:"ipapermright,omitempty"`
  
    /*
Effective attributes
All attributes to which the permission applies
    */
    Attrs *[]string `json:"attrs,omitempty"`
  
    /*
Included attributes
User-specified attributes to which the permission applies
    */
    Ipapermincludedattr *[]string `json:"ipapermincludedattr,omitempty"`
  
    /*
Excluded attributes
User-specified attributes to which the permission explicitly does not apply
    */
    Ipapermexcludedattr *[]string `json:"ipapermexcludedattr,omitempty"`
  
    /*
Default attributes
Attributes to which the permission applies by default
    */
    Ipapermdefaultattr *[]string `json:"ipapermdefaultattr,omitempty"`
  
    /*
Bind rule type
Bind rule type
    */
    Ipapermbindruletype string `json:"ipapermbindruletype,omitempty"`
  
    /*
Subtree
Subtree to apply permissions to
    */
    Ipapermlocation *string `json:"ipapermlocation,omitempty"`
  
    /*
Extra target filter
Extra target filter
    */
    Extratargetfilter *[]string `json:"extratargetfilter,omitempty"`
  
    /*
Raw target filter
All target filters, including those implied by type and memberof
    */
    Ipapermtargetfilter *[]string `json:"ipapermtargetfilter,omitempty"`
  
    /*
Target DN
Optional DN to apply the permission to (must be in the subtree, but may not yet exist)
    */
    Ipapermtarget *string `json:"ipapermtarget,omitempty"`
  
    /*
Target DN subtree
Optional DN subtree where an entry can be moved to (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetto *string `json:"ipapermtargetto,omitempty"`
  
    /*
Origin DN subtree
Optional DN subtree from where an entry can be moved (must be in the subtree, but may not yet exist)
    */
    Ipapermtargetfrom *string `json:"ipapermtargetfrom,omitempty"`
  
    /*
Member of group
Target members of a group (sets memberOf targetfilter)
    */
    Memberof *[]string `json:"memberof,omitempty"`
  
    /*
Target group
User group to apply permissions to (sets target)
    */
    Targetgroup *string `json:"targetgroup,omitempty"`
  
    /*
Type
Type of IPA object (sets subtree and objectClass targetfilter)
    */
    Type *string `json:"type,omitempty"`
  
    /*

Deprecated; use extratargetfilter
    */
    Filter *[]string `json:"filter,omitempty"`
  
    /*

Deprecated; use ipapermlocation
    */
    Subtree *[]string `json:"subtree,omitempty"`
  
    /*

Deprecated; use ipapermright
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Permission flags

    */
    Ipapermissiontype []string `json:"ipapermissiontype,omitempty"`
  
    /*
ACI

    */
    Aci string `json:"aci,omitempty"`
  
    /*
Granted to Privilege

    */
    MemberPrivilege *[]string `json:"member_privilege,omitempty"`
  
    /*
Indirect Member of roles

    */
    MemberindirectRole *[]string `json:"memberindirect_role,omitempty"`
  }

func (t *Permission) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Permission[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Permission%v", string(b))
}

type jsonPermission struct {
  
    Cn interface{} `json:"cn"`
  
    Ipapermright interface{} `json:"ipapermright"`
  
    Attrs interface{} `json:"attrs"`
  
    Ipapermincludedattr interface{} `json:"ipapermincludedattr"`
  
    Ipapermexcludedattr interface{} `json:"ipapermexcludedattr"`
  
    Ipapermdefaultattr interface{} `json:"ipapermdefaultattr"`
  
    Ipapermbindruletype interface{} `json:"ipapermbindruletype"`
  
    Ipapermlocation interface{} `json:"ipapermlocation"`
  
    Extratargetfilter interface{} `json:"extratargetfilter"`
  
    Ipapermtargetfilter interface{} `json:"ipapermtargetfilter"`
  
    Ipapermtarget interface{} `json:"ipapermtarget"`
  
    Ipapermtargetto interface{} `json:"ipapermtargetto"`
  
    Ipapermtargetfrom interface{} `json:"ipapermtargetfrom"`
  
    Memberof interface{} `json:"memberof"`
  
    Targetgroup interface{} `json:"targetgroup"`
  
    Type interface{} `json:"type"`
  
    Filter interface{} `json:"filter"`
  
    Subtree interface{} `json:"subtree"`
  
    Permissions interface{} `json:"permissions"`
  
    Ipapermissiontype interface{} `json:"ipapermissiontype"`
  
    Aci interface{} `json:"aci"`
  
    MemberPrivilege interface{} `json:"member_privilege"`
  
    MemberindirectRole interface{} `json:"memberindirect_role"`
  }

func (out *Permission) UnmarshalJSON(data []byte) error {
  var in jsonPermission
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipapermright != nil {
    raw := in.Ipapermright
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipapermright = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipapermright = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipapermright: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Attrs != nil {
    raw := in.Attrs
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Attrs = &[]string{plainV}
      } else if sliceOk {
        
        out.Attrs = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Attrs: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipapermincludedattr != nil {
    raw := in.Ipapermincludedattr
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipapermincludedattr = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipapermincludedattr = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipapermincludedattr: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipapermexcludedattr != nil {
    raw := in.Ipapermexcludedattr
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipapermexcludedattr = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipapermexcludedattr = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipapermexcludedattr: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipapermdefaultattr != nil {
    raw := in.Ipapermdefaultattr
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipapermdefaultattr = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipapermdefaultattr = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipapermdefaultattr: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipapermbindruletype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipapermbindruletype = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipapermbindruletype: %v; expected exactly one element", raw)
          }
          out.Ipapermbindruletype = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipapermbindruletype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipapermlocation != nil {
    raw := in.Ipapermlocation
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipapermlocation = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipapermlocation = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipapermlocation: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipapermlocation: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Extratargetfilter != nil {
    raw := in.Extratargetfilter
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Extratargetfilter = &[]string{plainV}
      } else if sliceOk {
        
        out.Extratargetfilter = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Extratargetfilter: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipapermtargetfilter != nil {
    raw := in.Ipapermtargetfilter
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipapermtargetfilter = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipapermtargetfilter = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipapermtargetfilter: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipapermtarget != nil {
    raw := in.Ipapermtarget
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipapermtarget = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipapermtarget = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipapermtarget: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipapermtarget: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipapermtargetto != nil {
    raw := in.Ipapermtargetto
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipapermtargetto = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipapermtargetto = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipapermtargetto: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipapermtargetto: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipapermtargetfrom != nil {
    raw := in.Ipapermtargetfrom
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipapermtargetfrom = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipapermtargetfrom = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipapermtargetfrom: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipapermtargetfrom: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Memberof != nil {
    raw := in.Memberof
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Memberof = &[]string{plainV}
      } else if sliceOk {
        
        out.Memberof = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Memberof: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Targetgroup != nil {
    raw := in.Targetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Targetgroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Targetgroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Targetgroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Targetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Type != nil {
    raw := in.Type
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Type = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Type = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Type: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Type: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Filter != nil {
    raw := in.Filter
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Filter = &[]string{plainV}
      } else if sliceOk {
        
        out.Filter = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Filter: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Subtree != nil {
    raw := in.Subtree
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Subtree = &[]string{plainV}
      } else if sliceOk {
        
        out.Subtree = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Subtree: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Permissions != nil {
    raw := in.Permissions
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Permissions = &[]string{plainV}
      } else if sliceOk {
        
        out.Permissions = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Permissions: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipapermissiontype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipapermissiontype = []string{plainV}
      } else if sliceOk {
        
          if len(sliceV) < 1 {
            return fmt.Errorf("unexpected value for field Ipapermissiontype: %v; expected at least one element", raw)
          }
        
        out.Ipapermissiontype = sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipapermissiontype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Aci
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Aci = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Aci: %v; expected exactly one element", raw)
          }
          out.Aci = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Aci: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberPrivilege != nil {
    raw := in.MemberPrivilege
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberPrivilege = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberPrivilege = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberPrivilege: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberindirectRole != nil {
    raw := in.MemberindirectRole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberindirectRole = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberindirectRole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberindirectRole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Pkinit struct {
  
    /*
Server name
IPA server hostname
    */
    ServerServer *string `json:"server_server,omitempty"`
  
    /*
PKINIT status
Whether PKINIT is enabled or disabled
    */
    Status *string `json:"status,omitempty"`
  }

func (t *Pkinit) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Pkinit[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Pkinit%v", string(b))
}

type jsonPkinit struct {
  
    ServerServer interface{} `json:"server_server"`
  
    Status interface{} `json:"status"`
  }

func (out *Pkinit) UnmarshalJSON(data []byte) error {
  var in jsonPkinit
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.ServerServer != nil {
    raw := in.ServerServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ServerServer = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.ServerServer = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field ServerServer: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field ServerServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Status != nil {
    raw := in.Status
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Status = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Status = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Status: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Status: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Privilege struct {
  
    /*
Privilege name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
Privilege description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Permissions

    */
    MemberofPermission *[]string `json:"memberof_permission,omitempty"`
  
    /*
Granting privilege to roles

    */
    MemberRole *[]string `json:"member_role,omitempty"`
  }

func (t *Privilege) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Privilege[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Privilege%v", string(b))
}

type jsonPrivilege struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    MemberofPermission interface{} `json:"memberof_permission"`
  
    MemberRole interface{} `json:"member_role"`
  }

func (out *Privilege) UnmarshalJSON(data []byte) error {
  var in jsonPrivilege
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofPermission != nil {
    raw := in.MemberofPermission
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofPermission = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofPermission = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofPermission: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberRole != nil {
    raw := in.MemberRole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberRole = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberRole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberRole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Pwpolicy struct {
  
    /*
Group
Manage password policy for specific group
    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Max lifetime (days)
Maximum password lifetime (in days)
    */
    Krbmaxpwdlife *int `json:"krbmaxpwdlife,omitempty"`
  
    /*
Min lifetime (hours)
Minimum password lifetime (in hours)
    */
    Krbminpwdlife *int `json:"krbminpwdlife,omitempty"`
  
    /*
History size
Password history size
    */
    Krbpwdhistorylength *int `json:"krbpwdhistorylength,omitempty"`
  
    /*
Character classes
Minimum number of character classes
    */
    Krbpwdmindiffchars *int `json:"krbpwdmindiffchars,omitempty"`
  
    /*
Min length
Minimum length of password
    */
    Krbpwdminlength *int `json:"krbpwdminlength,omitempty"`
  
    /*
Priority
Priority of the policy (higher number means lower priority
    */
    Cospriority int `json:"cospriority,omitempty"`
  
    /*
Max failures
Consecutive failures before lockout
    */
    Krbpwdmaxfailure *int `json:"krbpwdmaxfailure,omitempty"`
  
    /*
Failure reset interval
Period after which failure count will be reset (seconds)
    */
    Krbpwdfailurecountinterval *int `json:"krbpwdfailurecountinterval,omitempty"`
  
    /*
Lockout duration
Period for which lockout is enforced (seconds)
    */
    Krbpwdlockoutduration *int `json:"krbpwdlockoutduration,omitempty"`
  }

func (t *Pwpolicy) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Pwpolicy[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Pwpolicy%v", string(b))
}

type jsonPwpolicy struct {
  
    Cn interface{} `json:"cn"`
  
    Krbmaxpwdlife interface{} `json:"krbmaxpwdlife"`
  
    Krbminpwdlife interface{} `json:"krbminpwdlife"`
  
    Krbpwdhistorylength interface{} `json:"krbpwdhistorylength"`
  
    Krbpwdmindiffchars interface{} `json:"krbpwdmindiffchars"`
  
    Krbpwdminlength interface{} `json:"krbpwdminlength"`
  
    Cospriority interface{} `json:"cospriority"`
  
    Krbpwdmaxfailure interface{} `json:"krbpwdmaxfailure"`
  
    Krbpwdfailurecountinterval interface{} `json:"krbpwdfailurecountinterval"`
  
    Krbpwdlockoutduration interface{} `json:"krbpwdlockoutduration"`
  }

func (out *Pwpolicy) UnmarshalJSON(data []byte) error {
  var in jsonPwpolicy
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.Cn != nil {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Cn = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbmaxpwdlife != nil {
    raw := in.Krbmaxpwdlife
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Krbmaxpwdlife: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Krbmaxpwdlife = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbmaxpwdlife = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbmaxpwdlife: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbmaxpwdlife: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbminpwdlife != nil {
    raw := in.Krbminpwdlife
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Krbminpwdlife: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Krbminpwdlife = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbminpwdlife = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbminpwdlife: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbminpwdlife: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbpwdhistorylength != nil {
    raw := in.Krbpwdhistorylength
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Krbpwdhistorylength: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Krbpwdhistorylength = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbpwdhistorylength = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbpwdhistorylength: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbpwdhistorylength: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbpwdmindiffchars != nil {
    raw := in.Krbpwdmindiffchars
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Krbpwdmindiffchars: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Krbpwdmindiffchars = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbpwdmindiffchars = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbpwdmindiffchars: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbpwdmindiffchars: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbpwdminlength != nil {
    raw := in.Krbpwdminlength
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Krbpwdminlength: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Krbpwdminlength = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbpwdminlength = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbpwdminlength: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbpwdminlength: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Cospriority
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Cospriority: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Cospriority = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cospriority: %v; expected exactly one element", raw)
          }
          out.Cospriority = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cospriority: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbpwdmaxfailure != nil {
    raw := in.Krbpwdmaxfailure
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Krbpwdmaxfailure: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Krbpwdmaxfailure = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbpwdmaxfailure = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbpwdmaxfailure: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbpwdmaxfailure: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbpwdfailurecountinterval != nil {
    raw := in.Krbpwdfailurecountinterval
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Krbpwdfailurecountinterval: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Krbpwdfailurecountinterval = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbpwdfailurecountinterval = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbpwdfailurecountinterval: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbpwdfailurecountinterval: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbpwdlockoutduration != nil {
    raw := in.Krbpwdlockoutduration
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Krbpwdlockoutduration: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Krbpwdlockoutduration = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbpwdlockoutduration = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbpwdlockoutduration: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbpwdlockoutduration: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Radiusproxy struct {
  
    /*
RADIUS proxy server name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
A description of this RADIUS proxy server
    */
    Description *string `json:"description,omitempty"`
  
    /*
Server
The hostname or IP (with or without port)
    */
    Ipatokenradiusserver string `json:"ipatokenradiusserver,omitempty"`
  
    /*
Secret
The secret used to encrypt data
    */
    Ipatokenradiussecret string `json:"ipatokenradiussecret,omitempty"`
  
    /*
Timeout
The total timeout across all retries (in seconds)
    */
    Ipatokenradiustimeout *int `json:"ipatokenradiustimeout,omitempty"`
  
    /*
Retries
The number of times to retry authentication
    */
    Ipatokenradiusretries *int `json:"ipatokenradiusretries,omitempty"`
  
    /*
User attribute
The username attribute on the user object
    */
    Ipatokenusermapattribute *string `json:"ipatokenusermapattribute,omitempty"`
  }

func (t *Radiusproxy) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Radiusproxy[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Radiusproxy%v", string(b))
}

type jsonRadiusproxy struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    Ipatokenradiusserver interface{} `json:"ipatokenradiusserver"`
  
    Ipatokenradiussecret interface{} `json:"ipatokenradiussecret"`
  
    Ipatokenradiustimeout interface{} `json:"ipatokenradiustimeout"`
  
    Ipatokenradiusretries interface{} `json:"ipatokenradiusretries"`
  
    Ipatokenusermapattribute interface{} `json:"ipatokenusermapattribute"`
  }

func (out *Radiusproxy) UnmarshalJSON(data []byte) error {
  var in jsonRadiusproxy
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipatokenradiusserver
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenradiusserver = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipatokenradiusserver: %v; expected exactly one element", raw)
          }
          out.Ipatokenradiusserver = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenradiusserver: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipatokenradiussecret
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenradiussecret = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipatokenradiussecret: %v; expected exactly one element", raw)
          }
          out.Ipatokenradiussecret = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenradiussecret: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenradiustimeout != nil {
    raw := in.Ipatokenradiustimeout
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipatokenradiustimeout: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenradiustimeout = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenradiustimeout = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenradiustimeout: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenradiustimeout: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenradiusretries != nil {
    raw := in.Ipatokenradiusretries
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipatokenradiusretries: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenradiusretries = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenradiusretries = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenradiusretries: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenradiusretries: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenusermapattribute != nil {
    raw := in.Ipatokenusermapattribute
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenusermapattribute = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenusermapattribute = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenusermapattribute: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenusermapattribute: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Realmdomains struct {
  
    /*
Domain

    */
    Associateddomain []string `json:"associateddomain,omitempty"`
  
    /*
Add domain

    */
    AddDomain *string `json:"add_domain,omitempty"`
  
    /*
Delete domain

    */
    DelDomain *string `json:"del_domain,omitempty"`
  }

func (t *Realmdomains) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Realmdomains[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Realmdomains%v", string(b))
}

type jsonRealmdomains struct {
  
    Associateddomain interface{} `json:"associateddomain"`
  
    AddDomain interface{} `json:"add_domain"`
  
    DelDomain interface{} `json:"del_domain"`
  }

func (out *Realmdomains) UnmarshalJSON(data []byte) error {
  var in jsonRealmdomains
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Associateddomain
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Associateddomain = []string{plainV}
      } else if sliceOk {
        
          if len(sliceV) < 1 {
            return fmt.Errorf("unexpected value for field Associateddomain: %v; expected at least one element", raw)
          }
        
        out.Associateddomain = sliceV
      } else {
        return fmt.Errorf("unexpected value for field Associateddomain: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.AddDomain != nil {
    raw := in.AddDomain
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.AddDomain = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.AddDomain = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field AddDomain: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field AddDomain: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DelDomain != nil {
    raw := in.DelDomain
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DelDomain = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DelDomain = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DelDomain: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DelDomain: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Role struct {
  
    /*
Role name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
A description of this role-group
    */
    Description *string `json:"description,omitempty"`
  
    /*
Member users

    */
    MemberUser *[]string `json:"member_user,omitempty"`
  
    /*
Member groups

    */
    MemberGroup *[]string `json:"member_group,omitempty"`
  
    /*
Member hosts

    */
    MemberHost *[]string `json:"member_host,omitempty"`
  
    /*
Member host-groups

    */
    MemberHostgroup *[]string `json:"member_hostgroup,omitempty"`
  
    /*
Privileges

    */
    MemberofPrivilege *[]string `json:"memberof_privilege,omitempty"`
  
    /*
Member services

    */
    MemberService *[]string `json:"member_service,omitempty"`
  }

func (t *Role) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Role[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Role%v", string(b))
}

type jsonRole struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    MemberUser interface{} `json:"member_user"`
  
    MemberGroup interface{} `json:"member_group"`
  
    MemberHost interface{} `json:"member_host"`
  
    MemberHostgroup interface{} `json:"member_hostgroup"`
  
    MemberofPrivilege interface{} `json:"memberof_privilege"`
  
    MemberService interface{} `json:"member_service"`
  }

func (out *Role) UnmarshalJSON(data []byte) error {
  var in jsonRole
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberUser != nil {
    raw := in.MemberUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberUser = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberUser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberGroup != nil {
    raw := in.MemberGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberHost != nil {
    raw := in.MemberHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberHost = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberHost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberHostgroup != nil {
    raw := in.MemberHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofPrivilege != nil {
    raw := in.MemberofPrivilege
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofPrivilege = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofPrivilege = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofPrivilege: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberService != nil {
    raw := in.MemberService
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberService = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberService = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberService: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Selfservice struct {
  
    /*
Self-service name
Self-service name
    */
    Aciname string `json:"aciname,omitempty"`
  
    /*
Permissions
Permissions to grant (read, write). Default is write.
    */
    Permissions *[]string `json:"permissions,omitempty"`
  
    /*
Attributes
Attributes to which the permission applies.
    */
    Attrs []string `json:"attrs,omitempty"`
  
    /*
ACI

    */
    Aci string `json:"aci,omitempty"`
  }

func (t *Selfservice) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Selfservice[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Selfservice%v", string(b))
}

type jsonSelfservice struct {
  
    Aciname interface{} `json:"aciname"`
  
    Permissions interface{} `json:"permissions"`
  
    Attrs interface{} `json:"attrs"`
  
    Aci interface{} `json:"aci"`
  }

func (out *Selfservice) UnmarshalJSON(data []byte) error {
  var in jsonSelfservice
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Aciname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Aciname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Aciname: %v; expected exactly one element", raw)
          }
          out.Aciname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Aciname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Permissions != nil {
    raw := in.Permissions
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Permissions = &[]string{plainV}
      } else if sliceOk {
        
        out.Permissions = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Permissions: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Attrs
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Attrs = []string{plainV}
      } else if sliceOk {
        
          if len(sliceV) < 1 {
            return fmt.Errorf("unexpected value for field Attrs: %v; expected at least one element", raw)
          }
        
        out.Attrs = sliceV
      } else {
        return fmt.Errorf("unexpected value for field Attrs: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Aci
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Aci = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Aci: %v; expected exactly one element", raw)
          }
          out.Aci = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Aci: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Selinuxusermap struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
SELinux User

    */
    Ipaselinuxuser string `json:"ipaselinuxuser,omitempty"`
  
    /*
HBAC Rule
HBAC Rule that defines the users, groups and hostgroups
    */
    Seealso *string `json:"seealso,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
Users

    */
    MemberuserUser *[]string `json:"memberuser_user,omitempty"`
  
    /*
User Groups

    */
    MemberuserGroup *[]string `json:"memberuser_group,omitempty"`
  
    /*
Hosts

    */
    MemberhostHost *[]string `json:"memberhost_host,omitempty"`
  
    /*
Host Groups

    */
    MemberhostHostgroup *[]string `json:"memberhost_hostgroup,omitempty"`
  }

func (t *Selinuxusermap) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Selinuxusermap[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Selinuxusermap%v", string(b))
}

type jsonSelinuxusermap struct {
  
    Cn interface{} `json:"cn"`
  
    Ipaselinuxuser interface{} `json:"ipaselinuxuser"`
  
    Seealso interface{} `json:"seealso"`
  
    Usercategory interface{} `json:"usercategory"`
  
    Hostcategory interface{} `json:"hostcategory"`
  
    Description interface{} `json:"description"`
  
    Ipaenabledflag interface{} `json:"ipaenabledflag"`
  
    MemberuserUser interface{} `json:"memberuser_user"`
  
    MemberuserGroup interface{} `json:"memberuser_group"`
  
    MemberhostHost interface{} `json:"memberhost_host"`
  
    MemberhostHostgroup interface{} `json:"memberhost_hostgroup"`
  }

func (out *Selinuxusermap) UnmarshalJSON(data []byte) error {
  var in jsonSelinuxusermap
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipaselinuxuser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaselinuxuser = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipaselinuxuser: %v; expected exactly one element", raw)
          }
          out.Ipaselinuxuser = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaselinuxuser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Seealso != nil {
    raw := in.Seealso
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Seealso = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Seealso = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Seealso: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Seealso: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Usercategory != nil {
    raw := in.Usercategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Usercategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Usercategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Usercategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Usercategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Hostcategory != nil {
    raw := in.Hostcategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Hostcategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Hostcategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Hostcategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Hostcategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipaenabledflag != nil {
    raw := in.Ipaenabledflag
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaenabledflag = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipaenabledflag = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipaenabledflag: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaenabledflag: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberuserUser != nil {
    raw := in.MemberuserUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberuserUser = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberuserUser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberuserUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberuserGroup != nil {
    raw := in.MemberuserGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberuserGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberuserGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberuserGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberhostHost != nil {
    raw := in.MemberhostHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberhostHost = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberhostHost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberhostHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberhostHostgroup != nil {
    raw := in.MemberhostHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberhostHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberhostHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberhostHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Server struct {
  
    /*
Server name
IPA server hostname
    */
    Cn string `json:"cn,omitempty"`
  
    /*


    */
    Iparepltopomanagedsuffix *[]string `json:"iparepltopomanagedsuffix,omitempty"`
  
    /*
Managed suffixes

    */
    IparepltopomanagedsuffixTopologysuffix *[]string `json:"iparepltopomanagedsuffix_topologysuffix,omitempty"`
  
    /*
Min domain level
Minimum domain level
    */
    Ipamindomainlevel int `json:"ipamindomainlevel,omitempty"`
  
    /*
Max domain level
Maximum domain level
    */
    Ipamaxdomainlevel int `json:"ipamaxdomainlevel,omitempty"`
  
    /*
Location
Server location
    */
    IpalocationLocation *interface{} `json:"ipalocation_location,omitempty"`
  
    /*
Service weight
Weight for server services
    */
    Ipaserviceweight *int `json:"ipaserviceweight,omitempty"`
  
    /*
Service relative weight
Relative weight for server services (counts per location)
    */
    ServiceRelativeWeight string `json:"service_relative_weight,omitempty"`
  
    /*
Enabled server roles
List of enabled roles
    */
    EnabledRoleServrole *[]string `json:"enabled_role_servrole,omitempty"`
  }

func (t *Server) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Server[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Server%v", string(b))
}

type jsonServer struct {
  
    Cn interface{} `json:"cn"`
  
    Iparepltopomanagedsuffix interface{} `json:"iparepltopomanagedsuffix"`
  
    IparepltopomanagedsuffixTopologysuffix interface{} `json:"iparepltopomanagedsuffix_topologysuffix"`
  
    Ipamindomainlevel interface{} `json:"ipamindomainlevel"`
  
    Ipamaxdomainlevel interface{} `json:"ipamaxdomainlevel"`
  
    IpalocationLocation interface{} `json:"ipalocation_location"`
  
    Ipaserviceweight interface{} `json:"ipaserviceweight"`
  
    ServiceRelativeWeight interface{} `json:"service_relative_weight"`
  
    EnabledRoleServrole interface{} `json:"enabled_role_servrole"`
  }

func (out *Server) UnmarshalJSON(data []byte) error {
  var in jsonServer
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Iparepltopomanagedsuffix != nil {
    raw := in.Iparepltopomanagedsuffix
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Iparepltopomanagedsuffix = &[]string{plainV}
      } else if sliceOk {
        
        out.Iparepltopomanagedsuffix = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Iparepltopomanagedsuffix: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IparepltopomanagedsuffixTopologysuffix != nil {
    raw := in.IparepltopomanagedsuffixTopologysuffix
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IparepltopomanagedsuffixTopologysuffix = &[]string{plainV}
      } else if sliceOk {
        
        out.IparepltopomanagedsuffixTopologysuffix = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field IparepltopomanagedsuffixTopologysuffix: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipamindomainlevel
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipamindomainlevel: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipamindomainlevel = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipamindomainlevel: %v; expected exactly one element", raw)
          }
          out.Ipamindomainlevel = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipamindomainlevel: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipamaxdomainlevel
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipamaxdomainlevel: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipamaxdomainlevel = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipamaxdomainlevel: %v; expected exactly one element", raw)
          }
          out.Ipamaxdomainlevel = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipamaxdomainlevel: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpalocationLocation != nil {
    raw := in.IpalocationLocation
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpalocationLocation = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.IpalocationLocation = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field IpalocationLocation: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field IpalocationLocation: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipaserviceweight != nil {
    raw := in.Ipaserviceweight
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Ipaserviceweight: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Ipaserviceweight = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipaserviceweight = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipaserviceweight: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaserviceweight: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.ServiceRelativeWeight
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ServiceRelativeWeight = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field ServiceRelativeWeight: %v; expected exactly one element", raw)
          }
          out.ServiceRelativeWeight = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field ServiceRelativeWeight: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.EnabledRoleServrole != nil {
    raw := in.EnabledRoleServrole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.EnabledRoleServrole = &[]string{plainV}
      } else if sliceOk {
        
        out.EnabledRoleServrole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field EnabledRoleServrole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type ServerRole struct {
  
    /*
Server name
IPA server hostname
    */
    ServerServer string `json:"server_server,omitempty"`
  
    /*
Role name
IPA server role name
    */
    RoleServrole string `json:"role_servrole,omitempty"`
  
    /*
Role status
Status of the role
    */
    Status *string `json:"status,omitempty"`
  }

func (t *ServerRole) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("ServerRole[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("ServerRole%v", string(b))
}

type jsonServerRole struct {
  
    ServerServer interface{} `json:"server_server"`
  
    RoleServrole interface{} `json:"role_servrole"`
  
    Status interface{} `json:"status"`
  }

func (out *ServerRole) UnmarshalJSON(data []byte) error {
  var in jsonServerRole
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.ServerServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ServerServer = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field ServerServer: %v; expected exactly one element", raw)
          }
          out.ServerServer = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field ServerServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.RoleServrole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.RoleServrole = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field RoleServrole: %v; expected exactly one element", raw)
          }
          out.RoleServrole = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field RoleServrole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Status != nil {
    raw := in.Status
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Status = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Status = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Status: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Status: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Service struct {
  
    /*
Principal name
Service principal
    */
    Krbcanonicalname string `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias
Service principal alias
    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Certificate
Base-64 encoded service certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Subject

    */
    Subject string `json:"subject,omitempty"`
  
    /*
Serial Number

    */
    SerialNumber string `json:"serial_number,omitempty"`
  
    /*
Serial Number (hex)

    */
    SerialNumberHex string `json:"serial_number_hex,omitempty"`
  
    /*
Issuer

    */
    Issuer string `json:"issuer,omitempty"`
  
    /*
Not Before

    */
    ValidNotBefore string `json:"valid_not_before,omitempty"`
  
    /*
Not After

    */
    ValidNotAfter string `json:"valid_not_after,omitempty"`
  
    /*
Fingerprint (SHA1)

    */
    Sha1Fingerprint string `json:"sha1_fingerprint,omitempty"`
  
    /*
Fingerprint (SHA256)

    */
    Sha256Fingerprint string `json:"sha256_fingerprint,omitempty"`
  
    /*
Revocation reason

    */
    RevocationReason *string `json:"revocation_reason,omitempty"`
  
    /*
PAC type
Override default list of supported PAC types. Use 'NONE' to disable PAC support for this service, e.g. this might be necessary for NFS services.
    */
    Ipakrbauthzdata *[]string `json:"ipakrbauthzdata,omitempty"`
  
    /*
Authentication Indicators
Defines a whitelist for Authentication Indicators. Use 'otp' to allow OTP-based 2FA authentications. Use 'radius' to allow RADIUS-based 2FA authentications. Other values may be used for custom configurations.
    */
    Krbprincipalauthind *[]string `json:"krbprincipalauthind,omitempty"`
  
    /*
Requires pre-authentication
Pre-authentication is required for the service
    */
    Ipakrbrequirespreauth *bool `json:"ipakrbrequirespreauth,omitempty"`
  
    /*
Trusted for delegation
Client credentials may be delegated to the service
    */
    Ipakrbokasdelegate *bool `json:"ipakrbokasdelegate,omitempty"`
  
    /*
Trusted to authenticate as user
The service is allowed to authenticate on behalf of a client
    */
    Ipakrboktoauthasdelegate *bool `json:"ipakrboktoauthasdelegate,omitempty"`
  
    /*
Roles

    */
    MemberofRole *[]string `json:"memberof_role,omitempty"`
  
    /*
Keytab

    */
    HasKeytab *bool `json:"has_keytab,omitempty"`
  
    /*
Managed by

    */
    ManagedbyHost string `json:"managedby_host,omitempty"`
  
    /*
Users allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysUser string `json:"ipaallowedtoperform_read_keys_user,omitempty"`
  
    /*
Groups allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysGroup string `json:"ipaallowedtoperform_read_keys_group,omitempty"`
  
    /*
Hosts allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysHost string `json:"ipaallowedtoperform_read_keys_host,omitempty"`
  
    /*
Host Groups allowed to retrieve keytab

    */
    IpaallowedtoperformReadKeysHostgroup string `json:"ipaallowedtoperform_read_keys_hostgroup,omitempty"`
  
    /*
Users allowed to create keytab

    */
    IpaallowedtoperformWriteKeysUser string `json:"ipaallowedtoperform_write_keys_user,omitempty"`
  
    /*
Groups allowed to create keytab

    */
    IpaallowedtoperformWriteKeysGroup string `json:"ipaallowedtoperform_write_keys_group,omitempty"`
  
    /*
Hosts allowed to create keytab

    */
    IpaallowedtoperformWriteKeysHost string `json:"ipaallowedtoperform_write_keys_host,omitempty"`
  
    /*
Host Groups allowed to create keytab

    */
    IpaallowedtoperformWriteKeysHostgroup string `json:"ipaallowedtoperform_write_keys_hostgroup,omitempty"`
  }

func (t *Service) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Service[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Service%v", string(b))
}

type jsonService struct {
  
    Krbcanonicalname interface{} `json:"krbcanonicalname"`
  
    Krbprincipalname interface{} `json:"krbprincipalname"`
  
    Usercertificate interface{} `json:"usercertificate"`
  
    Subject interface{} `json:"subject"`
  
    SerialNumber interface{} `json:"serial_number"`
  
    SerialNumberHex interface{} `json:"serial_number_hex"`
  
    Issuer interface{} `json:"issuer"`
  
    ValidNotBefore interface{} `json:"valid_not_before"`
  
    ValidNotAfter interface{} `json:"valid_not_after"`
  
    Sha1Fingerprint interface{} `json:"sha1_fingerprint"`
  
    Sha256Fingerprint interface{} `json:"sha256_fingerprint"`
  
    RevocationReason interface{} `json:"revocation_reason"`
  
    Ipakrbauthzdata interface{} `json:"ipakrbauthzdata"`
  
    Krbprincipalauthind interface{} `json:"krbprincipalauthind"`
  
    Ipakrbrequirespreauth interface{} `json:"ipakrbrequirespreauth"`
  
    Ipakrbokasdelegate interface{} `json:"ipakrbokasdelegate"`
  
    Ipakrboktoauthasdelegate interface{} `json:"ipakrboktoauthasdelegate"`
  
    MemberofRole interface{} `json:"memberof_role"`
  
    HasKeytab interface{} `json:"has_keytab"`
  
    ManagedbyHost interface{} `json:"managedby_host"`
  
    IpaallowedtoperformReadKeysUser interface{} `json:"ipaallowedtoperform_read_keys_user"`
  
    IpaallowedtoperformReadKeysGroup interface{} `json:"ipaallowedtoperform_read_keys_group"`
  
    IpaallowedtoperformReadKeysHost interface{} `json:"ipaallowedtoperform_read_keys_host"`
  
    IpaallowedtoperformReadKeysHostgroup interface{} `json:"ipaallowedtoperform_read_keys_hostgroup"`
  
    IpaallowedtoperformWriteKeysUser interface{} `json:"ipaallowedtoperform_write_keys_user"`
  
    IpaallowedtoperformWriteKeysGroup interface{} `json:"ipaallowedtoperform_write_keys_group"`
  
    IpaallowedtoperformWriteKeysHost interface{} `json:"ipaallowedtoperform_write_keys_host"`
  
    IpaallowedtoperformWriteKeysHostgroup interface{} `json:"ipaallowedtoperform_write_keys_hostgroup"`
  }

func (out *Service) UnmarshalJSON(data []byte) error {
  var in jsonService
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Krbcanonicalname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbcanonicalname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Krbcanonicalname: %v; expected exactly one element", raw)
          }
          out.Krbcanonicalname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Krbcanonicalname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbprincipalname != nil {
    raw := in.Krbprincipalname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbprincipalname = &[]string{plainV}
      } else if sliceOk {
        
        out.Krbprincipalname = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Krbprincipalname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Usercertificate != nil {
    raw := in.Usercertificate
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Usercertificate = &[]interface{}{plainV}
      } else if sliceOk {
        
        out.Usercertificate = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Usercertificate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Subject
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Subject = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Subject: %v; expected exactly one element", raw)
          }
          out.Subject = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Subject: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.SerialNumber
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SerialNumber = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field SerialNumber: %v; expected exactly one element", raw)
          }
          out.SerialNumber = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field SerialNumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.SerialNumberHex
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.SerialNumberHex = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field SerialNumberHex: %v; expected exactly one element", raw)
          }
          out.SerialNumberHex = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field SerialNumberHex: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Issuer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Issuer = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Issuer: %v; expected exactly one element", raw)
          }
          out.Issuer = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Issuer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.ValidNotBefore
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ValidNotBefore = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field ValidNotBefore: %v; expected exactly one element", raw)
          }
          out.ValidNotBefore = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field ValidNotBefore: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.ValidNotAfter
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ValidNotAfter = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field ValidNotAfter: %v; expected exactly one element", raw)
          }
          out.ValidNotAfter = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field ValidNotAfter: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Sha1Fingerprint
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sha1Fingerprint = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Sha1Fingerprint: %v; expected exactly one element", raw)
          }
          out.Sha1Fingerprint = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Sha1Fingerprint: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Sha256Fingerprint
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sha256Fingerprint = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Sha256Fingerprint: %v; expected exactly one element", raw)
          }
          out.Sha256Fingerprint = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Sha256Fingerprint: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.RevocationReason != nil {
    raw := in.RevocationReason
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.RevocationReason = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.RevocationReason = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field RevocationReason: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field RevocationReason: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipakrbauthzdata != nil {
    raw := in.Ipakrbauthzdata
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipakrbauthzdata = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipakrbauthzdata = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipakrbauthzdata: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbprincipalauthind != nil {
    raw := in.Krbprincipalauthind
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbprincipalauthind = &[]string{plainV}
      } else if sliceOk {
        
        out.Krbprincipalauthind = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Krbprincipalauthind: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipakrbrequirespreauth != nil {
    raw := in.Ipakrbrequirespreauth
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipakrbrequirespreauth = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipakrbrequirespreauth = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipakrbrequirespreauth: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipakrbrequirespreauth: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipakrbokasdelegate != nil {
    raw := in.Ipakrbokasdelegate
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipakrbokasdelegate = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipakrbokasdelegate = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipakrbokasdelegate: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipakrbokasdelegate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipakrboktoauthasdelegate != nil {
    raw := in.Ipakrboktoauthasdelegate
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipakrboktoauthasdelegate = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipakrboktoauthasdelegate = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipakrboktoauthasdelegate: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipakrboktoauthasdelegate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofRole != nil {
    raw := in.MemberofRole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofRole = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofRole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofRole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.HasKeytab != nil {
    raw := in.HasKeytab
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.HasKeytab = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.HasKeytab = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field HasKeytab: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field HasKeytab: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.ManagedbyHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.ManagedbyHost = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field ManagedbyHost: %v; expected exactly one element", raw)
          }
          out.ManagedbyHost = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field ManagedbyHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.IpaallowedtoperformReadKeysUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformReadKeysUser = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysUser: %v; expected exactly one element", raw)
          }
          out.IpaallowedtoperformReadKeysUser = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.IpaallowedtoperformReadKeysGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformReadKeysGroup = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysGroup: %v; expected exactly one element", raw)
          }
          out.IpaallowedtoperformReadKeysGroup = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.IpaallowedtoperformReadKeysHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformReadKeysHost = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysHost: %v; expected exactly one element", raw)
          }
          out.IpaallowedtoperformReadKeysHost = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.IpaallowedtoperformReadKeysHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformReadKeysHostgroup = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysHostgroup: %v; expected exactly one element", raw)
          }
          out.IpaallowedtoperformReadKeysHostgroup = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformReadKeysHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.IpaallowedtoperformWriteKeysUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformWriteKeysUser = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysUser: %v; expected exactly one element", raw)
          }
          out.IpaallowedtoperformWriteKeysUser = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.IpaallowedtoperformWriteKeysGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformWriteKeysGroup = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysGroup: %v; expected exactly one element", raw)
          }
          out.IpaallowedtoperformWriteKeysGroup = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.IpaallowedtoperformWriteKeysHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformWriteKeysHost = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysHost: %v; expected exactly one element", raw)
          }
          out.IpaallowedtoperformWriteKeysHost = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.IpaallowedtoperformWriteKeysHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtoperformWriteKeysHostgroup = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysHostgroup: %v; expected exactly one element", raw)
          }
          out.IpaallowedtoperformWriteKeysHostgroup = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtoperformWriteKeysHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Servicedelegationrule struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Allowed Target

    */
    IpaallowedtargetServicedelegationtarget string `json:"ipaallowedtarget_servicedelegationtarget,omitempty"`
  
    /*
Allowed to Impersonate

    */
    Ipaallowedtoimpersonate string `json:"ipaallowedtoimpersonate,omitempty"`
  
    /*
Member principals

    */
    Memberprincipal string `json:"memberprincipal,omitempty"`
  }

func (t *Servicedelegationrule) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Servicedelegationrule[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Servicedelegationrule%v", string(b))
}

type jsonServicedelegationrule struct {
  
    Cn interface{} `json:"cn"`
  
    IpaallowedtargetServicedelegationtarget interface{} `json:"ipaallowedtarget_servicedelegationtarget"`
  
    Ipaallowedtoimpersonate interface{} `json:"ipaallowedtoimpersonate"`
  
    Memberprincipal interface{} `json:"memberprincipal"`
  }

func (out *Servicedelegationrule) UnmarshalJSON(data []byte) error {
  var in jsonServicedelegationrule
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.IpaallowedtargetServicedelegationtarget
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtargetServicedelegationtarget = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtargetServicedelegationtarget: %v; expected exactly one element", raw)
          }
          out.IpaallowedtargetServicedelegationtarget = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtargetServicedelegationtarget: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipaallowedtoimpersonate
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaallowedtoimpersonate = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipaallowedtoimpersonate: %v; expected exactly one element", raw)
          }
          out.Ipaallowedtoimpersonate = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaallowedtoimpersonate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Memberprincipal
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Memberprincipal = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Memberprincipal: %v; expected exactly one element", raw)
          }
          out.Memberprincipal = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Memberprincipal: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Servicedelegationtarget struct {
  
    /*
Delegation name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Allowed Target

    */
    IpaallowedtargetServicedelegationtarget string `json:"ipaallowedtarget_servicedelegationtarget,omitempty"`
  
    /*
Allowed to Impersonate

    */
    Ipaallowedtoimpersonate string `json:"ipaallowedtoimpersonate,omitempty"`
  
    /*
Member principals

    */
    Memberprincipal string `json:"memberprincipal,omitempty"`
  }

func (t *Servicedelegationtarget) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Servicedelegationtarget[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Servicedelegationtarget%v", string(b))
}

type jsonServicedelegationtarget struct {
  
    Cn interface{} `json:"cn"`
  
    IpaallowedtargetServicedelegationtarget interface{} `json:"ipaallowedtarget_servicedelegationtarget"`
  
    Ipaallowedtoimpersonate interface{} `json:"ipaallowedtoimpersonate"`
  
    Memberprincipal interface{} `json:"memberprincipal"`
  }

func (out *Servicedelegationtarget) UnmarshalJSON(data []byte) error {
  var in jsonServicedelegationtarget
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.IpaallowedtargetServicedelegationtarget
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpaallowedtargetServicedelegationtarget = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field IpaallowedtargetServicedelegationtarget: %v; expected exactly one element", raw)
          }
          out.IpaallowedtargetServicedelegationtarget = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field IpaallowedtargetServicedelegationtarget: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipaallowedtoimpersonate
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaallowedtoimpersonate = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipaallowedtoimpersonate: %v; expected exactly one element", raw)
          }
          out.Ipaallowedtoimpersonate = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaallowedtoimpersonate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Memberprincipal
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Memberprincipal = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Memberprincipal: %v; expected exactly one element", raw)
          }
          out.Memberprincipal = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Memberprincipal: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Servrole struct {
  
    /*
Role name
IPA role name
    */
    Name string `json:"name,omitempty"`
  }

func (t *Servrole) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Servrole[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Servrole%v", string(b))
}

type jsonServrole struct {
  
    Name interface{} `json:"name"`
  }

func (out *Servrole) UnmarshalJSON(data []byte) error {
  var in jsonServrole
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Name
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Name = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Name: %v; expected exactly one element", raw)
          }
          out.Name = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Name: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Stageuser struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  
    /*
First name

    */
    Givenname string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal name

    */
    Krbcanonicalname *string `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *bool `json:"random,omitempty"`
  
    /*
Random password

    */
    Randompassword *string `json:"randompassword,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
SSH public key fingerprint

    */
    Sshpubkeyfp *[]string `json:"sshpubkeyfp,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Certificate mapping data
Certificate mapping data
    */
    Ipacertmapdata *[]string `json:"ipacertmapdata,omitempty"`
  
    /*
Password

    */
    HasPassword *bool `json:"has_password,omitempty"`
  
    /*
Member of groups

    */
    MemberofGroup *[]string `json:"memberof_group,omitempty"`
  
    /*
Roles

    */
    MemberofRole *[]string `json:"memberof_role,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]string `json:"memberof_netgroup,omitempty"`
  
    /*
Member of Sudo rule

    */
    MemberofSudorule *[]string `json:"memberof_sudorule,omitempty"`
  
    /*
Member of HBAC rule

    */
    MemberofHbacrule *[]string `json:"memberof_hbacrule,omitempty"`
  
    /*
Indirect Member of group

    */
    MemberofindirectGroup *[]string `json:"memberofindirect_group,omitempty"`
  
    /*
Indirect Member of netgroup

    */
    MemberofindirectNetgroup *[]string `json:"memberofindirect_netgroup,omitempty"`
  
    /*
Indirect Member of role

    */
    MemberofindirectRole *[]string `json:"memberofindirect_role,omitempty"`
  
    /*
Indirect Member of Sudo rule

    */
    MemberofindirectSudorule *[]string `json:"memberofindirect_sudorule,omitempty"`
  
    /*
Indirect Member of HBAC rule

    */
    MemberofindirectHbacrule *[]string `json:"memberofindirect_hbacrule,omitempty"`
  
    /*
Kerberos keys available

    */
    HasKeytab *bool `json:"has_keytab,omitempty"`
  }

func (t *Stageuser) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Stageuser[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Stageuser%v", string(b))
}

type jsonStageuser struct {
  
    UID interface{} `json:"uid"`
  
    Givenname interface{} `json:"givenname"`
  
    Sn interface{} `json:"sn"`
  
    Cn interface{} `json:"cn"`
  
    Displayname interface{} `json:"displayname"`
  
    Initials interface{} `json:"initials"`
  
    Homedirectory interface{} `json:"homedirectory"`
  
    Gecos interface{} `json:"gecos"`
  
    Loginshell interface{} `json:"loginshell"`
  
    Krbcanonicalname interface{} `json:"krbcanonicalname"`
  
    Krbprincipalname interface{} `json:"krbprincipalname"`
  
    Krbprincipalexpiration interface{} `json:"krbprincipalexpiration"`
  
    Krbpasswordexpiration interface{} `json:"krbpasswordexpiration"`
  
    Mail interface{} `json:"mail"`
  
    Userpassword interface{} `json:"userpassword"`
  
    Random interface{} `json:"random"`
  
    Randompassword interface{} `json:"randompassword"`
  
    Uidnumber interface{} `json:"uidnumber"`
  
    Gidnumber interface{} `json:"gidnumber"`
  
    Street interface{} `json:"street"`
  
    L interface{} `json:"l"`
  
    St interface{} `json:"st"`
  
    Postalcode interface{} `json:"postalcode"`
  
    Telephonenumber interface{} `json:"telephonenumber"`
  
    Mobile interface{} `json:"mobile"`
  
    Pager interface{} `json:"pager"`
  
    Facsimiletelephonenumber interface{} `json:"facsimiletelephonenumber"`
  
    Ou interface{} `json:"ou"`
  
    Title interface{} `json:"title"`
  
    Manager interface{} `json:"manager"`
  
    Carlicense interface{} `json:"carlicense"`
  
    Ipasshpubkey interface{} `json:"ipasshpubkey"`
  
    Sshpubkeyfp interface{} `json:"sshpubkeyfp"`
  
    Ipauserauthtype interface{} `json:"ipauserauthtype"`
  
    Userclass interface{} `json:"userclass"`
  
    Ipatokenradiusconfiglink interface{} `json:"ipatokenradiusconfiglink"`
  
    Ipatokenradiususername interface{} `json:"ipatokenradiususername"`
  
    Departmentnumber interface{} `json:"departmentnumber"`
  
    Employeenumber interface{} `json:"employeenumber"`
  
    Employeetype interface{} `json:"employeetype"`
  
    Preferredlanguage interface{} `json:"preferredlanguage"`
  
    Usercertificate interface{} `json:"usercertificate"`
  
    Ipacertmapdata interface{} `json:"ipacertmapdata"`
  
    HasPassword interface{} `json:"has_password"`
  
    MemberofGroup interface{} `json:"memberof_group"`
  
    MemberofRole interface{} `json:"memberof_role"`
  
    MemberofNetgroup interface{} `json:"memberof_netgroup"`
  
    MemberofSudorule interface{} `json:"memberof_sudorule"`
  
    MemberofHbacrule interface{} `json:"memberof_hbacrule"`
  
    MemberofindirectGroup interface{} `json:"memberofindirect_group"`
  
    MemberofindirectNetgroup interface{} `json:"memberofindirect_netgroup"`
  
    MemberofindirectRole interface{} `json:"memberofindirect_role"`
  
    MemberofindirectSudorule interface{} `json:"memberofindirect_sudorule"`
  
    MemberofindirectHbacrule interface{} `json:"memberofindirect_hbacrule"`
  
    HasKeytab interface{} `json:"has_keytab"`
  }

func (out *Stageuser) UnmarshalJSON(data []byte) error {
  var in jsonStageuser
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.UID
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.UID = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field UID: %v; expected exactly one element", raw)
          }
          out.UID = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field UID: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Givenname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Givenname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Givenname: %v; expected exactly one element", raw)
          }
          out.Givenname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Givenname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Sn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Sn: %v; expected exactly one element", raw)
          }
          out.Sn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Sn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Displayname != nil {
    raw := in.Displayname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Displayname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Displayname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Displayname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Displayname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Initials != nil {
    raw := in.Initials
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Initials = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Initials = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Initials: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Initials: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Homedirectory != nil {
    raw := in.Homedirectory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Homedirectory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Homedirectory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Homedirectory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Homedirectory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Gecos != nil {
    raw := in.Gecos
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Gecos = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Gecos = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Gecos: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Gecos: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Loginshell != nil {
    raw := in.Loginshell
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Loginshell = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Loginshell = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Loginshell: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Loginshell: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbcanonicalname != nil {
    raw := in.Krbcanonicalname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbcanonicalname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbcanonicalname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbcanonicalname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbcanonicalname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbprincipalname != nil {
    raw := in.Krbprincipalname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbprincipalname = &[]string{plainV}
      } else if sliceOk {
        
        out.Krbprincipalname = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Krbprincipalname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbprincipalexpiration != nil {
    raw := in.Krbprincipalexpiration
    plainV, plainOk := raw.(time.Time)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []time.Time
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(time.Time)
        
        if !itemOk {
          
          // See https://github.com/ccin2p3/go-freeipa/issues/1
          mapV, mapVOk := rawItem.(map[string]interface{})
          if mapVOk {
            timeV, err := tryParseFreeIPADatetimeMap(mapV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = timeV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbprincipalexpiration = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbprincipalexpiration = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbprincipalexpiration: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbprincipalexpiration: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbpasswordexpiration != nil {
    raw := in.Krbpasswordexpiration
    plainV, plainOk := raw.(time.Time)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []time.Time
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(time.Time)
        
        if !itemOk {
          
          // See https://github.com/ccin2p3/go-freeipa/issues/1
          mapV, mapVOk := rawItem.(map[string]interface{})
          if mapVOk {
            timeV, err := tryParseFreeIPADatetimeMap(mapV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = timeV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbpasswordexpiration = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbpasswordexpiration = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbpasswordexpiration: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbpasswordexpiration: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Mail != nil {
    raw := in.Mail
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Mail = &[]string{plainV}
      } else if sliceOk {
        
        out.Mail = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Mail: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Userpassword != nil {
    raw := in.Userpassword
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Userpassword = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Userpassword = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Userpassword: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Userpassword: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Random != nil {
    raw := in.Random
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Random = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Random = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Random: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Random: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Randompassword != nil {
    raw := in.Randompassword
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Randompassword = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Randompassword = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Randompassword: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Randompassword: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Uidnumber != nil {
    raw := in.Uidnumber
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Uidnumber: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Uidnumber = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Uidnumber = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Uidnumber: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Uidnumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Gidnumber != nil {
    raw := in.Gidnumber
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Gidnumber: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Gidnumber = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Gidnumber = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Gidnumber: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Gidnumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Street != nil {
    raw := in.Street
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Street = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Street = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Street: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Street: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.L != nil {
    raw := in.L
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.L = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.L = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field L: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field L: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.St != nil {
    raw := in.St
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.St = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.St = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field St: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field St: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Postalcode != nil {
    raw := in.Postalcode
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Postalcode = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Postalcode = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Postalcode: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Postalcode: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Telephonenumber != nil {
    raw := in.Telephonenumber
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Telephonenumber = &[]string{plainV}
      } else if sliceOk {
        
        out.Telephonenumber = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Telephonenumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Mobile != nil {
    raw := in.Mobile
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Mobile = &[]string{plainV}
      } else if sliceOk {
        
        out.Mobile = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Mobile: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Pager != nil {
    raw := in.Pager
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Pager = &[]string{plainV}
      } else if sliceOk {
        
        out.Pager = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Pager: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Facsimiletelephonenumber != nil {
    raw := in.Facsimiletelephonenumber
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Facsimiletelephonenumber = &[]string{plainV}
      } else if sliceOk {
        
        out.Facsimiletelephonenumber = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Facsimiletelephonenumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ou != nil {
    raw := in.Ou
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ou = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ou = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ou: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ou: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Title != nil {
    raw := in.Title
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Title = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Title = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Title: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Title: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Manager != nil {
    raw := in.Manager
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Manager = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Manager = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Manager: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Manager: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Carlicense != nil {
    raw := in.Carlicense
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Carlicense = &[]string{plainV}
      } else if sliceOk {
        
        out.Carlicense = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Carlicense: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipasshpubkey != nil {
    raw := in.Ipasshpubkey
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipasshpubkey = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipasshpubkey = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipasshpubkey: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Sshpubkeyfp != nil {
    raw := in.Sshpubkeyfp
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sshpubkeyfp = &[]string{plainV}
      } else if sliceOk {
        
        out.Sshpubkeyfp = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Sshpubkeyfp: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipauserauthtype != nil {
    raw := in.Ipauserauthtype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipauserauthtype = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipauserauthtype = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipauserauthtype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Userclass != nil {
    raw := in.Userclass
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Userclass = &[]string{plainV}
      } else if sliceOk {
        
        out.Userclass = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Userclass: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenradiusconfiglink != nil {
    raw := in.Ipatokenradiusconfiglink
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenradiusconfiglink = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenradiusconfiglink = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenradiusconfiglink: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenradiusconfiglink: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenradiususername != nil {
    raw := in.Ipatokenradiususername
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenradiususername = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenradiususername = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenradiususername: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenradiususername: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Departmentnumber != nil {
    raw := in.Departmentnumber
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Departmentnumber = &[]string{plainV}
      } else if sliceOk {
        
        out.Departmentnumber = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Departmentnumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Employeenumber != nil {
    raw := in.Employeenumber
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Employeenumber = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Employeenumber = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Employeenumber: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Employeenumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Employeetype != nil {
    raw := in.Employeetype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Employeetype = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Employeetype = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Employeetype: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Employeetype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Preferredlanguage != nil {
    raw := in.Preferredlanguage
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Preferredlanguage = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Preferredlanguage = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Preferredlanguage: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Preferredlanguage: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Usercertificate != nil {
    raw := in.Usercertificate
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Usercertificate = &[]interface{}{plainV}
      } else if sliceOk {
        
        out.Usercertificate = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Usercertificate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipacertmapdata != nil {
    raw := in.Ipacertmapdata
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacertmapdata = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipacertmapdata = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipacertmapdata: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.HasPassword != nil {
    raw := in.HasPassword
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.HasPassword = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.HasPassword = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field HasPassword: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field HasPassword: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofGroup != nil {
    raw := in.MemberofGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofRole != nil {
    raw := in.MemberofRole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofRole = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofRole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofRole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofNetgroup != nil {
    raw := in.MemberofNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofSudorule != nil {
    raw := in.MemberofSudorule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofSudorule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofSudorule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofSudorule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofHbacrule != nil {
    raw := in.MemberofHbacrule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofHbacrule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofHbacrule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofHbacrule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectGroup != nil {
    raw := in.MemberofindirectGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectNetgroup != nil {
    raw := in.MemberofindirectNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectRole != nil {
    raw := in.MemberofindirectRole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectRole = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectRole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectRole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectSudorule != nil {
    raw := in.MemberofindirectSudorule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectSudorule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectSudorule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectSudorule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectHbacrule != nil {
    raw := in.MemberofindirectHbacrule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectHbacrule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectHbacrule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectHbacrule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.HasKeytab != nil {
    raw := in.HasKeytab
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.HasKeytab = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.HasKeytab = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field HasKeytab: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field HasKeytab: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Sudocmd struct {
  
    /*
Sudo Command

    */
    Sudocmd string `json:"sudocmd,omitempty"`
  
    /*
Description
A description of this command
    */
    Description *string `json:"description,omitempty"`
  
    /*
Sudo Command Groups

    */
    MemberofSudocmdgroup *[]string `json:"memberof_sudocmdgroup,omitempty"`
  }

func (t *Sudocmd) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Sudocmd[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Sudocmd%v", string(b))
}

type jsonSudocmd struct {
  
    Sudocmd interface{} `json:"sudocmd"`
  
    Description interface{} `json:"description"`
  
    MemberofSudocmdgroup interface{} `json:"memberof_sudocmdgroup"`
  }

func (out *Sudocmd) UnmarshalJSON(data []byte) error {
  var in jsonSudocmd
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Sudocmd
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sudocmd = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Sudocmd: %v; expected exactly one element", raw)
          }
          out.Sudocmd = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Sudocmd: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofSudocmdgroup != nil {
    raw := in.MemberofSudocmdgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofSudocmdgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofSudocmdgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofSudocmdgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Sudocmdgroup struct {
  
    /*
Sudo Command Group

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
Group description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Commands

    */
    MembercmdSudocmd *[]string `json:"membercmd_sudocmd,omitempty"`
  
    /*
Sudo Command Groups

    */
    MembercmdSudocmdgroup *[]string `json:"membercmd_sudocmdgroup,omitempty"`
  
    /*
Member Sudo commands

    */
    MemberSudocmd *[]string `json:"member_sudocmd,omitempty"`
  }

func (t *Sudocmdgroup) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Sudocmdgroup[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Sudocmdgroup%v", string(b))
}

type jsonSudocmdgroup struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    MembercmdSudocmd interface{} `json:"membercmd_sudocmd"`
  
    MembercmdSudocmdgroup interface{} `json:"membercmd_sudocmdgroup"`
  
    MemberSudocmd interface{} `json:"member_sudocmd"`
  }

func (out *Sudocmdgroup) UnmarshalJSON(data []byte) error {
  var in jsonSudocmdgroup
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MembercmdSudocmd != nil {
    raw := in.MembercmdSudocmd
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MembercmdSudocmd = &[]string{plainV}
      } else if sliceOk {
        
        out.MembercmdSudocmd = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MembercmdSudocmd: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MembercmdSudocmdgroup != nil {
    raw := in.MembercmdSudocmdgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MembercmdSudocmdgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MembercmdSudocmdgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MembercmdSudocmdgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberSudocmd != nil {
    raw := in.MemberSudocmd
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberSudocmd = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberSudocmd = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberSudocmd: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Sudorule struct {
  
    /*
Rule name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description

    */
    Description *string `json:"description,omitempty"`
  
    /*
Enabled

    */
    Ipaenabledflag *bool `json:"ipaenabledflag,omitempty"`
  
    /*
User category
User category the rule applies to
    */
    Usercategory *string `json:"usercategory,omitempty"`
  
    /*
Host category
Host category the rule applies to
    */
    Hostcategory *string `json:"hostcategory,omitempty"`
  
    /*
Command category
Command category the rule applies to
    */
    Cmdcategory *string `json:"cmdcategory,omitempty"`
  
    /*
RunAs User category
RunAs User category the rule applies to
    */
    Ipasudorunasusercategory *string `json:"ipasudorunasusercategory,omitempty"`
  
    /*
RunAs Group category
RunAs Group category the rule applies to
    */
    Ipasudorunasgroupcategory *string `json:"ipasudorunasgroupcategory,omitempty"`
  
    /*
Sudo order
integer to order the Sudo rules
    */
    Sudoorder *int `json:"sudoorder,omitempty"`
  
    /*
Users

    */
    MemberuserUser *[]string `json:"memberuser_user,omitempty"`
  
    /*
User Groups

    */
    MemberuserGroup *[]string `json:"memberuser_group,omitempty"`
  
    /*
External User
External User the rule applies to (sudorule-find only)
    */
    Externaluser *[]string `json:"externaluser,omitempty"`
  
    /*
Hosts

    */
    MemberhostHost *[]string `json:"memberhost_host,omitempty"`
  
    /*
Host Groups

    */
    MemberhostHostgroup *[]string `json:"memberhost_hostgroup,omitempty"`
  
    /*
Host Masks

    */
    Hostmask *[]string `json:"hostmask,omitempty"`
  
    /*
External host

    */
    Externalhost *[]string `json:"externalhost,omitempty"`
  
    /*
Sudo Allow Commands

    */
    MemberallowcmdSudocmd *[]string `json:"memberallowcmd_sudocmd,omitempty"`
  
    /*
Sudo Deny Commands

    */
    MemberdenycmdSudocmd *[]string `json:"memberdenycmd_sudocmd,omitempty"`
  
    /*
Sudo Allow Command Groups

    */
    MemberallowcmdSudocmdgroup *[]string `json:"memberallowcmd_sudocmdgroup,omitempty"`
  
    /*
Sudo Deny Command Groups

    */
    MemberdenycmdSudocmdgroup *[]string `json:"memberdenycmd_sudocmdgroup,omitempty"`
  
    /*
RunAs Users
Run as a user
    */
    IpasudorunasUser *[]string `json:"ipasudorunas_user,omitempty"`
  
    /*
Groups of RunAs Users
Run as any user within a specified group
    */
    IpasudorunasGroup *[]string `json:"ipasudorunas_group,omitempty"`
  
    /*
RunAs External User
External User the commands can run as (sudorule-find only)
    */
    Ipasudorunasextuser *[]string `json:"ipasudorunasextuser,omitempty"`
  
    /*
External Groups of RunAs Users
External Groups of users that the command can run as
    */
    Ipasudorunasextusergroup *[]string `json:"ipasudorunasextusergroup,omitempty"`
  
    /*
RunAs Groups
Run with the gid of a specified POSIX group
    */
    IpasudorunasgroupGroup *[]string `json:"ipasudorunasgroup_group,omitempty"`
  
    /*
RunAs External Group
External Group the commands can run as (sudorule-find only)
    */
    Ipasudorunasextgroup *[]string `json:"ipasudorunasextgroup,omitempty"`
  
    /*
Sudo Option

    */
    Ipasudoopt *[]string `json:"ipasudoopt,omitempty"`
  }

func (t *Sudorule) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Sudorule[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Sudorule%v", string(b))
}

type jsonSudorule struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    Ipaenabledflag interface{} `json:"ipaenabledflag"`
  
    Usercategory interface{} `json:"usercategory"`
  
    Hostcategory interface{} `json:"hostcategory"`
  
    Cmdcategory interface{} `json:"cmdcategory"`
  
    Ipasudorunasusercategory interface{} `json:"ipasudorunasusercategory"`
  
    Ipasudorunasgroupcategory interface{} `json:"ipasudorunasgroupcategory"`
  
    Sudoorder interface{} `json:"sudoorder"`
  
    MemberuserUser interface{} `json:"memberuser_user"`
  
    MemberuserGroup interface{} `json:"memberuser_group"`
  
    Externaluser interface{} `json:"externaluser"`
  
    MemberhostHost interface{} `json:"memberhost_host"`
  
    MemberhostHostgroup interface{} `json:"memberhost_hostgroup"`
  
    Hostmask interface{} `json:"hostmask"`
  
    Externalhost interface{} `json:"externalhost"`
  
    MemberallowcmdSudocmd interface{} `json:"memberallowcmd_sudocmd"`
  
    MemberdenycmdSudocmd interface{} `json:"memberdenycmd_sudocmd"`
  
    MemberallowcmdSudocmdgroup interface{} `json:"memberallowcmd_sudocmdgroup"`
  
    MemberdenycmdSudocmdgroup interface{} `json:"memberdenycmd_sudocmdgroup"`
  
    IpasudorunasUser interface{} `json:"ipasudorunas_user"`
  
    IpasudorunasGroup interface{} `json:"ipasudorunas_group"`
  
    Ipasudorunasextuser interface{} `json:"ipasudorunasextuser"`
  
    Ipasudorunasextusergroup interface{} `json:"ipasudorunasextusergroup"`
  
    IpasudorunasgroupGroup interface{} `json:"ipasudorunasgroup_group"`
  
    Ipasudorunasextgroup interface{} `json:"ipasudorunasextgroup"`
  
    Ipasudoopt interface{} `json:"ipasudoopt"`
  }

func (out *Sudorule) UnmarshalJSON(data []byte) error {
  var in jsonSudorule
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipaenabledflag != nil {
    raw := in.Ipaenabledflag
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipaenabledflag = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipaenabledflag = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipaenabledflag: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipaenabledflag: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Usercategory != nil {
    raw := in.Usercategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Usercategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Usercategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Usercategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Usercategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Hostcategory != nil {
    raw := in.Hostcategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Hostcategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Hostcategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Hostcategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Hostcategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Cmdcategory != nil {
    raw := in.Cmdcategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cmdcategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Cmdcategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Cmdcategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Cmdcategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipasudorunasusercategory != nil {
    raw := in.Ipasudorunasusercategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipasudorunasusercategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipasudorunasusercategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipasudorunasusercategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipasudorunasusercategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipasudorunasgroupcategory != nil {
    raw := in.Ipasudorunasgroupcategory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipasudorunasgroupcategory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipasudorunasgroupcategory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipasudorunasgroupcategory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipasudorunasgroupcategory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Sudoorder != nil {
    raw := in.Sudoorder
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Sudoorder: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Sudoorder = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Sudoorder = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Sudoorder: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Sudoorder: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberuserUser != nil {
    raw := in.MemberuserUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberuserUser = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberuserUser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberuserUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberuserGroup != nil {
    raw := in.MemberuserGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberuserGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberuserGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberuserGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Externaluser != nil {
    raw := in.Externaluser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Externaluser = &[]string{plainV}
      } else if sliceOk {
        
        out.Externaluser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Externaluser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberhostHost != nil {
    raw := in.MemberhostHost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberhostHost = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberhostHost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberhostHost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberhostHostgroup != nil {
    raw := in.MemberhostHostgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberhostHostgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberhostHostgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberhostHostgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Hostmask != nil {
    raw := in.Hostmask
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Hostmask = &[]string{plainV}
      } else if sliceOk {
        
        out.Hostmask = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Hostmask: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Externalhost != nil {
    raw := in.Externalhost
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Externalhost = &[]string{plainV}
      } else if sliceOk {
        
        out.Externalhost = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Externalhost: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberallowcmdSudocmd != nil {
    raw := in.MemberallowcmdSudocmd
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberallowcmdSudocmd = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberallowcmdSudocmd = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberallowcmdSudocmd: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberdenycmdSudocmd != nil {
    raw := in.MemberdenycmdSudocmd
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberdenycmdSudocmd = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberdenycmdSudocmd = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberdenycmdSudocmd: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberallowcmdSudocmdgroup != nil {
    raw := in.MemberallowcmdSudocmdgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberallowcmdSudocmdgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberallowcmdSudocmdgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberallowcmdSudocmdgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberdenycmdSudocmdgroup != nil {
    raw := in.MemberdenycmdSudocmdgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberdenycmdSudocmdgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberdenycmdSudocmdgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberdenycmdSudocmdgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpasudorunasUser != nil {
    raw := in.IpasudorunasUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpasudorunasUser = &[]string{plainV}
      } else if sliceOk {
        
        out.IpasudorunasUser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field IpasudorunasUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpasudorunasGroup != nil {
    raw := in.IpasudorunasGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpasudorunasGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.IpasudorunasGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field IpasudorunasGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipasudorunasextuser != nil {
    raw := in.Ipasudorunasextuser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipasudorunasextuser = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipasudorunasextuser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipasudorunasextuser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipasudorunasextusergroup != nil {
    raw := in.Ipasudorunasextusergroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipasudorunasextusergroup = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipasudorunasextusergroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipasudorunasextusergroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.IpasudorunasgroupGroup != nil {
    raw := in.IpasudorunasgroupGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.IpasudorunasgroupGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.IpasudorunasgroupGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field IpasudorunasgroupGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipasudorunasextgroup != nil {
    raw := in.Ipasudorunasextgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipasudorunasextgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipasudorunasextgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipasudorunasextgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipasudoopt != nil {
    raw := in.Ipasudoopt
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipasudoopt = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipasudoopt = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipasudoopt: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Topic struct {
  
    /*
Name

    */
    Name string `json:"name,omitempty"`
  
    /*
Version

    */
    Version string `json:"version,omitempty"`
  
    /*
Full name

    */
    FullName string `json:"full_name,omitempty"`
  
    /*
Documentation

    */
    Doc *string `json:"doc,omitempty"`
  
    /*
Exclude from

    */
    Exclude *[]string `json:"exclude,omitempty"`
  
    /*
Include in

    */
    Include *[]string `json:"include,omitempty"`
  
    /*
Help topic

    */
    TopicTopic *string `json:"topic_topic,omitempty"`
  }

func (t *Topic) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Topic[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Topic%v", string(b))
}

type jsonTopic struct {
  
    Name interface{} `json:"name"`
  
    Version interface{} `json:"version"`
  
    FullName interface{} `json:"full_name"`
  
    Doc interface{} `json:"doc"`
  
    Exclude interface{} `json:"exclude"`
  
    Include interface{} `json:"include"`
  
    TopicTopic interface{} `json:"topic_topic"`
  }

func (out *Topic) UnmarshalJSON(data []byte) error {
  var in jsonTopic
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Name
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Name = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Name: %v; expected exactly one element", raw)
          }
          out.Name = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Name: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Version
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Version = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Version: %v; expected exactly one element", raw)
          }
          out.Version = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Version: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.FullName
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.FullName = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field FullName: %v; expected exactly one element", raw)
          }
          out.FullName = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field FullName: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Doc != nil {
    raw := in.Doc
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Doc = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Doc = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Doc: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Doc: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Exclude != nil {
    raw := in.Exclude
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Exclude = &[]string{plainV}
      } else if sliceOk {
        
        out.Exclude = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Exclude: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Include != nil {
    raw := in.Include
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Include = &[]string{plainV}
      } else if sliceOk {
        
        out.Include = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Include: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.TopicTopic != nil {
    raw := in.TopicTopic
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.TopicTopic = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.TopicTopic = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field TopicTopic: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field TopicTopic: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Topologysegment struct {
  
    /*
Segment name
Arbitrary string identifying the segment
    */
    Cn string `json:"cn,omitempty"`
  
    /*
Left node
Left replication node - an IPA server
    */
    Iparepltoposegmentleftnode string `json:"iparepltoposegmentleftnode,omitempty"`
  
    /*
Right node
Right replication node - an IPA server
    */
    Iparepltoposegmentrightnode string `json:"iparepltoposegmentrightnode,omitempty"`
  
    /*
Connectivity
Direction of replication between left and right replication node
    */
    Iparepltoposegmentdirection string `json:"iparepltoposegmentdirection,omitempty"`
  
    /*
Attributes to strip
A space separated list of attributes which are removed from replication updates.
    */
    Nsds5replicastripattrs *string `json:"nsds5replicastripattrs,omitempty"`
  
    /*
Attributes to replicate
Attributes that are not replicated to a consumer server during a fractional update. E.g., `(objectclass=*) $ EXCLUDE accountlockout memberof
    */
    Nsds5replicatedattributelist *string `json:"nsds5replicatedattributelist,omitempty"`
  
    /*
Attributes for total update
Attributes that are not replicated to a consumer server during a total update. E.g. (objectclass=*) $ EXCLUDE accountlockout
    */
    Nsds5replicatedattributelisttotal *string `json:"nsds5replicatedattributelisttotal,omitempty"`
  
    /*
Session timeout
Number of seconds outbound LDAP operations waits for a response from the remote replica before timing out and failing
    */
    Nsds5replicatimeout *int `json:"nsds5replicatimeout,omitempty"`
  
    /*
Replication agreement enabled
Whether a replication agreement is active, meaning whether replication is occurring per that agreement
    */
    Nsds5replicaenabled *string `json:"nsds5replicaenabled,omitempty"`
  }

func (t *Topologysegment) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Topologysegment[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Topologysegment%v", string(b))
}

type jsonTopologysegment struct {
  
    Cn interface{} `json:"cn"`
  
    Iparepltoposegmentleftnode interface{} `json:"iparepltoposegmentleftnode"`
  
    Iparepltoposegmentrightnode interface{} `json:"iparepltoposegmentrightnode"`
  
    Iparepltoposegmentdirection interface{} `json:"iparepltoposegmentdirection"`
  
    Nsds5replicastripattrs interface{} `json:"nsds5replicastripattrs"`
  
    Nsds5replicatedattributelist interface{} `json:"nsds5replicatedattributelist"`
  
    Nsds5replicatedattributelisttotal interface{} `json:"nsds5replicatedattributelisttotal"`
  
    Nsds5replicatimeout interface{} `json:"nsds5replicatimeout"`
  
    Nsds5replicaenabled interface{} `json:"nsds5replicaenabled"`
  }

func (out *Topologysegment) UnmarshalJSON(data []byte) error {
  var in jsonTopologysegment
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Iparepltoposegmentleftnode
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Iparepltoposegmentleftnode = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Iparepltoposegmentleftnode: %v; expected exactly one element", raw)
          }
          out.Iparepltoposegmentleftnode = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Iparepltoposegmentleftnode: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Iparepltoposegmentrightnode
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Iparepltoposegmentrightnode = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Iparepltoposegmentrightnode: %v; expected exactly one element", raw)
          }
          out.Iparepltoposegmentrightnode = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Iparepltoposegmentrightnode: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Iparepltoposegmentdirection
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Iparepltoposegmentdirection = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Iparepltoposegmentdirection: %v; expected exactly one element", raw)
          }
          out.Iparepltoposegmentdirection = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Iparepltoposegmentdirection: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nsds5replicastripattrs != nil {
    raw := in.Nsds5replicastripattrs
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nsds5replicastripattrs = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Nsds5replicastripattrs = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Nsds5replicastripattrs: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Nsds5replicastripattrs: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nsds5replicatedattributelist != nil {
    raw := in.Nsds5replicatedattributelist
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nsds5replicatedattributelist = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Nsds5replicatedattributelist = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Nsds5replicatedattributelist: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Nsds5replicatedattributelist: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nsds5replicatedattributelisttotal != nil {
    raw := in.Nsds5replicatedattributelisttotal
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nsds5replicatedattributelisttotal = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Nsds5replicatedattributelisttotal = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Nsds5replicatedattributelisttotal: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Nsds5replicatedattributelisttotal: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nsds5replicatimeout != nil {
    raw := in.Nsds5replicatimeout
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Nsds5replicatimeout: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Nsds5replicatimeout = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Nsds5replicatimeout = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Nsds5replicatimeout: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Nsds5replicatimeout: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nsds5replicaenabled != nil {
    raw := in.Nsds5replicaenabled
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nsds5replicaenabled = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Nsds5replicaenabled = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Nsds5replicaenabled: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Nsds5replicaenabled: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Topologysuffix struct {
  
    /*
Suffix name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Managed LDAP suffix DN

    */
    Iparepltopoconfroot string `json:"iparepltopoconfroot,omitempty"`
  }

func (t *Topologysuffix) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Topologysuffix[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Topologysuffix%v", string(b))
}

type jsonTopologysuffix struct {
  
    Cn interface{} `json:"cn"`
  
    Iparepltopoconfroot interface{} `json:"iparepltopoconfroot"`
  }

func (out *Topologysuffix) UnmarshalJSON(data []byte) error {
  var in jsonTopologysuffix
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Iparepltopoconfroot
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Iparepltopoconfroot = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Iparepltopoconfroot: %v; expected exactly one element", raw)
          }
          out.Iparepltopoconfroot = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Iparepltopoconfroot: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Trust struct {
  
    /*
Realm name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Domain NetBIOS name

    */
    Ipantflatname string `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
SID blacklist incoming

    */
    Ipantsidblacklistincoming *[]string `json:"ipantsidblacklistincoming,omitempty"`
  
    /*
SID blacklist outgoing

    */
    Ipantsidblacklistoutgoing *[]string `json:"ipantsidblacklistoutgoing,omitempty"`
  
    /*
Trust direction

    */
    Trustdirection string `json:"trustdirection,omitempty"`
  
    /*
Trust type

    */
    Trusttype string `json:"trusttype,omitempty"`
  
    /*
Trust status

    */
    Truststatus string `json:"truststatus,omitempty"`
  
    /*
UPN suffixes

    */
    Ipantadditionalsuffixes *[]string `json:"ipantadditionalsuffixes,omitempty"`
  }

func (t *Trust) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Trust[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Trust%v", string(b))
}

type jsonTrust struct {
  
    Cn interface{} `json:"cn"`
  
    Ipantflatname interface{} `json:"ipantflatname"`
  
    Ipanttrusteddomainsid interface{} `json:"ipanttrusteddomainsid"`
  
    Ipantsidblacklistincoming interface{} `json:"ipantsidblacklistincoming"`
  
    Ipantsidblacklistoutgoing interface{} `json:"ipantsidblacklistoutgoing"`
  
    Trustdirection interface{} `json:"trustdirection"`
  
    Trusttype interface{} `json:"trusttype"`
  
    Truststatus interface{} `json:"truststatus"`
  
    Ipantadditionalsuffixes interface{} `json:"ipantadditionalsuffixes"`
  }

func (out *Trust) UnmarshalJSON(data []byte) error {
  var in jsonTrust
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipantflatname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipantflatname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipantflatname: %v; expected exactly one element", raw)
          }
          out.Ipantflatname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipantflatname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipanttrusteddomainsid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipanttrusteddomainsid = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipanttrusteddomainsid: %v; expected exactly one element", raw)
          }
          out.Ipanttrusteddomainsid = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipanttrusteddomainsid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipantsidblacklistincoming != nil {
    raw := in.Ipantsidblacklistincoming
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipantsidblacklistincoming = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipantsidblacklistincoming = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipantsidblacklistincoming: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipantsidblacklistoutgoing != nil {
    raw := in.Ipantsidblacklistoutgoing
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipantsidblacklistoutgoing = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipantsidblacklistoutgoing = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipantsidblacklistoutgoing: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Trustdirection
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Trustdirection = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Trustdirection: %v; expected exactly one element", raw)
          }
          out.Trustdirection = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Trustdirection: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Trusttype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Trusttype = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Trusttype: %v; expected exactly one element", raw)
          }
          out.Trusttype = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Trusttype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Truststatus
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Truststatus = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Truststatus: %v; expected exactly one element", raw)
          }
          out.Truststatus = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Truststatus: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipantadditionalsuffixes != nil {
    raw := in.Ipantadditionalsuffixes
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipantadditionalsuffixes = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipantadditionalsuffixes = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipantadditionalsuffixes: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Trustconfig struct {
  
    /*
Domain

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Security Identifier

    */
    Ipantsecurityidentifier string `json:"ipantsecurityidentifier,omitempty"`
  
    /*
NetBIOS name

    */
    Ipantflatname string `json:"ipantflatname,omitempty"`
  
    /*
Domain GUID

    */
    Ipantdomainguid string `json:"ipantdomainguid,omitempty"`
  
    /*
Fallback primary group

    */
    Ipantfallbackprimarygroup string `json:"ipantfallbackprimarygroup,omitempty"`
  
    /*
IPA AD trust agents
IPA servers configured as AD trust agents
    */
    AdTrustAgentServer *[]string `json:"ad_trust_agent_server,omitempty"`
  
    /*
IPA AD trust controllers
IPA servers configured as AD trust controllers
    */
    AdTrustControllerServer *[]string `json:"ad_trust_controller_server,omitempty"`
  }

func (t *Trustconfig) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Trustconfig[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Trustconfig%v", string(b))
}

type jsonTrustconfig struct {
  
    Cn interface{} `json:"cn"`
  
    Ipantsecurityidentifier interface{} `json:"ipantsecurityidentifier"`
  
    Ipantflatname interface{} `json:"ipantflatname"`
  
    Ipantdomainguid interface{} `json:"ipantdomainguid"`
  
    Ipantfallbackprimarygroup interface{} `json:"ipantfallbackprimarygroup"`
  
    AdTrustAgentServer interface{} `json:"ad_trust_agent_server"`
  
    AdTrustControllerServer interface{} `json:"ad_trust_controller_server"`
  }

func (out *Trustconfig) UnmarshalJSON(data []byte) error {
  var in jsonTrustconfig
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipantsecurityidentifier
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipantsecurityidentifier = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipantsecurityidentifier: %v; expected exactly one element", raw)
          }
          out.Ipantsecurityidentifier = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipantsecurityidentifier: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipantflatname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipantflatname = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipantflatname: %v; expected exactly one element", raw)
          }
          out.Ipantflatname = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipantflatname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipantdomainguid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipantdomainguid = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipantdomainguid: %v; expected exactly one element", raw)
          }
          out.Ipantdomainguid = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipantdomainguid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Ipantfallbackprimarygroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipantfallbackprimarygroup = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Ipantfallbackprimarygroup: %v; expected exactly one element", raw)
          }
          out.Ipantfallbackprimarygroup = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Ipantfallbackprimarygroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.AdTrustAgentServer != nil {
    raw := in.AdTrustAgentServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.AdTrustAgentServer = &[]string{plainV}
      } else if sliceOk {
        
        out.AdTrustAgentServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field AdTrustAgentServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.AdTrustControllerServer != nil {
    raw := in.AdTrustControllerServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.AdTrustControllerServer = &[]string{plainV}
      } else if sliceOk {
        
        out.AdTrustControllerServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field AdTrustControllerServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Trustdomain struct {
  
    /*
Domain name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Domain NetBIOS name

    */
    Ipantflatname *string `json:"ipantflatname,omitempty"`
  
    /*
Domain Security Identifier

    */
    Ipanttrusteddomainsid *string `json:"ipanttrusteddomainsid,omitempty"`
  
    /*
Domain enabled

    */
    DomainEnabled *bool `json:"domain_enabled,omitempty"`
  }

func (t *Trustdomain) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Trustdomain[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Trustdomain%v", string(b))
}

type jsonTrustdomain struct {
  
    Cn interface{} `json:"cn"`
  
    Ipantflatname interface{} `json:"ipantflatname"`
  
    Ipanttrusteddomainsid interface{} `json:"ipanttrusteddomainsid"`
  
    DomainEnabled interface{} `json:"domain_enabled"`
  }

func (out *Trustdomain) UnmarshalJSON(data []byte) error {
  var in jsonTrustdomain
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipantflatname != nil {
    raw := in.Ipantflatname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipantflatname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipantflatname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipantflatname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipantflatname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipanttrusteddomainsid != nil {
    raw := in.Ipanttrusteddomainsid
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipanttrusteddomainsid = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipanttrusteddomainsid = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipanttrusteddomainsid: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipanttrusteddomainsid: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.DomainEnabled != nil {
    raw := in.DomainEnabled
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.DomainEnabled = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.DomainEnabled = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field DomainEnabled: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field DomainEnabled: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type User struct {
  
    /*
User login

    */
    UID string `json:"uid,omitempty"`
  
    /*
First name

    */
    Givenname *string `json:"givenname,omitempty"`
  
    /*
Last name

    */
    Sn string `json:"sn,omitempty"`
  
    /*
Full name

    */
    Cn *string `json:"cn,omitempty"`
  
    /*
Display name

    */
    Displayname *string `json:"displayname,omitempty"`
  
    /*
Initials

    */
    Initials *string `json:"initials,omitempty"`
  
    /*
Home directory

    */
    Homedirectory *string `json:"homedirectory,omitempty"`
  
    /*
GECOS

    */
    Gecos *string `json:"gecos,omitempty"`
  
    /*
Login shell

    */
    Loginshell *string `json:"loginshell,omitempty"`
  
    /*
Principal name

    */
    Krbcanonicalname *string `json:"krbcanonicalname,omitempty"`
  
    /*
Principal alias

    */
    Krbprincipalname *[]string `json:"krbprincipalname,omitempty"`
  
    /*
Kerberos principal expiration

    */
    Krbprincipalexpiration *time.Time `json:"krbprincipalexpiration,omitempty"`
  
    /*
User password expiration

    */
    Krbpasswordexpiration *time.Time `json:"krbpasswordexpiration,omitempty"`
  
    /*
Email address

    */
    Mail *[]string `json:"mail,omitempty"`
  
    /*
Password
Prompt to set the user password
    */
    Userpassword *string `json:"userpassword,omitempty"`
  
    /*

Generate a random user password
    */
    Random *bool `json:"random,omitempty"`
  
    /*
Random password

    */
    Randompassword *string `json:"randompassword,omitempty"`
  
    /*
UID
User ID Number (system will assign one if not provided)
    */
    Uidnumber *int `json:"uidnumber,omitempty"`
  
    /*
GID
Group ID Number
    */
    Gidnumber *int `json:"gidnumber,omitempty"`
  
    /*
Street address

    */
    Street *string `json:"street,omitempty"`
  
    /*
City

    */
    L *string `json:"l,omitempty"`
  
    /*
State/Province

    */
    St *string `json:"st,omitempty"`
  
    /*
ZIP

    */
    Postalcode *string `json:"postalcode,omitempty"`
  
    /*
Telephone Number

    */
    Telephonenumber *[]string `json:"telephonenumber,omitempty"`
  
    /*
Mobile Telephone Number

    */
    Mobile *[]string `json:"mobile,omitempty"`
  
    /*
Pager Number

    */
    Pager *[]string `json:"pager,omitempty"`
  
    /*
Fax Number

    */
    Facsimiletelephonenumber *[]string `json:"facsimiletelephonenumber,omitempty"`
  
    /*
Org. Unit

    */
    Ou *string `json:"ou,omitempty"`
  
    /*
Job Title

    */
    Title *string `json:"title,omitempty"`
  
    /*
Manager

    */
    Manager *string `json:"manager,omitempty"`
  
    /*
Car License

    */
    Carlicense *[]string `json:"carlicense,omitempty"`
  
    /*
SSH public key

    */
    Ipasshpubkey *[]string `json:"ipasshpubkey,omitempty"`
  
    /*
SSH public key fingerprint

    */
    Sshpubkeyfp *[]string `json:"sshpubkeyfp,omitempty"`
  
    /*
User authentication types
Types of supported user authentication
    */
    Ipauserauthtype *[]string `json:"ipauserauthtype,omitempty"`
  
    /*
Class
User category (semantics placed on this attribute are for local interpretation)
    */
    Userclass *[]string `json:"userclass,omitempty"`
  
    /*
RADIUS proxy configuration

    */
    Ipatokenradiusconfiglink *string `json:"ipatokenradiusconfiglink,omitempty"`
  
    /*
RADIUS proxy username

    */
    Ipatokenradiususername *string `json:"ipatokenradiususername,omitempty"`
  
    /*
Department Number

    */
    Departmentnumber *[]string `json:"departmentnumber,omitempty"`
  
    /*
Employee Number

    */
    Employeenumber *string `json:"employeenumber,omitempty"`
  
    /*
Employee Type

    */
    Employeetype *string `json:"employeetype,omitempty"`
  
    /*
Preferred Language

    */
    Preferredlanguage *string `json:"preferredlanguage,omitempty"`
  
    /*
Certificate
Base-64 encoded user certificate
    */
    Usercertificate *[]interface{} `json:"usercertificate,omitempty"`
  
    /*
Certificate mapping data
Certificate mapping data
    */
    Ipacertmapdata *[]string `json:"ipacertmapdata,omitempty"`
  
    /*
Account disabled

    */
    Nsaccountlock *bool `json:"nsaccountlock,omitempty"`
  
    /*
Preserved user

    */
    Preserved *bool `json:"preserved,omitempty"`
  
    /*
Password

    */
    HasPassword *bool `json:"has_password,omitempty"`
  
    /*
Member of groups

    */
    MemberofGroup *[]string `json:"memberof_group,omitempty"`
  
    /*
Roles

    */
    MemberofRole *[]string `json:"memberof_role,omitempty"`
  
    /*
Member of netgroups

    */
    MemberofNetgroup *[]string `json:"memberof_netgroup,omitempty"`
  
    /*
Member of Sudo rule

    */
    MemberofSudorule *[]string `json:"memberof_sudorule,omitempty"`
  
    /*
Member of HBAC rule

    */
    MemberofHbacrule *[]string `json:"memberof_hbacrule,omitempty"`
  
    /*
Indirect Member of group

    */
    MemberofindirectGroup *[]string `json:"memberofindirect_group,omitempty"`
  
    /*
Indirect Member of netgroup

    */
    MemberofindirectNetgroup *[]string `json:"memberofindirect_netgroup,omitempty"`
  
    /*
Indirect Member of role

    */
    MemberofindirectRole *[]string `json:"memberofindirect_role,omitempty"`
  
    /*
Indirect Member of Sudo rule

    */
    MemberofindirectSudorule *[]string `json:"memberofindirect_sudorule,omitempty"`
  
    /*
Indirect Member of HBAC rule

    */
    MemberofindirectHbacrule *[]string `json:"memberofindirect_hbacrule,omitempty"`
  
    /*
Kerberos keys available

    */
    HasKeytab *bool `json:"has_keytab,omitempty"`
  }

func (t *User) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("User[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("User%v", string(b))
}

type jsonUser struct {
  
    UID interface{} `json:"uid"`
  
    Givenname interface{} `json:"givenname"`
  
    Sn interface{} `json:"sn"`
  
    Cn interface{} `json:"cn"`
  
    Displayname interface{} `json:"displayname"`
  
    Initials interface{} `json:"initials"`
  
    Homedirectory interface{} `json:"homedirectory"`
  
    Gecos interface{} `json:"gecos"`
  
    Loginshell interface{} `json:"loginshell"`
  
    Krbcanonicalname interface{} `json:"krbcanonicalname"`
  
    Krbprincipalname interface{} `json:"krbprincipalname"`
  
    Krbprincipalexpiration interface{} `json:"krbprincipalexpiration"`
  
    Krbpasswordexpiration interface{} `json:"krbpasswordexpiration"`
  
    Mail interface{} `json:"mail"`
  
    Userpassword interface{} `json:"userpassword"`
  
    Random interface{} `json:"random"`
  
    Randompassword interface{} `json:"randompassword"`
  
    Uidnumber interface{} `json:"uidnumber"`
  
    Gidnumber interface{} `json:"gidnumber"`
  
    Street interface{} `json:"street"`
  
    L interface{} `json:"l"`
  
    St interface{} `json:"st"`
  
    Postalcode interface{} `json:"postalcode"`
  
    Telephonenumber interface{} `json:"telephonenumber"`
  
    Mobile interface{} `json:"mobile"`
  
    Pager interface{} `json:"pager"`
  
    Facsimiletelephonenumber interface{} `json:"facsimiletelephonenumber"`
  
    Ou interface{} `json:"ou"`
  
    Title interface{} `json:"title"`
  
    Manager interface{} `json:"manager"`
  
    Carlicense interface{} `json:"carlicense"`
  
    Ipasshpubkey interface{} `json:"ipasshpubkey"`
  
    Sshpubkeyfp interface{} `json:"sshpubkeyfp"`
  
    Ipauserauthtype interface{} `json:"ipauserauthtype"`
  
    Userclass interface{} `json:"userclass"`
  
    Ipatokenradiusconfiglink interface{} `json:"ipatokenradiusconfiglink"`
  
    Ipatokenradiususername interface{} `json:"ipatokenradiususername"`
  
    Departmentnumber interface{} `json:"departmentnumber"`
  
    Employeenumber interface{} `json:"employeenumber"`
  
    Employeetype interface{} `json:"employeetype"`
  
    Preferredlanguage interface{} `json:"preferredlanguage"`
  
    Usercertificate interface{} `json:"usercertificate"`
  
    Ipacertmapdata interface{} `json:"ipacertmapdata"`
  
    Nsaccountlock interface{} `json:"nsaccountlock"`
  
    Preserved interface{} `json:"preserved"`
  
    HasPassword interface{} `json:"has_password"`
  
    MemberofGroup interface{} `json:"memberof_group"`
  
    MemberofRole interface{} `json:"memberof_role"`
  
    MemberofNetgroup interface{} `json:"memberof_netgroup"`
  
    MemberofSudorule interface{} `json:"memberof_sudorule"`
  
    MemberofHbacrule interface{} `json:"memberof_hbacrule"`
  
    MemberofindirectGroup interface{} `json:"memberofindirect_group"`
  
    MemberofindirectNetgroup interface{} `json:"memberofindirect_netgroup"`
  
    MemberofindirectRole interface{} `json:"memberofindirect_role"`
  
    MemberofindirectSudorule interface{} `json:"memberofindirect_sudorule"`
  
    MemberofindirectHbacrule interface{} `json:"memberofindirect_hbacrule"`
  
    HasKeytab interface{} `json:"has_keytab"`
  }

func (out *User) UnmarshalJSON(data []byte) error {
  var in jsonUser
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.UID
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.UID = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field UID: %v; expected exactly one element", raw)
          }
          out.UID = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field UID: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Givenname != nil {
    raw := in.Givenname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Givenname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Givenname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Givenname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Givenname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Sn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Sn: %v; expected exactly one element", raw)
          }
          out.Sn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Sn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Cn != nil {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Cn = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Displayname != nil {
    raw := in.Displayname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Displayname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Displayname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Displayname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Displayname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Initials != nil {
    raw := in.Initials
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Initials = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Initials = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Initials: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Initials: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Homedirectory != nil {
    raw := in.Homedirectory
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Homedirectory = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Homedirectory = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Homedirectory: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Homedirectory: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Gecos != nil {
    raw := in.Gecos
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Gecos = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Gecos = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Gecos: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Gecos: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Loginshell != nil {
    raw := in.Loginshell
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Loginshell = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Loginshell = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Loginshell: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Loginshell: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbcanonicalname != nil {
    raw := in.Krbcanonicalname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbcanonicalname = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbcanonicalname = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbcanonicalname: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbcanonicalname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbprincipalname != nil {
    raw := in.Krbprincipalname
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbprincipalname = &[]string{plainV}
      } else if sliceOk {
        
        out.Krbprincipalname = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Krbprincipalname: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbprincipalexpiration != nil {
    raw := in.Krbprincipalexpiration
    plainV, plainOk := raw.(time.Time)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []time.Time
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(time.Time)
        
        if !itemOk {
          
          // See https://github.com/ccin2p3/go-freeipa/issues/1
          mapV, mapVOk := rawItem.(map[string]interface{})
          if mapVOk {
            timeV, err := tryParseFreeIPADatetimeMap(mapV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = timeV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbprincipalexpiration = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbprincipalexpiration = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbprincipalexpiration: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbprincipalexpiration: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Krbpasswordexpiration != nil {
    raw := in.Krbpasswordexpiration
    plainV, plainOk := raw.(time.Time)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []time.Time
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(time.Time)
        
        if !itemOk {
          
          // See https://github.com/ccin2p3/go-freeipa/issues/1
          mapV, mapVOk := rawItem.(map[string]interface{})
          if mapVOk {
            timeV, err := tryParseFreeIPADatetimeMap(mapV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = timeV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbpasswordexpiration = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Krbpasswordexpiration = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Krbpasswordexpiration: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Krbpasswordexpiration: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Mail != nil {
    raw := in.Mail
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Mail = &[]string{plainV}
      } else if sliceOk {
        
        out.Mail = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Mail: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Userpassword != nil {
    raw := in.Userpassword
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Userpassword = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Userpassword = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Userpassword: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Userpassword: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Random != nil {
    raw := in.Random
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Random = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Random = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Random: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Random: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Randompassword != nil {
    raw := in.Randompassword
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Randompassword = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Randompassword = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Randompassword: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Randompassword: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Uidnumber != nil {
    raw := in.Uidnumber
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Uidnumber: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Uidnumber = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Uidnumber = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Uidnumber: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Uidnumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Gidnumber != nil {
    raw := in.Gidnumber
    plainV, plainOk := raw.(int)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []int
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        intV, e := strconv.Atoi(itemV)
        if e != nil {
          return fmt.Errorf("unexpected value for field Gidnumber: %v (hit string which couldn't be converted to int)", raw)
        }
        sliceV = append(sliceV, intV)
        
      }
    }
    
      if plainOk {
        out.Gidnumber = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Gidnumber = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Gidnumber: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Gidnumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Street != nil {
    raw := in.Street
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Street = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Street = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Street: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Street: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.L != nil {
    raw := in.L
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.L = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.L = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field L: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field L: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.St != nil {
    raw := in.St
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.St = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.St = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field St: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field St: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Postalcode != nil {
    raw := in.Postalcode
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Postalcode = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Postalcode = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Postalcode: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Postalcode: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Telephonenumber != nil {
    raw := in.Telephonenumber
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Telephonenumber = &[]string{plainV}
      } else if sliceOk {
        
        out.Telephonenumber = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Telephonenumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Mobile != nil {
    raw := in.Mobile
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Mobile = &[]string{plainV}
      } else if sliceOk {
        
        out.Mobile = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Mobile: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Pager != nil {
    raw := in.Pager
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Pager = &[]string{plainV}
      } else if sliceOk {
        
        out.Pager = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Pager: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Facsimiletelephonenumber != nil {
    raw := in.Facsimiletelephonenumber
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Facsimiletelephonenumber = &[]string{plainV}
      } else if sliceOk {
        
        out.Facsimiletelephonenumber = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Facsimiletelephonenumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ou != nil {
    raw := in.Ou
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ou = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ou = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ou: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ou: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Title != nil {
    raw := in.Title
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Title = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Title = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Title: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Title: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Manager != nil {
    raw := in.Manager
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Manager = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Manager = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Manager: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Manager: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Carlicense != nil {
    raw := in.Carlicense
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Carlicense = &[]string{plainV}
      } else if sliceOk {
        
        out.Carlicense = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Carlicense: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipasshpubkey != nil {
    raw := in.Ipasshpubkey
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipasshpubkey = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipasshpubkey = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipasshpubkey: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Sshpubkeyfp != nil {
    raw := in.Sshpubkeyfp
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Sshpubkeyfp = &[]string{plainV}
      } else if sliceOk {
        
        out.Sshpubkeyfp = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Sshpubkeyfp: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipauserauthtype != nil {
    raw := in.Ipauserauthtype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipauserauthtype = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipauserauthtype = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipauserauthtype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Userclass != nil {
    raw := in.Userclass
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Userclass = &[]string{plainV}
      } else if sliceOk {
        
        out.Userclass = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Userclass: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenradiusconfiglink != nil {
    raw := in.Ipatokenradiusconfiglink
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenradiusconfiglink = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenradiusconfiglink = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenradiusconfiglink: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenradiusconfiglink: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipatokenradiususername != nil {
    raw := in.Ipatokenradiususername
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipatokenradiususername = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipatokenradiususername = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipatokenradiususername: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipatokenradiususername: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Departmentnumber != nil {
    raw := in.Departmentnumber
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Departmentnumber = &[]string{plainV}
      } else if sliceOk {
        
        out.Departmentnumber = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Departmentnumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Employeenumber != nil {
    raw := in.Employeenumber
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Employeenumber = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Employeenumber = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Employeenumber: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Employeenumber: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Employeetype != nil {
    raw := in.Employeetype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Employeetype = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Employeetype = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Employeetype: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Employeetype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Preferredlanguage != nil {
    raw := in.Preferredlanguage
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Preferredlanguage = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Preferredlanguage = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Preferredlanguage: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Preferredlanguage: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Usercertificate != nil {
    raw := in.Usercertificate
    plainV, plainOk := raw.(interface{})
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []interface{}
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(interface{})
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Usercertificate = &[]interface{}{plainV}
      } else if sliceOk {
        
        out.Usercertificate = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Usercertificate: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipacertmapdata != nil {
    raw := in.Ipacertmapdata
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipacertmapdata = &[]string{plainV}
      } else if sliceOk {
        
        out.Ipacertmapdata = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field Ipacertmapdata: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Nsaccountlock != nil {
    raw := in.Nsaccountlock
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Nsaccountlock = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Nsaccountlock = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Nsaccountlock: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Nsaccountlock: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Preserved != nil {
    raw := in.Preserved
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Preserved = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Preserved = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Preserved: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Preserved: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.HasPassword != nil {
    raw := in.HasPassword
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.HasPassword = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.HasPassword = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field HasPassword: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field HasPassword: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofGroup != nil {
    raw := in.MemberofGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofRole != nil {
    raw := in.MemberofRole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofRole = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofRole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofRole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofNetgroup != nil {
    raw := in.MemberofNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofSudorule != nil {
    raw := in.MemberofSudorule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofSudorule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofSudorule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofSudorule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofHbacrule != nil {
    raw := in.MemberofHbacrule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofHbacrule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofHbacrule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofHbacrule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectGroup != nil {
    raw := in.MemberofindirectGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectNetgroup != nil {
    raw := in.MemberofindirectNetgroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectNetgroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectNetgroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectNetgroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectRole != nil {
    raw := in.MemberofindirectRole
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectRole = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectRole = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectRole: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectSudorule != nil {
    raw := in.MemberofindirectSudorule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectSudorule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectSudorule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectSudorule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberofindirectHbacrule != nil {
    raw := in.MemberofindirectHbacrule
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberofindirectHbacrule = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberofindirectHbacrule = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberofindirectHbacrule: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.HasKeytab != nil {
    raw := in.HasKeytab
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.HasKeytab = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.HasKeytab = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field HasKeytab: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field HasKeytab: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Userstatus struct {
  
    /*
Preserved user

    */
    Preserved *bool `json:"preserved,omitempty"`
  
    /*
Server

    */
    Server string `json:"server,omitempty"`
  
    /*
Failed logins

    */
    Krbloginfailedcount string `json:"krbloginfailedcount,omitempty"`
  
    /*
Last successful authentication

    */
    Krblastsuccessfulauth string `json:"krblastsuccessfulauth,omitempty"`
  
    /*
Last failed authentication

    */
    Krblastfailedauth string `json:"krblastfailedauth,omitempty"`
  
    /*
Time now

    */
    Now string `json:"now,omitempty"`
  }

func (t *Userstatus) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Userstatus[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Userstatus%v", string(b))
}

type jsonUserstatus struct {
  
    Preserved interface{} `json:"preserved"`
  
    Server interface{} `json:"server"`
  
    Krbloginfailedcount interface{} `json:"krbloginfailedcount"`
  
    Krblastsuccessfulauth interface{} `json:"krblastsuccessfulauth"`
  
    Krblastfailedauth interface{} `json:"krblastfailedauth"`
  
    Now interface{} `json:"now"`
  }

func (out *Userstatus) UnmarshalJSON(data []byte) error {
  var in jsonUserstatus
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.Preserved != nil {
    raw := in.Preserved
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Preserved = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Preserved = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Preserved: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Preserved: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Server
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Server = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Server: %v; expected exactly one element", raw)
          }
          out.Server = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Server: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Krbloginfailedcount
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krbloginfailedcount = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Krbloginfailedcount: %v; expected exactly one element", raw)
          }
          out.Krbloginfailedcount = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Krbloginfailedcount: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Krblastsuccessfulauth
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krblastsuccessfulauth = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Krblastsuccessfulauth: %v; expected exactly one element", raw)
          }
          out.Krblastsuccessfulauth = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Krblastsuccessfulauth: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Krblastfailedauth
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Krblastfailedauth = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Krblastfailedauth: %v; expected exactly one element", raw)
          }
          out.Krblastfailedauth = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Krblastfailedauth: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if true {
    raw := in.Now
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Now = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Now: %v; expected exactly one element", raw)
          }
          out.Now = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Now: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Vault struct {
  
    /*
Vault name

    */
    Cn string `json:"cn,omitempty"`
  
    /*
Description
Vault description
    */
    Description *string `json:"description,omitempty"`
  
    /*
Type
Vault type
    */
    Ipavaulttype *string `json:"ipavaulttype,omitempty"`
  
    /*
Salt
Vault salt
    */
    Ipavaultsalt *string `json:"ipavaultsalt,omitempty"`
  
    /*
Public key
Vault public key
    */
    Ipavaultpublickey *string `json:"ipavaultpublickey,omitempty"`
  
    /*
Owner users

    */
    OwnerUser *string `json:"owner_user,omitempty"`
  
    /*
Owner groups

    */
    OwnerGroup *string `json:"owner_group,omitempty"`
  
    /*
Owner services

    */
    OwnerService *string `json:"owner_service,omitempty"`
  
    /*
Failed owners

    */
    Owner *string `json:"owner,omitempty"`
  
    /*
Vault service

    */
    Service *string `json:"service,omitempty"`
  
    /*
Shared vault

    */
    Shared *bool `json:"shared,omitempty"`
  
    /*
Vault user

    */
    Username *string `json:"username,omitempty"`
  
    /*
Member users

    */
    MemberUser *[]string `json:"member_user,omitempty"`
  
    /*
Member groups

    */
    MemberGroup *[]string `json:"member_group,omitempty"`
  
    /*
Member services

    */
    MemberService *[]string `json:"member_service,omitempty"`
  }

func (t *Vault) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Vault[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Vault%v", string(b))
}

type jsonVault struct {
  
    Cn interface{} `json:"cn"`
  
    Description interface{} `json:"description"`
  
    Ipavaulttype interface{} `json:"ipavaulttype"`
  
    Ipavaultsalt interface{} `json:"ipavaultsalt"`
  
    Ipavaultpublickey interface{} `json:"ipavaultpublickey"`
  
    OwnerUser interface{} `json:"owner_user"`
  
    OwnerGroup interface{} `json:"owner_group"`
  
    OwnerService interface{} `json:"owner_service"`
  
    Owner interface{} `json:"owner"`
  
    Service interface{} `json:"service"`
  
    Shared interface{} `json:"shared"`
  
    Username interface{} `json:"username"`
  
    MemberUser interface{} `json:"member_user"`
  
    MemberGroup interface{} `json:"member_group"`
  
    MemberService interface{} `json:"member_service"`
  }

func (out *Vault) UnmarshalJSON(data []byte) error {
  var in jsonVault
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.Cn
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Cn = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field Cn: %v; expected exactly one element", raw)
          }
          out.Cn = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field Cn: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Description != nil {
    raw := in.Description
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Description = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Description = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Description: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Description: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipavaulttype != nil {
    raw := in.Ipavaulttype
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipavaulttype = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipavaulttype = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipavaulttype: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipavaulttype: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipavaultsalt != nil {
    raw := in.Ipavaultsalt
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipavaultsalt = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipavaultsalt = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipavaultsalt: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipavaultsalt: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Ipavaultpublickey != nil {
    raw := in.Ipavaultpublickey
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Ipavaultpublickey = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Ipavaultpublickey = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Ipavaultpublickey: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Ipavaultpublickey: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.OwnerUser != nil {
    raw := in.OwnerUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.OwnerUser = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.OwnerUser = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field OwnerUser: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field OwnerUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.OwnerGroup != nil {
    raw := in.OwnerGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.OwnerGroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.OwnerGroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field OwnerGroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field OwnerGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.OwnerService != nil {
    raw := in.OwnerService
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.OwnerService = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.OwnerService = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field OwnerService: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field OwnerService: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Owner != nil {
    raw := in.Owner
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Owner = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Owner = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Owner: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Owner: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Service != nil {
    raw := in.Service
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Service = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Service = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Service: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Service: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Shared != nil {
    raw := in.Shared
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Shared = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Shared = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Shared: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Shared: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Username != nil {
    raw := in.Username
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Username = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Username = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Username: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Username: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberUser != nil {
    raw := in.MemberUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberUser = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberUser = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberGroup != nil {
    raw := in.MemberGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberGroup = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberGroup = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.MemberService != nil {
    raw := in.MemberService
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.MemberService = &[]string{plainV}
      } else if sliceOk {
        
        out.MemberService = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field MemberService: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Vaultconfig struct {
  
    /*
Transport Certificate

    */
    TransportCert string `json:"transport_cert,omitempty"`
  
    /*
IPA KRA servers
IPA servers configured as key recovery agents
    */
    KraServerServer *[]string `json:"kra_server_server,omitempty"`
  }

func (t *Vaultconfig) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Vaultconfig[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Vaultconfig%v", string(b))
}

type jsonVaultconfig struct {
  
    TransportCert interface{} `json:"transport_cert"`
  
    KraServerServer interface{} `json:"kra_server_server"`
  }

func (out *Vaultconfig) UnmarshalJSON(data []byte) error {
  var in jsonVaultconfig
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if true {
    raw := in.TransportCert
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.TransportCert = plainV
      } else if sliceOk {
        
          if len(sliceV) != 1 {
            return fmt.Errorf("unexpected value for field TransportCert: %v; expected exactly one element", raw)
          }
          out.TransportCert = sliceV[0]
        
      } else {
        return fmt.Errorf("unexpected value for field TransportCert: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.KraServerServer != nil {
    raw := in.KraServerServer
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.KraServerServer = &[]string{plainV}
      } else if sliceOk {
        
        out.KraServerServer = &sliceV
      } else {
        return fmt.Errorf("unexpected value for field KraServerServer: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}

type Vaultcontainer struct {
  
    /*
Owner users

    */
    OwnerUser *string `json:"owner_user,omitempty"`
  
    /*
Owner groups

    */
    OwnerGroup *string `json:"owner_group,omitempty"`
  
    /*
Owner services

    */
    OwnerService *string `json:"owner_service,omitempty"`
  
    /*
Failed owners

    */
    Owner *string `json:"owner,omitempty"`
  
    /*
Vault service

    */
    Service *string `json:"service,omitempty"`
  
    /*
Shared vault

    */
    Shared *bool `json:"shared,omitempty"`
  
    /*
Vault user

    */
    Username *string `json:"username,omitempty"`
  }

func (t *Vaultcontainer) String() string {
  if t == nil {
    return "<nil>"
  }
  b, e := json.Marshal(t)
  if e != nil {
    return fmt.Sprintf("Vaultcontainer[failed json.Marshal: %v]", e)
  }
  return fmt.Sprintf("Vaultcontainer%v", string(b))
}

type jsonVaultcontainer struct {
  
    OwnerUser interface{} `json:"owner_user"`
  
    OwnerGroup interface{} `json:"owner_group"`
  
    OwnerService interface{} `json:"owner_service"`
  
    Owner interface{} `json:"owner"`
  
    Service interface{} `json:"service"`
  
    Shared interface{} `json:"shared"`
  
    Username interface{} `json:"username"`
  }

func (out *Vaultcontainer) UnmarshalJSON(data []byte) error {
  var in jsonVaultcontainer
  if e := json.Unmarshal(data, &in); e != nil {
    return e
  }
  
  if in.OwnerUser != nil {
    raw := in.OwnerUser
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.OwnerUser = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.OwnerUser = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field OwnerUser: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field OwnerUser: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.OwnerGroup != nil {
    raw := in.OwnerGroup
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.OwnerGroup = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.OwnerGroup = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field OwnerGroup: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field OwnerGroup: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.OwnerService != nil {
    raw := in.OwnerService
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.OwnerService = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.OwnerService = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field OwnerService: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field OwnerService: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Owner != nil {
    raw := in.Owner
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Owner = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Owner = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Owner: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Owner: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Service != nil {
    raw := in.Service
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Service = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Service = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Service: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Service: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Shared != nil {
    raw := in.Shared
    plainV, plainOk := raw.(bool)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []bool
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(bool)
        
        if !itemOk {
          
          // See https://github.com/tehwalris/go-freeipa/issues/3
          // Sometimes IPA returns ["TRUE"] as a boolean value
          strV, strOk := rawItem.(string)
          if strOk {
            boolV, err := strconv.ParseBool(strV)
            if err != nil {
              sliceOk = false
              break
            }

            itemV = boolV
          } else {
            sliceOk = false
            break
          }
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Shared = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Shared = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Shared: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Shared: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  
  if in.Username != nil {
    raw := in.Username
    plainV, plainOk := raw.(string)
    sliceWrapperV, sliceWrapperOk := raw.([]interface{})
    var sliceV []string
    sliceOk := sliceWrapperOk
    if sliceWrapperOk {
      for _, rawItem := range sliceWrapperV {
        
        itemV, itemOk := rawItem.(string)
        
        if !itemOk {
          
          sliceOk = false
          break
          

        }
        
        sliceV = append(sliceV, itemV)
        
      }
    }
    
      if plainOk {
        out.Username = &plainV
      } else if sliceOk {
        
          if len(sliceV) == 1 {
            out.Username = &sliceV[0]
          } else if len(sliceV) > 1 {
            return fmt.Errorf("unexpected value for field Username: %v; expected at most one element", raw)
          }
        
      } else {
        return fmt.Errorf("unexpected value for field Username: %v (%v)", raw, reflect.TypeOf(raw))
      }
    
  }
  return nil
}



const PublicErrorCode = 900

const VersionErrorCode = 901

const UnknownErrorCode = 902

const InternalErrorCode = 903

const ServerInternalErrorCode = 904

const CommandErrorCode = 905

const ServerCommandErrorCode = 906

const NetworkErrorCode = 907

const ServerNetworkErrorCode = 908

const JSONErrorCode = 909

const XMLRPCMarshallErrorCode = 910

const RefererErrorCode = 911

const EnvironmentErrorCode = 912

const SystemEncodingErrorCode = 913

const AuthenticationErrorCode = 1000

const KerberosErrorCode = 1100

const CCacheErrorCode = 1101

const ServiceErrorCode = 1102

const NoCCacheErrorCode = 1103

const TicketExpiredCode = 1104

const BadCCachePermsCode = 1105

const BadCCacheFormatCode = 1106

const CannotResolveKDCCode = 1107

const SessionErrorCode = 1200

const InvalidSessionPasswordCode = 1201

const PasswordExpiredCode = 1202

const KrbPrincipalExpiredCode = 1203

const UserLockedCode = 1204

const AuthorizationErrorCode = 2000

const ACIErrorCode = 2100

const InvocationErrorCode = 3000

const EncodingErrorCode = 3001

const BinaryEncodingErrorCode = 3002

const ZeroArgumentErrorCode = 3003

const MaxArgumentErrorCode = 3004

const OptionErrorCode = 3005

const OverlapErrorCode = 3006

const RequirementErrorCode = 3007

const ConversionErrorCode = 3008

const ValidationErrorCode = 3009

const NoSuchNamespaceErrorCode = 3010

const PasswordMismatchCode = 3011

const NotImplementedErrorCode = 3012

const NotConfiguredErrorCode = 3013

const PromptFailedCode = 3014

const DeprecationErrorCode = 3015

const NotAForestRootErrorCode = 3016

const ExecutionErrorCode = 4000

const NotFoundCode = 4001

const DuplicateEntryCode = 4002

const HostServiceCode = 4003

const MalformedServicePrincipalCode = 4004

const RealmMismatchCode = 4005

const RequiresRootCode = 4006

const AlreadyPosixGroupCode = 4007

const MalformedUserPrincipalCode = 4008

const AlreadyActiveCode = 4009

const AlreadyInactiveCode = 4010

const HasNSAccountLockCode = 4011

const NotGroupMemberCode = 4012

const RecursiveGroupCode = 4013

const AlreadyGroupMemberCode = 4014

const Base64DecodeErrorCode = 4015

const RemoteRetrieveErrorCode = 4016

const SameGroupErrorCode = 4017

const DefaultGroupErrorCode = 4018

const DNSNotARecordErrorCode = 4019

const ManagedGroupErrorCode = 4020

const ManagedPolicyErrorCode = 4021

const FileErrorCode = 4022

const NoCertificateErrorCode = 4023

const ManagedGroupExistsErrorCode = 4024

const ReverseMemberErrorCode = 4025

const AttrValueNotFoundCode = 4026

const SingleMatchExpectedCode = 4027

const AlreadyExternalGroupCode = 4028

const ExternalGroupViolationCode = 4029

const PosixGroupViolationCode = 4030

const EmptyResultCode = 4031

const InvalidDomainLevelErrorCode = 4032

const ServerRemovalErrorCode = 4033

const OperationNotSupportedForPrincipalTypeCode = 4034

const HTTPRequestErrorCode = 4035

const RedundantMappingRuleCode = 4036

const CSRTemplateErrorCode = 4037

const AlreadyContainsValueErrorCode = 4038

const BuiltinErrorCode = 4100

const HelpErrorCode = 4101

const LDAPErrorCode = 4200

const MidairCollisionCode = 4201

const EmptyModlistCode = 4202

const DatabaseErrorCode = 4203

const LimitsExceededCode = 4204

const ObjectclassViolationCode = 4205

const NotAllowedOnRDNCode = 4206

const OnlyOneValueAllowedCode = 4207

const InvalidSyntaxCode = 4208

const BadSearchFilterCode = 4209

const NotAllowedOnNonLeafCode = 4210

const DatabaseTimeoutCode = 4211

const DNSDataMismatchCode = 4212

const TaskTimeoutCode = 4213

const TimeLimitExceededCode = 4214

const SizeLimitExceededCode = 4215

const AdminLimitExceededCode = 4216

const CertificateErrorCode = 4300

const CertificateOperationErrorCode = 4301

const CertificateFormatErrorCode = 4302

const MutuallyExclusiveErrorCode = 4303

const NonFatalErrorCode = 4304

const AlreadyRegisteredErrorCode = 4305

const NotRegisteredErrorCode = 4306

const DependentEntryCode = 4307

const LastMemberErrorCode = 4308

const ProtectedEntryErrorCode = 4309

const CertificateInvalidErrorCode = 4310

const SchemaUpToDateCode = 4311

const DNSErrorCode = 4400

const DNSResolverErrorCode = 4401

const TrustErrorCode = 4500

const TrustTopologyConflictErrorCode = 4501

const GenericErrorCode = 5000
